/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2001
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 * meta.h
 *
 * Project:
 * --------
 *   META
 *
 * Description:
 * ------------
 *   This module contains the definitions for using META_DLL.dll.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *           HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 Traditional calibration (RX LNA / 8-level PA control
 FHC (RX LNA / 8-level PA control)
 NSFT

 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/
#ifndef META_DLL_H
#define META_DLL_H


#include "brom.h"




#ifdef __cplusplus
extern "C" {
#endif


#define __META_DLL_WCDMA__

//--------------------------------------------------------------------------//
//  META General                                                            //
//--------------------------------------------------------------------------//

#define META_DEFAULT_SHORT_TIMEOUT  1000
#define META_DEFAULT_MID_TIMEOUT    3000
#define META_DEFAULT_LONG_TIMEOUT   5000

//-----------------------------------------------------//
//  META General: data structure definition            //
//-----------------------------------------------------//
typedef enum
{
    // META_DLL received a corrupted frame
    META_CNF_FRAME_ERROR = 0,

    // META_DLL received a confirm or indication from target,
    // but there is not corresponding call back function
    // installed for this confirm or indication.
    META_CNF_NO_CALLBACK = 1,

    // META_DLL received a corrupted primitive.
    META_CNF_PRIMITIVE_ERROR = 2,

    // META_DLL received a confirm or indication from
    // target, but there is no sufficient memory to process.
    META_CNF_NO_MEMORY = 3,

    // META_DLL retrieved a callback function, however,
    // the user input arguments are invalid.
    META_CNF_CALLBACK_PARAMETER_ERROR = 4,

    // META_DLL received a confirm with peer msg, however,
    // the peer msg is corrupted.
    META_CNF_PEER_MSG_ERROR = 5,

    // META_DLL received a confirm and successfully executed
    // the callback function.
    META_CNF_OK = 6
}
META_CNF_ERR_CODE;

// The magic value to stop usb enumerate process
#define ENUM_USB_STOP   9876
#define ENUM_ANY_STOP   9876

typedef enum
{
    META_SUCCESS                                             // 0
    , META_FAILED                                            // 1
    , META_COMM_FAIL                                         // 2
    , META_NORESPONSE                                        // 3
    , META_EBOOT_FAILED                                      // 4
    , META_BUFFER_LEN                                        // 5
    , META_FILE_BAD                                          // 6
    , META_LID_INVALID                                       // 7
    , META_INTERNAL_DB_ERR                                   // 8
    , META_NO_MEMORY                                         // 9
    , META_INVALID_ARGUMENTS                                 // 10
    , META_TIMEOUT                                           // 11
    , META_BUSY                                              // 12
    , META_INVALID_HANDLE                                    // 13
    , META_FAT_ERROR                                         // 14
    , META_FAT_DISK_FULL                                     // 15
    , META_FAT_ROOT_DIR_FULL                                 // 16
    , META_FAT_INVALID_FILENAME                              // 17
    , META_FAT_INVALID_FILE_HANDLE                           // 18
    , META_FAT_FILE_NOT_FOUND                                // 19
    , META_FAT_DRIVE_NOT_FOUND                               // 20
    , META_FAT_PATH_NOT_FOUND                                // 21
    , META_FAT_ACCESS_DENIED                                 // 22
    , META_FAT_TOO_MANY_FILES                                // 23
    , META_INCORRECT_TARGET_VER                              // 24
    , META_COM_ERROR                                         // 25
    , META_BROM_CMD_ERROR                                    // 26
    , META_INCORRECT_BBCHIP_TYPE                             // 27
    , META_BROM_ERROR                                        // 28
    , META_STOP_BOOTUP_PROCEDURE                             // 29
    , META_CANCEL                                            // 30
    , META_FUNC_NOT_IMPLEMENT_YET                            // 31
    , META_FAT_APP_QUOTA_FULL                                // 32
    , META_IMEI_CD_ERROR                                     // 33
    , META_RFID_MISMATCH                                     // 34
    , META_NVRAM_DB_IS_NOT_LOADED_YET                        // 35
    , META_WAIT_FOR_TARGET_READY_TIMEOUT                     // 36
    , META_ERR_EXCEED_MAX_PEER_BUF_SIZE                      // 37
    , META_BROM_SECURITY_CHECK_FAIL                          // 38
    , META_MAUI_DB_INCONSISTENT                              // 39
    , META_FAT_FILEPATH_TOO_LONG                             // 40
    , META_FAT_RESTRICTED_FILEPATH                           // 41
    , META_FAT_DIR_NOT_EXIST                                 // 42
    , META_FAT_DISK_SPACE_IS_NOT_ENOUGH                      // 43
    , META_TDMB_ERR_BAND_NOT_EXIST                           // 44
    , META_TDMB_ERR_FREQ_NOT_EXIST                           // 45
    , META_TDMB_ERR_ENSM_NOT_EXIST                           // 46
    , META_TDMB_ERR_SERV_NOT_EXIST                           // 47
    , META_TDMB_ERR_SUB_CHAN_NOT_EXIST                       // 48
    , META_TDMB_ERR_DEMOD_STATE                              // 49
    , META_ENUMERATE_USB_FAIL                                // 50
    , META_STOP_ENUM_USB_PROCEDURE                           // 51
    , META_MISC_TARGET_LOAD_NEED_TO_BE_PATCHED               // 52
    , META_MISC_INI_FILE_SETTINGS_WRONG                      // 53
    , META_MISC_FAIL_TO_READ_IMEI                            // 54
    , META_MISC_FAIL_TO_BACKUP_FILE                          // 55
    , META_MISC_FAIL_TO_WRITE_BACKUP_RESULT                  // 56
    , META_MISC_FAIL_TO_GET_NVRAM_FOLDER_PATH                // 57
    , META_MISC_FAIL_TO_GET_NVRAM_MUST_LIST                  // 58
    , META_STOP_CURRENT_PROCEDURE                            // 59
    , META_MISC_CUSTOMIZED_NVRAM_ERROR                       // 60
    , META_MISC_FOLDER_EMPTY_CHECKING_FAIL                   // 61
    , META_MISC_TOO_MANY_BACKUP_RESULT_FILE                  // 62
    , META_MISC_TOO_MANY_RESTORE_RESULT_FILE                 // 63
    , META_MISC_RESTORE_RESULT_FILE_NOT_EXIST                // 64
    , META_MISC_RESTORE_RESULT_FILE_INCOMPLETE               // 65
    , META_FAIL_TO_CELAR_ALL_IN_BACUP_FOLDER                 // 66
    , META_MISC_BACKUP_RESULT_FILE_NOT_EXIST                 // 67
    , META_MISC_BACKUP_RESULT_FILE_INCOMPLETE                // 68
    , META_MISC_IMEI_MISMATCH                                // 69
    , META_MISC_SML_FILE_VERIFY_FAIL                         // 70
    , META_MISC_BACKUP_RESULT_NOT_ENOUGH_FOR_NEW_LOAD        // 71
    , META_MISC_FAIL_TO_RESTORE_FILE                         // 72
    , META_MISC_FAIL_TO_WRITE_RESTORE_RESULT                 // 73
    , META_MISC_USE_WRONG_API_FOR_NEW_LOAD                   // 74
    , META_MISC_QUERY_TARGET_CAPABILITY_FAIL                 // 75
    , META_MISC_INI_SETTINGS_ERR_IN_NVRAM_SEC                // 76
    , META_MISC_INI_SETTINGS_ERR_IN_TARGET_SEC               // 77
    , META_MISC_INI_SETTINGS_ERR_IN_PC_SEC                   // 78
    , META_MISC_NO_FILES_NEED_TO_BE_UPLOAD                   // 79
    , META_FAT_ACTION_NOT_SUPPORT                            // 80
    , META_MISC_EMPTY_UPLOADFILES_AND_IMEI_SEC               // 81
    , META_MISC_INI_SETTINGS_ERR_IN_MORE_SEC                 // 82
    , META_MISC_INI_SETTINGS_ERR_IN_DELETE_SEC               // 83
    , META_MISC_CHECK_TARGET_NVRAM_FILES_FAIL                // 84
    , META_MISC_FAIL_TO_GET_NVRAM_FOLDER_AMOUNT              // 85
    , META_AUDIO_CHECK_WAVE_FILE_FAIL                        // 86
    , META_MISC_COLLECT_NVRAM_FOLDER_FILES_FAILED            // 87
    , META_MISC_COLLECT_NVRAM_FOLDER_FILES_FIRST             // 88
    , META_MISC_BACKUP_FILE_NOT_FOUND_IN_NVRAM               // 89
    , META_MISC_BACKUP_MORE_FILE_NOT_FOUND_IN_NVRAM          // 90
    , META_MISC_LOCAL_FS_UNKNOWN_ERROR                       // 91
    , META_MISC_RETORE_FILE_NOT_FOUND_IN_BACKUP_RESULT       // 92
    , META_MISC_LEGACY_ADC_FILE_NOT_FOUND                    // 93
    , META_MISC_LEGACY_BARCODE_FILE_NOT_FOUND                // 94
    , META_MISC_FILE_SIZE_MISMATCH                           // 95
    , META_MISC_RESTORE_TARGET_NOT_FOUND_IN_NVRAM            // 96
    , META_UTIL_CONVERT_MULTIBYTE_TO_WCHAR_FAILED            // 97
    , META_FAT_RECURSIVE_CREATE_FOLDER_FAILED                // 98
    , META_FAT_COPY_INVALID_SOURCE_FOLDER                    // 99
    , META_FAT_COPY_EMPTY_SOURCE_FOLDER                      // 100
    , META_MISC_MULTIPLE_ENTRY_NOT_SUPPORTED                 // 101
    , META_MISC_INVALID_FORMAT                               // 102
    , META_FAT_FILE_LENGTH_ZERO                              // 103
    , META_MISC_INI_SETTINGS_ERR_IN_PC_FOLDER_SEC            // 104
    , META_PC_FILE_NOT_FOUND                                 // 105
    , META_MEMBER_FIELD_TYPE_NOT_FOUND                       // 106
    , META_MEMBER_FIELD_OFFSET_NOT_FOUND                     // 107
    , META_NVRAM_GET_KEY_LENGTH_CALLBACK_ERROR               // 108
    , META_NVRAM_ALLOCATE_KEY_BUFFER_ERROR                   // 109
    , META_NVRAM_GET_KEY_BUFFER_CALLBACK_ERROR               // 110
    , META_NVRAM_KEY_ENTRY_MISSING                           // 111
    , META_NVRAM_KEY_ENTRY_ERROR                             // 112
    , META_NVRAM_KEY_LENGTH_EXCEEDS_INTERNAL_BUFFER          // 113
    , META_FAT_SPACE_SIZE_OVERFLOW                           // 114
    , META_LIB_INCONSISTENT                                  // 115
    , META_INTERNAL_DB_ERROR                                 // 116
    , META_REQUIRED_TOOL_VERSION_CHECK_FAILD                 /**< 117, the current tool version does not fullfil the required tool version */
    , META_CROSS_BRANCH_BACKUP_OPEN_FAILED                   // 118
    , META_CROSS_BRANCH_BACKUP_PARSE_FAILED                  // 119
    , META_CROSS_BRANCH_BACKUP_FILE_ATT_NOT_MATCH            // 120
    , META_NVRAM_VALUE_NOT_LEGAL                             // 121
    , META_INIT_CONNECTION_STARTED                           // 122
    , META_QUERY_NO_MODEM_SUPPORT                            // 123
    , META_MEMBER_FIELD_SIZE_NOT_FOUND                       /**< 124, the member field size look-up failed */
    , META_LAST_RESULT

} META_RESULT;

typedef enum
{
    META_BAUD2400 = 0,
    META_BAUD4800,
    META_BAUD9600,
    META_BAUD14400,
    META_BAUD19200,
    META_BAUD57600,   // 5
    META_BAUD115200,
    META_BAUD230400,
    META_BAUD460800,
    META_BAUD921600,
    META_BAUD1500000,            //10
    META_BAUD_END = 0xFF
} META_COMM_BAUDRATE;

typedef enum
{
    META_NO_FLOWCTRL = 0,   // no flow control
    META_SW_FLOWCTRL,       // enable S/W flow control
    META_FLOWCTRL_END
} META_FLOWCTRL;

typedef struct
{
    char    BB_CHIP[64];    // BaseBand chip version
    char    ECO_VER[4];     // ECO version
    char    DSP_FW[64];     // DSP firmware version
    char    DSP_PATCH[64];  // DSP patch version
    char    SW_VER[64];     // S/W version
    char    HW_VER[64];     // H/W board version
    char    MELODY_VER[64]; // Melody version
} VerInfo_Cnf;

typedef struct
{
    unsigned short      com_port_list[255];
    unsigned short      com_port_num;
    unsigned int        ms_connect_timeout; // [META] META enumerate port timeout value
} META_Enumerate_USB_Req;

typedef struct
{
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[12];       // [META] META stage baudrate polling array, it must end with META_BAUD_END.
    META_FLOWCTRL       flowctrl;           // [META] META stage uart flow control type.
    BOOT_META_ARG       boot_meta_arg;      // [BootROM] please refer to brom.h
    unsigned int        ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass)
} META_Connect_Req;

typedef enum
{
    GENERAL_MODE
    , CATCHER_RELAY_MODE
    , FILE_DUMP_MODE
    , TRACE_MODE_NUM
} META_TRACE_MODE;

typedef  struct
{
    META_TRACE_MODE mode;
    int             modem_index;
    char*           dump_file_path;
} META_MODE_TRACE_PARA_T;

typedef struct
{
    int                    com_port;
    META_COMM_BAUDRATE     baudrate[12];       // [META] META stage baudrate polling array, it must end with META_BAUD_END.
    META_FLOWCTRL          flowctrl;           // [META] META stage uart flow control type.
    BOOT_META_ARG          boot_meta_arg;      // [BootROM] please refer to brom.h
    unsigned int           ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass)
    unsigned int           usb_enable: 1;      // [META] Connect target with UART or USB, 0: UART 1: USB others:reserved
    unsigned int           InMetaMode: 1;      // [META] Decide that need boot META or not 0:need boot META 1:already in meta mode
    unsigned int           escape: 1;          // [META] Force to connect target with escaping
    unsigned int           close_com_port: 1;  // [META] Choose to close com port or handle
    META_MODE_TRACE_PARA_T trace_para;         // [META] META mode trace parameters
    unsigned int           protocol: 4;        // [META] Only for MultiMode connection API. When InMetaMode==true, connect target with different protocol 0||1:TST 2:DHL
    unsigned int           channel_type: 4;    // [META] Only for MultiMode connection API. Connect target with different channel type, 0||1: native channel, 2: tunneling, 3: tunneling with check sum ignored
} META_Connect_Ex_Req;

typedef struct
{
    unsigned int m_u4TargetMainVersion;
    unsigned int m_u4TargetMinorVersion;
    unsigned int m_u4TargetBuildNum;
} META_VER_REQUIRED_BY_TARGET;

typedef struct
{
    META_COMM_BAUDRATE  final_baudrate;                 // [META] Detected META stage baudrate.
    unsigned int        meta_ver_required_by_target;    // [META] Target required META_DLL version.  ==> always return 0
    BOOT_RESULT         boot_result;                    // [BootROM] boot-up result.
    STATUS_E            boot_meta_ret;                  // [BROM_DLL] The return code of Boot_META function.
    META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         // [META] Target required META_DLL version.
} META_Connect_Report;

typedef struct
{
    int                 com_port;
    BOOT_META_ARG       boot_meta_arg;      // [BootROM] please refer to brom.h
    unsigned int        ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass)
} META_ConnectByUSB_Req;

typedef struct
{
    unsigned int        meta_ver_required_by_target;    // [META] Target required META_DLL version.  ==> always return 0
    BOOT_RESULT         boot_result;                    // [BootROM] boot-up result.
    STATUS_E            boot_meta_ret;                  // [BROM_DLL] The return code of Boot_META function.
    META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         // [META] Target required META_DLL version.
} META_ConnectByUSB_Report;

typedef struct
{
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[11];       // [META] META stage baudrate polling array, it must end with META_BAUD_END.
    META_FLOWCTRL       flowctrl;           // [META] META stage uart flow control type.
    unsigned int        ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass)
} META_ConnectInMETA_Req;

typedef struct
{
    int                 com_port;
    META_COMM_BAUDRATE  baudrate[11];       // [META] META stage baudrate polling array, it must end with META_BAUD_END.
    META_FLOWCTRL       flowctrl;           // [META] META stage uart flow control type.
    unsigned int        ms_connect_timeout; // [META] META stage sync timeout value (after BootROM negotiation pass)
    bool                escape;             // [META] Force to connect target with escaping
} META_ConnectInMETA_Ex_Req;

typedef struct
{
    META_COMM_BAUDRATE            final_baudrate;                   // [META] Detected META stage baudrate.
    unsigned int                  meta_ver_required_by_target;  // [META] Target required META_DLL version.  ==> always return 0
    META_VER_REQUIRED_BY_TARGET   m_rTargetVer;         // [META] Target required META_DLL version.
} META_ConnectInMETA_Report;

//-----------------------------------------------------//
//  META General: callback function definition         //
//-----------------------------------------------------//
typedef void (__stdcall* META_Error_CallBack)(const META_CNF_ERR_CODE  mr);
typedef void (__stdcall* META_SysTrace_CallBack)(const char* sys_trace);
typedef void (__stdcall* META_GET_VERSION_INFO_CNF)(const VerInfo_Cnf*  cnf, const short token, void* usrData);

//-----------------------------------------------------//
//  META for CTI                                       //
//-----------------------------------------------------//
typedef enum
{
    CTI_OK = 0
             , CTI_MISSING_HEADER
    , CTI_CORRUPTED_FAME
    , CTI_EXCEED_LEN
} CTI_RET_ENUM;

typedef void (__stdcall* META_CTI_CallBack)(CTI_RET_ENUM  ret, const int size, const unsigned char* data, void* param);
META_RESULT  __stdcall META_CTI_SendPacketCmd(const unsigned char* pPayLoadBuffer, int nPayloadLength);
META_RESULT  __stdcall META_CTI_SendPacketCmd_r(const int meta_handle, const unsigned char* pPayLoadBuffer, int nPayloadLength);
META_RESULT  __stdcall META_CTI_SetPacketCallback(META_CTI_CallBack  pCBFunc, void* param);
META_RESULT  __stdcall META_CTI_SetPacketCallback_r(const int meta_handle, META_CTI_CallBack  pCBFunc, void* param);

//-----------------------------------------------------//
//  Switch TST message format                          //
//-----------------------------------------------------//
typedef enum
{
    META_TST_MSG_2G = 0,
    META_TST_MSG_3G
} META_TST_MSG_FORMAT;

META_RESULT  __stdcall META_SetTstMsgFormat(META_TST_MSG_FORMAT  msg_fmt);
META_RESULT  __stdcall META_SetTstMsgFormat_r(const int meta_handle, META_TST_MSG_FORMAT  msg_fmt);

//-----------------------------------------------------//
//  META Debug: exported debug function definition     //
//-----------------------------------------------------//
META_RESULT  __stdcall META_DebugOn();
META_RESULT  __stdcall META_DebugOn_With_FilePath(const char* filepath);
META_RESULT  __stdcall META_DebugOn_ex(const int meta_handle);
META_RESULT  __stdcall META_DebugOn_ex2(const int meta_handle, char* path);
META_RESULT  __stdcall META_DebugOff();
META_RESULT  __stdcall META_DebugClear();

//-----------------------------------------------------//
//  META UnitTest                                      //
//-----------------------------------------------------//

typedef struct
{
    unsigned int    m_TestCaseID;
    const char*     m_pDescription;
} META_UT_TestCaseID_T;

void __stdcall META_QueryTestCase(META_UT_TestCaseID_T**  ppTestCase, unsigned int*  pTestCaseCount);
void __stdcall META_UnitTest(const unsigned int*  p_TestCaseID_Array, unsigned int  TestCaseCount);

//-----------------------------------------------------//
//  META General: exported function definition         //
//-----------------------------------------------------//

#define     FT_MT_UNKNOWN  0
#define     FT_MT6305  1
#define     FT_MT6318  2
#define     FT_MT6326  3

typedef struct
{
    unsigned char   id;
} PMIC_ID;
typedef struct
{
    unsigned int    pcl;
} RF_GetITC_PCL;
// General
void  __stdcall META_GetDLLVer(unsigned int* major_ver, unsigned int* minor_ver, unsigned int* build_num, unsigned int* patch_num);
void  __stdcall META_GetDLLInfo(const char** pp_version, const char** pp_release_type, const char** pp_build_date, const char** pp_load_path);
void  __stdcall META_Cancel(const short token);
void  __stdcall META_Cancel_r(const int meta_handle, const short token);
void  __stdcall META_CancelAllBlockingCall(void);
void  __stdcall META_CancelAllBlockingCall_r(const int meta_handle);
META_RESULT  __stdcall META_QueryIfFunctionSupportedByTarget(unsigned int ms_timeout, const char* query_func_name);
META_RESULT  __stdcall META_QueryIfFunctionSupportedByTarget_r(const int meta_handle, unsigned int ms_timeout, const char* query_func_name);
META_RESULT  __stdcall META_QueryIfTargetSupportISP(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportISP_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAcoustic16level(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAcoustic16level_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAudioParam45Tap(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportAudioParam45Tap_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetIsLowCostSingleBankFlash(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetIsLowCostSingleBankFlash_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryPMICID(unsigned int  ms_timeout, PMIC_ID*  cnf);
META_RESULT  __stdcall META_QueryPMICID_r(const int meta_handle, unsigned int  ms_timeout, PMIC_ID*  cnf);
META_RESULT  __stdcall META_BTPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_BTPowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportWifiALC(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportWifiALC_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryITC_PCL(unsigned int  ms_timeout, RF_GetITC_PCL*  cnf);
META_RESULT  __stdcall META_QueryITC_PCL_r(const int meta_handle, unsigned int  ms_timeout, RF_GetITC_PCL*  cnf);
META_RESULT  __stdcall META_QueryIfTargetSupportDRC(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfTargetSupportDRC_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfBTPowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_QueryIfBTPowerOn_r(const int meta_handle, unsigned int ms_timeout);

//-----------------------------------------------------//
//  UTILITY--ENABLE WATCHDOG                           //
//-----------------------------------------------------//
#define GPIO_DEV_LED_MAINLCD 0
//#define GPIO_DEV_LED_SUBLCD 1

typedef struct
{
    unsigned int    ms_timeout_interval;
} FtWatchDog;

typedef struct
{
    unsigned char       led_light_level;
} FtLEDLevel;

typedef struct
{
    unsigned char       lcd_type;
    unsigned char       lcd_light_level;
} FtLCDLevel;

typedef struct
{
    unsigned char       onoff;
} FtVibratorOnOff;

typedef struct
{
    unsigned char       m_rtc_sec;    /* seconds after the minute   - [0,59]  */
    unsigned char       m_rtc_min;    /* minutes after the hour     - [0,59]  */
    unsigned char       m_rtc_hour;   /* hours after the midnight   - [0,23]  */
    unsigned char       m_rtc_day;    /* day of the month           - [1,31]  */
    unsigned char       m_rtc_mon;    /* months                        - [1,12] */
    unsigned char       m_rtc_wday;   /* days in a week               - [1,7] */
    unsigned char       m_rtc_year;
} T_Rtc;

META_RESULT  __stdcall META_EnableWatchDogTimer(unsigned int ms_timeout, FtWatchDog* req);
META_RESULT  __stdcall META_EnableWatchDogTimer_r(const int meta_handle, unsigned int ms_timeout, FtWatchDog* req);

META_RESULT  __stdcall META_SetLEDLightLevel(unsigned int ms_timeout, FtLEDLevel* req);
META_RESULT  __stdcall META_SetLEDLightLevel_r(const int meta_handle, unsigned int ms_timeout, FtLEDLevel* req);

META_RESULT  __stdcall META_SetVibratorOnOff(unsigned int ms_timeout, FtVibratorOnOff* req);
META_RESULT  __stdcall META_SetVibratorOnOff_r(const int meta_handle, unsigned int ms_timeout, FtVibratorOnOff* req);

META_RESULT  __stdcall META_QueryLocalTime(unsigned int  ms_timeout, T_Rtc*  cnf);
META_RESULT  __stdcall META_QueryLocalTime_r(const int meta_handle, unsigned int  ms_timeout, T_Rtc*  cnf);

META_RESULT  __stdcall META_SetMainSubLCDLightLevel(unsigned int ms_timeout, FtLCDLevel* req);
META_RESULT  __stdcall META_SetMainSubLCDLightLevel_r(const int meta_handle, unsigned int ms_timeout, FtLCDLevel* req);


// timer-related APIs
META_RESULT  __stdcall META_StartTimer();
META_RESULT  __stdcall META_StartTimer_r(const int meta_handle);
META_RESULT  __stdcall META_StopTimer();
META_RESULT  __stdcall META_StopTimer_r(const int meta_handle);
META_RESULT __stdcall META_GetProcessTime(unsigned int*  pProcessTime, unsigned short* pNumAPIs);
META_RESULT __stdcall META_GetProcessTime_r(const int meta_handle, unsigned int* pProcessTime, unsigned short* pNumAPIs);



const char* __stdcall META_GetErrorString(META_RESULT  ErrCode);
const char* __stdcall META_BaudrateEnumToName(META_COMM_BAUDRATE  baudrate);

// Initialization
META_RESULT  __stdcall META_GetAvailableHandle(int* p_meta_handle);
META_RESULT  __stdcall META_Init(const META_Error_CallBack  cb);
META_RESULT  __stdcall META_Init_r(const int meta_handle, const META_Error_CallBack  cb);
/* [Dual Talk] */
/** for MT6582 world phone */
typedef struct
{
    unsigned int number_of_md: 8;
    unsigned int active_md_idx: 8;
    unsigned int multi_talk: 1; // 0: no multi-talk, 1: multi-talk
    unsigned int multi_frame_type: 1; // 0: all MD use the same frame type, 1: each MD is assigned a frame type
    unsigned int number_of_mdSwImg: 4; //for MT6582 world phone (multi-MDtype)
    unsigned int active_mdtype_idx: 4;
    unsigned int multi_mdtype: 1; // 0: no multi-MDtype, 1: multi-MDtype
    unsigned int multi_md_capability_support: 1;
    unsigned int reserved: 4;
} META_MD_Query_Result_T;
typedef enum
{
    md_type_invalid = 0,
    modem_2g = 1,
    modem_3g,
    modem_wg,
    modem_tg,
    modem_lwg,
    modem_ltg,
    modem_ltng,
    num_modem_type  //number of md type need to -1, bescause "md_type_invalid = 0"
} modem_type_t;
const char* __stdcall META_GetModemTypeString(modem_type_t mdType);
//for switch mdtype callback arguments
typedef struct
{
    unsigned int md_idx: 8;
    unsigned int mdtype_idx: 8;
    unsigned int reserved: 16;
} META_MDTYPE_Switch_Param_T;
/**
 * \brief the callback function for querying the multi-talk capability on the target system
 * \return the query result
 */
typedef META_MD_Query_Result_T (__stdcall* META_MD_Query_CallBack)(void* arg);
/**
 * \brief the callback function for MODEM switching
 * \return 0: success, otherwise, fail
 */
typedef int (__stdcall* META_MD_Switch_CallBack)(void* arg);
/**
 * for MT6582 world phone
 * \brief the callback function for MODEM TYPEswitching
 * \return 0: success, otherwise, fail
 */
typedef int (__stdcall* META_MDTYPE_Switch_CallBack)(META_MDTYPE_Switch_Param_T mdtype_switch_param, void* arg);
/**
 * \brief non-reentrant version of META_Init_Ex_r
 */
META_RESULT  __stdcall META_Init_Ex(const META_Error_CallBack err_cb,
                                    const META_MD_Query_CallBack md_query_cb,
                                    void* md_query_arg,
                                    const META_MD_Switch_CallBack md_switch_cb,
                                    void* md_switch_arg
                                   );
/**
 * \brief META_Init extended version for multiple-talk project
 * \param meta_handle the operating session ID (meta_handle)
 * \param err_cb the error handler for META DLL
 * \param md_query_cb the switching implementation of upper layer (OPTIONAL)
 *        in different product segment, the multiple-talk product could be all-in-one chip or
 *        external MODEM solution
 *        external MODEM solution needs extra switching procedure
 *        all-in-one solution needs no extra switching procedure
 * \param md_query_arg the argument to be passed to md_query_cb (OPTIONAL)
 * \param md_switch_cb the switching implementation of upper layer (OPTIONAL)
 * \param md_switch_arg the argument to be passed to md_switch_arg (OPTIONAL)
 * \return On success: META_SUCCESS
 *         On fail: META_FAILED or META_INVALID_ARGUMENTS
 */
META_RESULT  __stdcall META_Init_Ex_r(const int meta_handle,
                                      const META_Error_CallBack err_cb,
                                      const META_MD_Query_CallBack md_query_cb,
                                      void* md_query_arg,
                                      const META_MD_Switch_CallBack md_switch_cb,
                                      void* md_switch_arg
                                     );
/**
 * \brief non-reentrant version of META_Init_Ex_2_r
 */
META_RESULT  __stdcall META_Init_Ex_2(const META_Error_CallBack err_cb,
                                      const META_MD_Query_CallBack md_query_cb,
                                      void* md_query_arg,
                                      const META_MD_Switch_CallBack md_switch_cb,
                                      void* md_switch_arg,
                                      const META_MDTYPE_Switch_CallBack mdtype_switch_cb,
                                      void* mdtype_switch_arg
                                     );
/**
 * \brief META_Init extended version for multiple-modemtype project [world phone]
 * \param meta_handle the operating session ID (meta_handle)
 * \param err_cb the error handler for META DLL
 * \param md_query_cb the switching implementation of upper layer (OPTIONAL)
 *        in different product segment, the multiple-talk product could be all-in-one chip or
 *        Multiple MODEM Typesolution
 *        Multiple MODEM solution needs extra switching procedure
 *        all-in-one solution needs no extra switching procedure
 * \param md_query_arg the argument to be passed to md_query_cb (OPTIONAL)
 * \param md_switch_cb the switching implementation of upper layer (OPTIONAL)
 * \param md_switch_arg the argument to be passed to md_switch_arg (OPTIONAL)
  * \param mdtype_switch_cb the mdtype switching implementation of upper layer (OPTIONAL)
 * \param mdtype_switch_arg the argument to be passed to mdtype_switch_arg (OPTIONAL)
 * \return On success: META_SUCCESS
 *         On fail: META_FAILED or META_INVALID_ARGUMENTS
 */
META_RESULT  __stdcall META_Init_Ex_2_r(const int meta_handle,
                                        const META_Error_CallBack err_cb,
                                        const META_MD_Query_CallBack md_query_cb,
                                        void* md_query_arg,
                                        const META_MD_Switch_CallBack md_switch_cb,
                                        void* md_switch_arg,
                                        const META_MDTYPE_Switch_CallBack mdtype_switch_cb,
                                        void* mdtype_switch_arg
                                       );
/**
 * \brief non-reentrant version of META_SwitchCurrentModem_r
 *        this API switch the operating MODEM of meta_handle 0
 */
META_RESULT  __stdcall META_SwitchCurrentModem(const unsigned int ms_timeout, const unsigned int md_index);
/**
 * \brief switch the current operating MODEM to specified md_index
 * \param meta_handle the operating session ID (meta_handle)
 * \param md_index the specified md_index to be switched to
 * \return On success: META_SUCCESS
 *         On Fail: META_MAUI_DB_INCONSISTENT if the DB does not match with the switched MODEM
 *                  META_FAILED failed to switch to specifed md_index
 *                  META_FUNC_NOT_IMPLEMENT_YET for single-talk project
 *                  META_INVALID_ARGUMENTS for not supported md_index
 *                  for example, md_index 0 and 1 are valid on dual-talk projects
 */
META_RESULT  __stdcall META_SwitchCurrentModem_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int md_index);
/**
 * \brief non-reentrant version of META_QueryCurrentModem_r
 *        this API query the operating MODEM of meta_handle 0
 */
META_RESULT  __stdcall META_QueryCurrentModem(unsigned int* md_index);
/**
 * \brief Query the current operating MODEM of the specified meta_handle
 * \param meta_handle the operating session ID (meta_handle)
 * \param[OUT] md_index the query result
 * \return On success: META_SUCCESS
 */
META_RESULT  __stdcall META_QueryCurrentModem_r(const int meta_handle, unsigned int* md_index);
/**
 * \brief non-reentrant version of META_SwitchCurrentModem_r
 *        this API switch the operating MODEM of meta_handle 0
 */
META_RESULT  __stdcall META_SwitchCurrentModemEx(const unsigned int ms_timeout, const unsigned int md_index, const unsigned int protocol, const unsigned int channel_type, const META_MODE_TRACE_PARA_T* trace_para);
/**
 * \brief switch the current operating MODEM to specified md_index and protocol and channel type
 * \param meta_handle the operating session ID (meta_handle)
 * \param md_index the specified md_index to be switched to
 * \return On success: META_SUCCESS
 *         On Fail: META_MAUI_DB_INCONSISTENT if the DB does not match with the switched MODEM
 *                  META_FAILED failed to switch to specifed md_index
 *                  META_FUNC_NOT_IMPLEMENT_YET for single-talk project
 *                  META_INVALID_ARGUMENTS for not supported md_index
 *                  for example, md_index 0 and 1 are valid on dual-talk projects
 */
META_RESULT  __stdcall META_SwitchCurrentModemEx_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int md_index, const unsigned int protocol, const unsigned int channel_type, const META_MODE_TRACE_PARA_T* trace_para);
/**
 * \brief non-reentrant version of META_QueryCurrentModem_r
 *        this API query the operating MODEM of meta_handle 0
 */
META_RESULT  __stdcall META_QueryCurrentModemEx(unsigned int* md_index, unsigned int* protocol, unsigned int* channel_type);
/**
 * \brief Query the current operating MODEM of the specified meta_handle
 * \param meta_handle the operating session ID (meta_handle)
 * \param[OUT] md_index the query result
 * \return On success: META_SUCCESS
 */
META_RESULT  __stdcall META_QueryCurrentModemEx_r(const int meta_handle, unsigned int* md_index, unsigned int* protocol, unsigned int* channel_type);
META_RESULT  __stdcall META_SetSysTraceCallback(const META_SysTrace_CallBack  sys_cb);
META_RESULT  __stdcall META_SetSysTraceCallback_r(const int meta_handle, const META_SysTrace_CallBack  sys_cb);
void  __stdcall META_Deinit(void);
void  __stdcall META_Deinit_r(int* p_meta_handle);
/**
 * for MT6582 world phone
 * \brief Set the current operating MODEM type of the specified meta_handle
 * \param meta_handle the operating session ID (meta_handle)
 * \return On success: META_SUCCESS
 */
META_RESULT  __stdcall META_SetInfo4SwitchModemType(const unsigned int ms_timeout, const unsigned int md_index, const unsigned int mdtype_index);
META_RESULT  __stdcall META_SetInfo4SwitchModemType_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int md_index, const unsigned int mdtype_index);
// connect with target
META_RESULT  __stdcall META_ConnectWithTarget(const META_Connect_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
META_RESULT  __stdcall META_ConnectWithTarget_r(const int meta_handle, const META_Connect_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
META_RESULT  __stdcall META_ConnectWithTargetEx(const META_Connect_Ex_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
META_RESULT  __stdcall META_ConnectWithTargetEx_r(const int meta_handle, const META_Connect_Ex_Req*  req, int* p_bootstop, META_Connect_Report*  p_report);
META_RESULT  __stdcall META_ConnectWithMultiModeTarget(const META_Connect_Ex_Req*  req, const unsigned int requestLengthlength, int* p_bootstop, META_Connect_Report*  p_report);
META_RESULT  __stdcall META_ConnectWithMultiModeTarget_r(const int meta_handle, const META_Connect_Ex_Req*  req, const unsigned int requestLengthlength, int* p_bootstop, META_Connect_Report*  p_report);
// dsiconnect and shutdown target
META_RESULT  __stdcall META_DisconnectWithTarget(void);
META_RESULT  __stdcall META_DisconnectWithTarget_r(const int meta_handle);

// connect with target when target already in meta mode
META_RESULT  __stdcall META_ConnectInMetaMode(const META_ConnectInMETA_Req*  req, int* p_bootstop, META_ConnectInMETA_Report*  p_report);
META_RESULT  __stdcall META_ConnectInMetaMode_r(const int meta_handle, const META_ConnectInMETA_Req* req, int* p_bootstop, META_ConnectInMETA_Report* p_report);
// connect with target when target already in meta mode for SP connection via UART with escaping
META_RESULT  __stdcall META_ConnectInMetaMode_Ex(const META_ConnectInMETA_Ex_Req* req, int* p_bootstop, META_ConnectInMETA_Report* p_report);
META_RESULT  __stdcall META_ConnectInMetaMode_Ex_r(const int meta_handle, const META_ConnectInMETA_Ex_Req* req, int* p_bootstop, META_ConnectInMETA_Report* p_report);
// dsiconnect without shutdown target
META_RESULT  __stdcall META_DisconnectInMetaMode(void);
META_RESULT  __stdcall META_DisconnectInMetaMode_r(const int meta_handle);

// USB-related connect
META_RESULT  __stdcall META_ConnectInMetaModeByUSB(const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);
META_RESULT  __stdcall META_ConnectInMetaModeByUSB_r(const int meta_handle, const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);

META_RESULT  __stdcall META_ConnectWithTargetByUSB(const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);
META_RESULT  __stdcall META_ConnectWithTargetByUSB_r(const int meta_handle, const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report);

META_RESULT  __stdcall META_ConnectWithTargetByUSBEx(const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report, bool close_com_port);
META_RESULT  __stdcall META_ConnectWithTargetByUSBEx_r(const int meta_handle, const META_ConnectByUSB_Req*  req, int* p_bootstop, META_ConnectByUSB_Report*  p_report, bool close_com_port);
META_RESULT  __stdcall META_QueryConnectionMedia(unsigned int* indicator, int* comport);
META_RESULT  __stdcall META_QueryConnectionMedia_r(const int meta_handle, unsigned int* indicator, int* comport);

META_RESULT  __stdcall META_GetDynamicUSBComPort(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop);
META_RESULT  __stdcall META_GetDynamicUSBComPort_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop);
META_RESULT  __stdcall META_GetDynamicUSBComPortWithPrefix(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, const char* prefix);
META_RESULT  __stdcall META_GetDynamicUSBComPortWithPrefix_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, const char* prefix);
META_RESULT  __stdcall META_GetDynamicUSBComPortEx(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length);
META_RESULT  __stdcall META_GetDynamicUSBComPortEx_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length);
META_RESULT  __stdcall META_GetDynamicUSBComPortExWithFilter(unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length, char* valid_usb_info);
META_RESULT  __stdcall META_GetDynamicUSBComPortExWithFilter_r(const int meta_handle, unsigned int ms_scan_timeout, unsigned short* com_port, int* p_scanstop, char* info, int length, char* valid_usb_info);

// Get target S/W, H/W and Melody version
META_RESULT  __stdcall META_GetTargetVerInfo(const META_GET_VERSION_INFO_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_GetTargetVerInfo_r(const int meta_handle, const META_GET_VERSION_INFO_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_GetTargetVerInfoEx(VerInfo_Cnf* cnf);
META_RESULT  __stdcall META_GetTargetVerInfoEx_r(const int meta_handle, VerInfo_Cnf* cnf);
// Shutdown target
META_RESULT  __stdcall META_ShutDownTarget(void);
META_RESULT  __stdcall META_ShutDownTarget_r(const int meta_handle);
// Get target send bytes
META_RESULT  __stdcall META_GetReadBytes(unsigned long* read_bytes);
META_RESULT  __stdcall META_GetReadBytes_r(const int meta_handle, unsigned long* read_bytes);

// ***** Expired Functions -- BEGIN ***** //
// these functions are expired, we encourage you to use META_ConnectWithTarget and META_DisconnectWithTarget
META_RESULT  __stdcall META_COMM_Set_Baudrate(const META_COMM_BAUDRATE  baudrate);
META_RESULT  __stdcall META_COMM_Set_Baudrate_r(const int meta_handle, const META_COMM_BAUDRATE  baudrate);
META_RESULT  __stdcall META_COMM_Start(const int comm_port, const META_FLOWCTRL  flowctrl);
META_RESULT  __stdcall META_COMM_Start_r(const int meta_handle, const int comm_port, const META_FLOWCTRL  flowctrl);
META_RESULT  __stdcall META_COMM_Stop(void);
META_RESULT  __stdcall META_COMM_Stop_r(const int meta_handle);
META_RESULT  __stdcall META_WaitForTargetReady(unsigned int ms_waiting_time, unsigned int request_count);
META_RESULT  __stdcall META_WaitForTargetReady_r(const int meta_handle, unsigned int ms_waiting_time, unsigned int request_count);
META_RESULT  __stdcall META_GetTargetRequiredMetaVer(unsigned int* p_meta_ver_required_by_target);
META_RESULT  __stdcall META_GetTargetRequiredMetaVer_r(const int meta_handle, unsigned int* p_meta_ver_required_by_target);
// ***** Expired Functions -- END ***** //
const char* __stdcall META_GetBBChipNameByType(unsigned int type);
unsigned int __stdcall META_GetBBChipTypeByString(const char* bb_str);

#ifdef __META_DLL_WCDMA__

/**V \brief
 * Using cost down PA, after MT6280, is needed to add compensation for dealing with transient state unstable situation
 * when switching mode, e.g., Low mode to High mode.
 */
typedef struct
{
    short pa_drift_comp_w_table[6][2];
    short pa_drift_comp_h_table[6][4];
} U_sPADRIFTSETTING;
typedef struct
{
    U_sPADRIFTSETTING txPaDriftCompData;
} ul1Cal_txPaDriftCompData_T;

/**V \brief
 * 20130425
 * PRACH TX Temperature Compensation
 */
typedef struct
{
    short   vga_comp_by_temperature[8][2];  //[0]:slope in dB (unit: 1/32 dB), [1]:offset in txdac
} U_sRACHCOMP;
typedef struct
{
    U_sRACHCOMP power_dac[3];//0:PA high mode, 1:PA mid mode, 2:PA low mode (use 0&1 if only 2 mode)
} U_sPARACHTMCOMPDATA;
typedef struct
{
    U_sPARACHTMCOMPDATA txPrachTmCompData;
} ul1cal_txPrachTmCompData_T;

typedef struct
{
    unsigned short ul_uarfcn;       /* UL uarfcn range:????Read from NVRAM?? (9612 ~ 9888) */
    unsigned short dl_uarfcn;
    unsigned short dl_psc;      /* 0~511. */
    unsigned short signature;   /* 0~15, for single signature decision. */
    unsigned char  pa_mode; /* 0: high 1: middle 2: low */
    char           init_power;  /* Assume cpich_rscp=0, ul_interference=0. */
    unsigned char  power_step;     /* Preamble power ramping step. 1 ~ 8dB */
    unsigned char  max_retrans; /* 1~64 */
    unsigned char  asc;            /* 0~7 */
} URfTestCmdTxAccess;
typedef struct
{
    unsigned short  ul_freq;
    short   psc;        /* 0~511. */
    unsigned int    sc_code;    /* Scrambling code #. 0 ~ 16777215 */
    unsigned char   power_ctrl_mode;
    unsigned char   pa_mode;
    unsigned short  idx;
    unsigned short  afc_dac;
    unsigned char   dpcch_pwr;
    unsigned char   dpdch_pwr;
    unsigned char   rf_band;
    unsigned char   vm1;
    unsigned char   vm2;
    unsigned short  dc2dc_dac;
    unsigned short  vbias_dac;
    bool            pwr_det;
    unsigned short  apc_dac;
} URfTestCmdTxDPCh; //Anthony  target side is :UL1TSTCmdTxDPCh and  URfTestCmdTxDPCh
typedef struct
{
    unsigned short  dl_freq;
    short   psc;    /* 0~511. */
    unsigned char   ssc;    /* 0~15. */
    short   ovsf;   /* 0~sf-1. */
    unsigned short  afc_dac;
    bool    hwAGC;
    unsigned char   mode;       /* 0: mode0, 1: mode1. */
    short   gain;       /* mode0. */
    unsigned char   LNAmode;     /* mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /* mode1. */
} URfTestCmdRxDPCh;
#define MAX_FREQ_LIST 36
typedef struct
{
    unsigned char   num_freq;
    unsigned short  dl_freq[ MAX_FREQ_LIST ];
    unsigned char   temperature;
    bool    hwAGC;
    unsigned char   mode;       /* 0: mode0, 1: mode1. */
    short   gain;       /* mode0. */
    unsigned char   LNAmode;    /* mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /* mode1. */
} URfTestCmdRSSI;
typedef struct
{
    bool            pscan_before_cell_search;   /* True if UL1TST needs power scan before cell search/RSCP. */
    unsigned short  dl_freq;    /* Specific dl_freq to do cell search. Valid if pscan_before_cell_search=F. */
    unsigned char   sample_num_per_cell;
    bool            read_sfn;   /* True if we need to do SFN measurement for the found cell. */
    bool            hwAGC;
    unsigned char   mode;       /* 0: mode0, 1: mode1. */
    short           gain;       /* mode0. */
    unsigned char   LNAmode;    /* mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /* mode1. */
} URfTestCmdRSCP;
typedef struct
{
    short           dl_freq;    /* Specific dl_freq to do cell search. Valid if pscan_before_cell_search=F. */
    short           afc_dac;    //anthony 0514
    bool            hwAGC;
    unsigned char   mode;       /* 0: mode0, 1: mode1. */
    short           gain;       /* mode0. */
    unsigned char   LNAmode;    /* mode1. 0: LNA high, 1: LNA mid, 2: LNA low. */
    unsigned short  pga;        /* mode1. */
} URfTestCmdAFC;
typedef struct
{
    char            m_cRfBand;    // only 0 ~ 5
    unsigned short  m_u2Idx;
    unsigned char   m_ucPaMode;
    unsigned char    m_ucVm1;
    unsigned char    m_ucVm2;
    unsigned short   m_u2DC2DC_Dac;
    unsigned short   m_u2Vbias_Dac;
    unsigned short   m_u2ApcDac;
} UL1D_RF_TX_PA_APC_REQ_T;

typedef struct
{
    unsigned char  pseudo_hscch[5];
    unsigned char  pseudo_hdsch[5];
    unsigned short beta_hs_p[15];
    unsigned short beta_hs_q[15];
} UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSDPA;

typedef struct
{
    unsigned char  edch_enable[5];
    unsigned char  is_new_tx[5];
    unsigned char  etfci[5];
    unsigned char  beta_ed_num[5];
    unsigned short  beta_ed0_sf[5];
    unsigned short  beta_ed1_sf[5];
    unsigned short  beta_ed2_sf[5];
    unsigned short  beta_ed3_sf[5];
    unsigned short  beta_ec[5];
    unsigned short  beta_ed_x_beta_c_0[5];
    unsigned short  beta_ed_x_beta_c_1[5];
    unsigned short  beta_ed_x_beta_c_2[5];
    unsigned short  beta_ed_x_beta_c_3[5];
    unsigned char  delta_harq[5];
} UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSUPA;

typedef struct
{
    unsigned int   normcon;
    short          net_maxpow;
    short          net_minpow;
    // __HSDPA_SUPPORT__
    UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSDPA frame_info_r5r6_hsdpa;
    // end of __HSDPA_SUPPORT__
    // __HSUPA_SUPPORT__
    UL1D_RF_HWTPC_FRAME_INFO_R5R6_HSUPA frame_info_r5r6_hsupa;
    // end of __HSUPA_SUPPORT__
} UL1D_RF_HWTPC_FRAME_INFO_R5R6;

typedef struct
{
    unsigned char tpc_step;
    unsigned char itp;
    unsigned char rpp;
    unsigned char fmt_idx;
    unsigned char dl_frame_type;
    unsigned short slot_mask;
    char   tpc_cmd[15];
    unsigned char  beta_c;
    unsigned char  beta_d;
    UL1D_RF_HWTPC_FRAME_INFO_R5R6 r5r6_parameters;
} UL1D_RF_HWTPC_FRAME_INFO;

typedef struct
{
    // __HSDPA_SUPPORT__
    unsigned short  h_dpch_offset;
    unsigned char   h_cqi_cycle;
    unsigned char   h_cqi_rep_factor;
    unsigned char   h_delta_cqi;
    unsigned char   h_delta_ack;
    unsigned char   h_delta_nack;
    unsigned char   h_acknack_repe_factor;
    unsigned char   h_harq_pre_mode;
    // end of __HSDPA_SUPPORT__
} UL1D_RF_HWTPC_INFO_R5R6_HSDPA;

typedef struct
{
    // __HSUPA_SUPPORT__
    unsigned char   e_tti;
    unsigned char   e_ul_dpch_num;
    unsigned char   e_beta_ec_idx;
    unsigned char   e_ref_etfci_num;
    unsigned char   e_etfci_table_idx;
    unsigned char   e_pl_non_max;
    unsigned char   e_ref_etfci[8];
    unsigned char   e_ref_etfci_po[8];
    // end of __HSUPA_SUPPORT__
} UL1D_RF_HWTPC_INFO_R5R6_HSUPA;

typedef struct
{
    short         max_pow;
    short         min_pow;
    unsigned char hsdpa;
    unsigned char hsupa;
    // YH: no compile option, the compile option handling is done in the FT task
    UL1D_RF_HWTPC_INFO_R5R6_HSDPA hwtpc_info_r5r6_hsdpa;
    UL1D_RF_HWTPC_INFO_R5R6_HSUPA hwtpc_info_r5r6_hsupa;

} UL1D_RF_HWTPC_INFO_R5R6_EXTRA;

typedef struct
{
    unsigned char pc_algo;
    unsigned char tpc_used_frame;  // at most 8 so far
    short  p_ini;
    UL1D_RF_HWTPC_INFO_R5R6_EXTRA hw_tpc_r5r6_extra;
    UL1D_RF_HWTPC_FRAME_INFO frame_info[9];
} UL1D_RF_HWTPC_CONFIG_REQ_T;
typedef struct
{
    unsigned char rf_band;
} UL1D_RF_GET_PWR_THR_REQ_T;
typedef struct
{
    unsigned int bsi_data;
} UL1D_RF_SET_BSI_DATA_REQ_T;
typedef struct
{
    unsigned int bsi_addr;
} UL1D_RF_GET_BSI_DATA_REQ_T;
#define FT_MAX_FHC_FREQ_COUNT 40
#define FT_MAX_FHC_PWR_COUNT 40
#define FT_MAX_CAL_BAND     10
typedef struct
{
    bool              no_loop_ctrl;
    unsigned short    afc_dac;
    bool              pwr_det;//0 off/manual mode, 1 on/auto mode
    unsigned char     power_ctrl_mode;//1: HW->O3, 2: SW->59D, Smarti
    unsigned char     vm1[FT_MAX_CAL_BAND][3];      //PA param
    unsigned char     vm2[FT_MAX_CAL_BAND][3];      //PA param
    unsigned short    dc2dc_dac[FT_MAX_CAL_BAND][3];//PA param
    unsigned short    vbias_dac[FT_MAX_CAL_BAND][3];//PA param
    bool              init_tx_onoff;             //0:off, 1:on
    bool              ready_tx_onoff;            //0:off, 1:on
    unsigned char     init_pa_mode;
    unsigned char     ready_pa_mode;
    unsigned short    init_pa_gain;
    unsigned short    ready_pa_gain;
    unsigned short    init_vga_dac_tpc_idx;
    unsigned short    ready_vga_dac_tpc_idx;
    unsigned char    temperature;
    bool             hwAGC;       //0:SW gain mode, 1:HW AGC. AGC must on for RSSI measure. HW limit
    short            gain_init;     /* for HW mode */
    bool              init_condition; //0: max_pwr, 1:min_pwr
    unsigned char     step_duration;  //in slot
    unsigned char     ready_duration; //in slot
    unsigned char     retune_duration; //in slot
    unsigned char     gain_stable_time; //in slot
    unsigned short     max_vga_dac;
    unsigned short     min_vga_dac;
    unsigned short     jump_vga_dac;
    unsigned char       freq_count;
    unsigned char       pwr_count;
    unsigned char       freq_start_idx;
    unsigned char       pwr_start_idx;
    unsigned char       odd_record;  /*for Anritsu8820, only odd step (1,3,5...start from 1) is for measurement.  */
    unsigned char       pa_gain_start_idx; // for O3 TPC
    unsigned char       pd_gain_start_idx; // for O3 TPC
    unsigned char       dl_band[FT_MAX_FHC_FREQ_COUNT]; //1:band1, 2:band2, 3:band3, 5:band5
    unsigned char       ul_band[FT_MAX_FHC_FREQ_COUNT]; //1:band1, 2:band2, 3:band3, 5:band5
    unsigned short      dl_freq[FT_MAX_FHC_FREQ_COUNT]; //in uarfcn
    unsigned short      ul_freq[FT_MAX_FHC_FREQ_COUNT]; //in uarfcn
    unsigned char       pa_mode[FT_MAX_FHC_PWR_COUNT];
    unsigned short      vga_dac_tpc_idx[FT_MAX_FHC_PWR_COUNT];//power_ctrl_mode=HW, tpc_idx. Vice versa.
    unsigned short      pa_gain[FT_MAX_FHC_PWR_COUNT]; // for O3 TPC
    unsigned char       pd_gain[FT_MAX_FHC_FREQ_COUNT]; // [FT_MAX_MQC_FREQ_COUNT]; // for O3 TPC
} UL1D_RF_FHC_REQ_T;
typedef struct
{
    bool              no_loop_ctrl;
    unsigned short    afc_dac;
    bool              pwr_det;//0 off/manual mode, 1 on/auto mode
    unsigned char     power_ctrl_mode;//1: HW->O3, 2: SW->59D, Smarti
    unsigned char     vm1[FT_MAX_CAL_BAND][3];      //PA param
    unsigned char     vm2[FT_MAX_CAL_BAND][3];      //PA param
    unsigned short    dc2dc_dac[FT_MAX_CAL_BAND][3];//PA param
    unsigned short    vbias_dac[FT_MAX_CAL_BAND][3];//PA param
    bool              init_tx_onoff;             //0:off, 1:on
    bool              ready_tx_onoff;            //0:off, 1:on
    unsigned char     init_pa_mode;
    unsigned char     ready_pa_mode;
    unsigned short    init_pa_gain;
    unsigned short    ready_pa_gain;
    unsigned short    init_vga_dac_tpc_idx;
    unsigned short    ready_vga_dac_tpc_idx;
    unsigned char    temperature;
    bool             hwAGC;       //0:SW gain mode, 1:HW AGC. AGC must on for RSSI measure. HW limit
    short            gain_init;     /* for HW mode */
    bool              init_condition; //0: max_pwr, 1:min_pwr
    unsigned char     step_duration;  //in slot
    unsigned char     ready_duration; //in slot
    unsigned char     retune_duration; //in slot
    unsigned char     gain_stable_time; //in slot
    unsigned short     max_vga_dac;
    unsigned short     min_vga_dac;
    unsigned short     jump_vga_dac;
    unsigned char       freq_count;
    unsigned char       pwr_count;
    unsigned char       freq_start_idx;
    unsigned char       pwr_start_idx;
    unsigned char       odd_record;  /*for Anritsu8820, only odd step (1,3,5...start from 1) is for measurement.  */
    unsigned char       pa_gain_start_idx; // for O3 TPC
    unsigned char       pd_gain_start_idx; // for O3 TPC
    unsigned char       dl_band[FT_MAX_FHC_FREQ_COUNT]; //1:band1, 2:band2, 3:band3, 5:band5
    unsigned char       ul_band[FT_MAX_FHC_FREQ_COUNT]; //1:band1, 2:band2, 3:band3, 5:band5
    unsigned short      dl_freq[FT_MAX_FHC_FREQ_COUNT]; //in uarfcn
    unsigned short      ul_freq[FT_MAX_FHC_FREQ_COUNT]; //in uarfcn
    unsigned char       pa_mode[FT_MAX_FHC_PWR_COUNT];
    unsigned short      vga_dac_tpc_idx[FT_MAX_FHC_PWR_COUNT];//power_ctrl_mode=HW, tpc_idx. Vice versa.
    unsigned short      pa_gain[FT_MAX_FHC_PWR_COUNT]; // for O3 TPC
    unsigned char       pd_gain[FT_MAX_FHC_FREQ_COUNT]; // [FT_MAX_MQC_FREQ_COUNT]; // for O3 TPC
    unsigned char       pa_section[FT_MAX_FHC_PWR_COUNT];
    unsigned short      lna_gain[FT_MAX_FHC_FREQ_COUNT];  /**< \brief 80 path loss 3 lna mode fixed gain */
} UL1D_RF_FHC_EX_REQ_T;
#define FT_MAX_FHC_RSSI_COUNT 400
typedef struct
{
    bool             ok;
    unsigned char    freq_count;
    unsigned char    pwr_count;
    unsigned char    freq_start_idx;
    unsigned char    pwr_start_idx;
    short            rssi[FT_MAX_FHC_RSSI_COUNT];
    unsigned short   pwr_det_value[FT_MAX_FHC_FREQ_COUNT];//[FT_MAX_MQC_FREQ_COUNT];
} UL1D_RF_FHC_CNF_T; //URfTestResultMQC;  // will send by peer buffer
typedef struct
{
    bool             ok;
    unsigned char    freq_count;
    unsigned char    pwr_count;
    unsigned char    freq_start_idx;
    unsigned char    pwr_start_idx;
    unsigned char    rx_lna_mode[FT_MAX_FHC_RSSI_COUNT];
    short            rssi[FT_MAX_FHC_RSSI_COUNT];
    unsigned short   pwr_det_value[FT_MAX_FHC_FREQ_COUNT][3];
} UL1D_RF_FHC_EX_CNF_T;

typedef struct
{
    bool             ok;
    unsigned char    freq_count;
    unsigned char    pwr_count;
    unsigned char    freq_start_idx;
    unsigned char    pwr_start_idx;
    unsigned char    rx_lna_mode[FT_MAX_FHC_RSSI_COUNT];
    short            rssi[FT_MAX_FHC_RSSI_COUNT];
    unsigned short   pwr_det_value[FT_MAX_FHC_FREQ_COUNT][3];
    short            Gbb_Offset[FT_MAX_FHC_RSSI_COUNT];   /**< \brief TX Gbb power compensation */
    unsigned char    rxd_lna_mode[FT_MAX_FHC_RSSI_COUNT]; /**< \brief Rx diversity path lna mode */
    short            rxd_rssi[FT_MAX_FHC_RSSI_COUNT];     /**< \brief Rx diversity path RSSI */
} UL1D_RF_FHC_EX2_CNF_T;

typedef struct
{
    unsigned short m_u2TxPclIndex;
} UL1D_RF_GET_PWR_DET_REPORT_REQ_T;
typedef struct
{
    unsigned short m_u2PwrDetResult;
} UL1D_RF_GET_PWR_DET_REPORT_CNF_T;
typedef struct
{
    unsigned char m_u1PwrCtrlMode;
} UL1D_RF_SET_PWR_CTRL_MODE_REQ_T;
typedef struct
{
    bool              b_afc_dac_valid;
    unsigned short    u2_afc_dac;
    unsigned char     u1_loopbackType;//0: no loopback, 1: loopback type 1, 2: loopback type 2
    unsigned char     u1_frame_shift;//default=0, depends on Test Machine
    unsigned char     u1_rmc_type;//1: 12.2k, 2: 64k, 3: 144k, 4: 384k
    unsigned char     u1_ctfc[4];//8960=0,1,2,3; cmu200=0,2,1,3
    unsigned char     u1_bit_pattern;//0: single ended ber disable, 1: all one, 2: all zero
    short             i2_dl_freq;
    short             i2_dl_psc;/* 0~511. */
    short             i2_dl_ovsf;//RMC12.2k: <128, but test set not allow all ovsf,
    short            i2_ul_freq;
    unsigned short   u2_ul_tfci;
    unsigned int     u4_ul_sc_code;  /* Scrambling code #. 0 ~ 16777215 */
    bool             b_iq_pwr_valid;//valid dpcch, dpdch power
    unsigned char    u1_dpcch_pwr;//default 8, depends on testing requirement
    unsigned char    u1_dpdch_pwr;//default 15, depends on testing requirement
} UL1D_RF_NSFT_REQ_T;

/** list mode */
#if defined(__MTK_INTERNAL__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MTK_INTERNAL__ */
/**
 * META DLL HSPA NSFT parameter
 */
typedef struct
{
    UL1D_RF_NSFT_REQ_T r99Param;
    unsigned char      subTest;
} META_URfTestCmdHspaNsft;

typedef struct
{
    bool    ok;
    unsigned char   num_freq;
    short   dl_freq[ MAX_FREQ_LIST ];
    int rssi[ MAX_FREQ_LIST ];
} URfTestResultRSSI;

/**
 * \brief R8 RF TOOL, the struture use to access both RX path RSSI
 **/
typedef struct
{
    bool    ok;
    unsigned char   num_freq;
    short   dl_freq[ MAX_FREQ_LIST ];
    int rssi[ MAX_FREQ_LIST ];
    int rssi_rxd[ MAX_FREQ_LIST ];
} URfTestResultRSSIRxD;

typedef struct
{
    unsigned short  psc;        /* Primary scrambling code */
    int tm;     /* Cell frame boundary offset to LST */
    short   off;        /* Cell frame number offset to LST */
    bool    sttd;       /* True for STTD used. */
    unsigned char   sample_num;
    short rscp_sum;
    short freq_error;  // 20070514
} UL1TST_cpich_result_T;
#define MAX_NUM_MEAS_CELL 32
typedef struct
{
    bool        ok;
    unsigned char       num_cell;
    UL1TST_cpich_result_T   cpich_result[ MAX_NUM_MEAS_CELL ];
} URfTestResultRSCP;
typedef struct
{
    bool            ok;
    unsigned short  psc;        /* Primary scrambling code */
    int             tm;     /* Cell frame boundary offset to LST */
    bool            sttd;       /* True for STTD used. */
    unsigned char   rscp_sum;
    short           freq_error; //anthony 0514
} URfTestResultAFC;
typedef struct
{
    bool            ok;
    unsigned short  psc;        /* Primary scrambling code */
    int             tm;         /* Cell frame boundary offset to LST */
    bool            sttd;       /* True for STTD used. */
    unsigned char   rscp_sum;
    int             freq_error;
} URfTestResultAFC_Ex;
typedef struct
{
    bool    ok;
    unsigned int    ber;    /* Spec requirement=10^-3. We will count 10^5 frames(100 times spec requirement) for BER calculation. Only count for the only TRCh for DPDCh. */
} URfTestResultRxDPCh;
#define  UL1D_RF_ID_SONY_CXA3359    0x00000001
#define  UL1D_RF_ID_MT6159B         0x00000002
#define  UL1D_RF_ID_SMARTI3G        0x00000003
#define  UL1D_RF_ID_MT6159C         0x00000004
#define  UL1D_RF_ID_MT6159D         0x00000005   /* reserved for MT6159C ECO */
#define  UL1D_RF_ID_MT6159E         0x00000006     /* reserved for MT6159 MP*/
#define  UL1D_RF_ID_MT6160        0x00000007    // OthelloE3, Initially called as AD6551R1
#define  UL1D_RF_ID_MT6161        0x00000010  // O3T
#define  UL1D_RF_ID_MT6162        0x00000008  // OH
#define  UL1D_RF_ID_MT6162_DUAL   0x00000009  // OHa
#define  UL1D_RF_ID_MT6280        0x0000000B
#define  UL1D_RF_ID_MT6167        0x0000000C
#define  UL1D_RF_ID_MT6166        0x0000000D
#define  UL1D_RF_ID_MT6169        0x0000000E

typedef struct
{
    unsigned int m_u4Rfid;
} URfTestResultRFID;
typedef struct
{
    unsigned char m_u1Result;
} URfTestResultPwrDtStep;
typedef struct
{
    unsigned short m_u2Result;
} URfTestResultPwrDtDac;
typedef struct
{
    unsigned char m_u1Result;
} URfTestResultPwrDtDefaultThr;

#define UMTS_SUPPORT_BAND1       0x00000001
#define UMTS_SUPPORT_BAND2       0x00000002
#define UMTS_SUPPORT_BAND3       0x00000004
#define UMTS_SUPPORT_BAND4       0x00000008
#define UMTS_SUPPORT_BAND5       0x00000010
#define UMTS_SUPPORT_BAND6       0x00000020
#define UMTS_SUPPORT_BAND7       0x00000040
#define UMTS_SUPPORT_BAND8       0x00000080
#define UMTS_SUPPORT_BAND9       0x00000100
#define UMTS_SUPPORT_BAND10      0x00000200

#ifdef __WCDMA_EXTRA_BAND__

#define UMTS_SUPPORT_BAND11      0x00000400
#define UMTS_SUPPORT_BAND12      0x00000800
#define UMTS_SUPPORT_BAND13      0x00001000
#define UMTS_SUPPORT_BAND14      0x00002000
#define UMTS_SUPPORT_BAND15_DMY  0x00004000 /* dummy band */
#define UMTS_SUPPORT_BAND16_DMY  0x00008000 /* dummy band */
#define UMTS_SUPPORT_BAND17      0x00010000
#define UMTS_SUPPORT_BAND18_DMY  0x00020000 /* dummy band */
#define UMTS_SUPPORT_BAND19      0x00040000
#define UMTS_SUPPORT_BAND_COUNT  19

#else

#define UMTS_SUPPORT_BAND_COUNT  10

#endif //#ifdef __WCDMA_EXTRA_BAND__

typedef struct
{
    unsigned int    PaOctLevelControl: 1;                  // 0x00000001
    unsigned int    PaPhaseCompensationConversion: 1;      // 0x00000002
    unsigned int    PaCouplerLossByPaMode: 1;              // 0x00000004
    unsigned int    HsdpaNsft: 1;                          // 0x00000008
    unsigned int    HsupaNsft: 1;                          // 0x00000010
    unsigned int    UmtsFddDcxoSupport: 1;                 // 0x00000020
    unsigned int    UmtsFddRxDiversitySupport: 1;          // 0x00000040
    unsigned int    UmtsFddRxDualCellSupport: 1;           // 0x00000080
    unsigned int    PdMeasurementDbConversion: 1;          // 0x00000100
    unsigned int    PaDriftCompenstaion: 1;                // 0x00000200
    unsigned int    UmtsTempAdcUsingL1API: 1;              // 0x00000400
    unsigned int    Dc2DcLevelUnused: 1;                   // 0x00000800
    unsigned int    RxSoftwareModeTracking: 1;             // 0x00001000
    unsigned int    FhcTxVgaBB0Mode: 1;                    // 0x00002000
    unsigned int    FhcTxFrameDurationLimit: 1;            // 0x00004000  /* \brief: frame time 15 ms * x */
    unsigned int    NsftSetICSInitialGain: 1;              // 0x00008000  /* \brief: setup initial gain for ICS */
    //20130425 for PRACH TX Temp. Compensation
    unsigned int    UmtsFddTxPRACHTemperatureCompensationSupport: 1; // 0x00010000  /* \brief: brief: setup temperature compensation for PRACH Tx*/
    unsigned int    RfCapabilityExtension: 1;              // 0x00020000  /* \brief: indicates the extended capability API is supported by UL1 */
} UMTS_MsCapabilityEx_Bits;
typedef struct
{
    unsigned int        capability;
    unsigned int        band_support;
    /* R8 RX diversity band support */
    unsigned int        rxd_band_support;
    /* R8 Pa drift compenstaion band support */
    unsigned int        padrift_band_support;
} UMTS_MsCapabilityEx;
typedef struct
{
    UMTS_MsCapabilityEx_Bits      capability;
    unsigned int                  band_support;
    /* R8 RX diversity band support */
    unsigned int                  rxd_band_support;
    /* R8 Pa drift compenstaion band support */
    unsigned int                  padrift_band_support;
} UMTS_MsCapabilityEx2;
typedef struct
{
    bool         bDataValid;
    unsigned int u4TotalBits; // if bDataValid = true, the value here is valid
    unsigned int u4ErrorBits; // if bDataValid = true, the value here is valid
} UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T;

typedef struct
{
    bool          ok;
    unsigned char link_status;
} UMTS_NSFTLinkStatusReport;

#if defined(__MTK_INTERNAL__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MTK_INTERNAL__ */

typedef struct
{
    bool          ok;    /*<! ok indicator */
    unsigned int  sum;   /*<! the sum of measure_count times of temp sensor result */
} URfTestResultGetRfTempSensor;

typedef struct
{
    unsigned int is_capable      : 1; /*<! the indicator to indicate if this item is supported by SW or HW */
    unsigned int is_mandatory    : 1; /*<! the indicator to indicate if this item is mandatory to be calibrated */
    unsigned int parameter       : 30; /*<! parameter to be carried to tool side */
} UL1TSTCalibrationItem;

typedef struct
{
    unsigned int mipi_pa_support_band; /*<! bit map of mipi pa support band */
} UL1TSTCapabilityItemSet;

/* DO NOT Modify the member order of UL1TSTCalibrationItemSet, Items must be added to the end  */
typedef struct
{
    UL1TSTCalibrationItem tadc_cal; /*<! [0] TADC calibration capability */
    UL1TSTCalibrationItem multi_rat_tadc_bitmap; /*<! [1] bit map of multi-rat TADC calibration */
    UL1TSTCalibrationItem multi_rat_afc_bitmap; /*<! [2] bit map of multi-rat AFC calibration */
    UL1TSTCalibrationItem mipi_pa_level_and_cw_num; /*<! [3] MIPI PA power level and codeword number*/
    UL1TSTCalibrationItem temperature_info; /*<! [4] Target support temperature info. API; is_capable (0: not supported, 1: supported) */
} UL1TSTCalibrationItemSet;

typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} URfTestCmdGetRfCapabilityReq;

typedef struct
{
    int                    valid;
    int                    status;
    UL1TSTCapabilityItemSet capabilityItems;
    UL1TSTCalibrationItemSet calibrationItems;
} URfTestResultGetRfCapabilityCnf;
#define MAX_URF_MIPI_POWER_LEVEL   16
#define MAX_URF_MIPI_CODE_WORD_NUM 16
typedef struct
{
    unsigned short       rf_band_idx;
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_URF_MIPI_POWER_LEVEL][MAX_URF_MIPI_CODE_WORD_NUM];
} URfTestCmdSetMIPICodeWord;
typedef struct
{
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_URF_MIPI_POWER_LEVEL][MAX_URF_MIPI_CODE_WORD_NUM];
} URfTestResultGetMIPICodeWord;
typedef struct
{
    short status;
    short tadc_dac;
    short temperature;
    short temp_index;
} META_Rf_TemperatureInfo_T;

typedef META_Rf_TemperatureInfo_T META_3Grf_TemperatureInfo_T;

typedef union
{
    bool                                   ok;
    char                                   m_i1CurGainTableState;
    unsigned int                           bsi_data;
    unsigned int                           m_u4MaxCapId;
    unsigned char                          currentLnaMode;
    URfTestResultRSSI                      rssi;
    URfTestResultRSSIRxD                   rssi_rxd; /**< \brief R8 get both rx path RSSI */
    URfTestResultAFC                       afc;
    URfTestResultRSCP                      rscp;
    URfTestResultRFID                      rfid;
    UL1D_RF_FHC_CNF_T                      m_rMQCResult;
    URfTestResultAFC_Ex                    afc_ex;
    URfTestResultRxDPCh                    rx_dpch;
    UMTS_MsCapabilityEx                    m_rTargetCapability;
    UL1D_RF_FHC_EX2_CNF_T                  fhcExResult;
    URfTestResultPwrDtDac                  pwr_dt_dac;
    URfTestResultPwrDtStep                 pwr_dt_step;
    UMTS_NSFTLinkStatusReport              m_rNSFTLinkStatusReport;
#if defined(__MTK_INTERNAL__)
/* under construction !*/
#endif /* __MTK_INTERNAL__ */
    URfTestResultGetRfTempSensor           rfTemperature;
    URfTestResultPwrDtDefaultThr           pwr_dt_default_thr;
    UL1D_RF_GET_PWR_DET_REPORT_CNF_T       m_rPwrDetResult;
    UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T m_rNSFTBERResult;
} URfTestResultParam;
META_RESULT  __stdcall META_3Grf_TxAccess(unsigned int  ms_timeout, URfTestCmdTxAccess* req, URfTestResultParam* cnf);
META_RESULT  __stdcall META_3Grf_TxAccess_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdTxAccess* req, URfTestResultParam* cnf);
META_RESULT  __stdcall META_3Grf_TestStop(unsigned int  ms_timeout, URfTestResultParam* cnf);
META_RESULT  __stdcall META_3Grf_TestStop_r(const int meta_handle, unsigned int  ms_timeout, URfTestResultParam* cnf);
META_RESULT  __stdcall META_3Grf_TxDpch(unsigned int  ms_timeout, URfTestCmdTxDPCh* req, URfTestResultParam* cnf);
META_RESULT  __stdcall META_3Grf_TxDpch_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdTxDPCh* req, URfTestResultParam* cnf);
META_RESULT  __stdcall META_3Grf_RxDpch(unsigned int  ms_timeout, URfTestCmdRxDPCh* req, URfTestResultRxDPCh* cnf);
META_RESULT  __stdcall META_3Grf_RxDpch_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdRxDPCh* req, URfTestResultRxDPCh* cnf);
META_RESULT  __stdcall META_3Grf_Rssi(unsigned int  ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSI* cnf);
META_RESULT  __stdcall META_3Grf_Rssi_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSI* cnf);

/**V
 * \brief R8 RF tool. RX diversity RSSI.
 **/
META_RESULT  __stdcall META_3Grf_RxDRssi(unsigned int  ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSIRxD* cnf);
META_RESULT  __stdcall META_3Grf_RxDRssi_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdRSSI* req, URfTestResultRSSIRxD* cnf);

META_RESULT  __stdcall META_3Grf_Rscp(unsigned int  ms_timeout, URfTestCmdRSCP* req, URfTestResultRSCP* cnf);
META_RESULT  __stdcall META_3Grf_Rscp_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdRSCP* req, URfTestResultRSCP* cnf);
META_RESULT  __stdcall META_3Grf_Set_Tx_PaApc(unsigned int  ms_timeout, UL1D_RF_TX_PA_APC_REQ_T* req);
META_RESULT  __stdcall META_3Grf_Set_Tx_PaApc_r(const int meta_handle, unsigned int  ms_timeout, UL1D_RF_TX_PA_APC_REQ_T* req);
META_RESULT  __stdcall META_3Grf_AFC(unsigned int  ms_timeout, URfTestCmdAFC* req, URfTestResultAFC* cnf);
META_RESULT  __stdcall META_3Grf_AFC_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdAFC* req, URfTestResultAFC* cnf);
META_RESULT  __stdcall META_3Grf_GetRFID(unsigned int  ms_timeout, URfTestResultRFID* cnf);
META_RESULT  __stdcall META_3Grf_GetRFID_r(const int meta_handle, unsigned int  ms_timeout, URfTestResultRFID* cnf);
META_RESULT  __stdcall META_3Grf_ConfigHWTPC(unsigned int  ms_timeout, UL1D_RF_HWTPC_CONFIG_REQ_T* req);
META_RESULT  __stdcall META_3Grf_ConfigHWTPC_r(const int meta_handle, unsigned int  ms_timeout, UL1D_RF_HWTPC_CONFIG_REQ_T* req);
META_RESULT  __stdcall META_3Grf_GetPwrDtStep(unsigned int  ms_timeout, URfTestResultPwrDtStep* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtStep_r(const int meta_handle, unsigned int  ms_timeout, URfTestResultPwrDtStep* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtDac(unsigned int  ms_timeout, URfTestResultPwrDtDac* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtDac_r(const int meta_handle, unsigned int  ms_timeout, URfTestResultPwrDtDac* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtDefaultThr(unsigned int  ms_timeout, UL1D_RF_GET_PWR_THR_REQ_T* req, URfTestResultPwrDtDefaultThr* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtDefaultThr_r(const int meta_handle, unsigned int  ms_timeout, UL1D_RF_GET_PWR_THR_REQ_T* req, URfTestResultPwrDtDefaultThr* cnf);
META_RESULT  __stdcall META_3Grf_SetImmediateBSI(unsigned int  ms_timeout, const UL1D_RF_SET_BSI_DATA_REQ_T* req);
META_RESULT  __stdcall META_3Grf_SetImmediateBSI_r(const int meta_handle, unsigned int  ms_timeout, const UL1D_RF_SET_BSI_DATA_REQ_T* req);
META_RESULT  __stdcall META_3Grf_GetImmediateBSI(unsigned int  ms_timeout, const UL1D_RF_GET_BSI_DATA_REQ_T* req, unsigned int* p_bsi_data);
META_RESULT  __stdcall META_3Grf_GetImmediateBSI_r(const int meta_handle, unsigned int  ms_timeout, const UL1D_RF_GET_BSI_DATA_REQ_T* req, unsigned int* p_bsi_data);
META_RESULT  __stdcall META_3Grf_ContinuousRX(unsigned int  ms_timeout, URfTestCmdRSSI* req);
META_RESULT  __stdcall META_3Grf_ContinuousRX_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdRSSI* req);
META_RESULT  __stdcall META_3Grf_FHC_Start(unsigned int  ms_timeout, const UL1D_RF_FHC_REQ_T* req, UL1D_RF_FHC_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_FHC_Start_r(const int meta_handle, unsigned int  ms_timeout, const UL1D_RF_FHC_REQ_T* req, UL1D_RF_FHC_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_FHC_NoWaitResult(unsigned int  ms_timeout, const UL1D_RF_FHC_REQ_T* req);
META_RESULT  __stdcall META_3Grf_FHC_NoWaitResult_r(const int meta_handle, unsigned int  ms_timeout, const UL1D_RF_FHC_REQ_T* req);
META_RESULT  __stdcall META_3Grf_QueryFHCResult(unsigned int  ms_timeout, UL1D_RF_FHC_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_QueryFHCResult_r(const int meta_handle, unsigned int  ms_timeout, UL1D_RF_FHC_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtMeasureResult(unsigned int ms_timeout,
        const UL1D_RF_GET_PWR_DET_REPORT_REQ_T* req,
        UL1D_RF_GET_PWR_DET_REPORT_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_GetPwrDtMeasureResult_r(const int meta_handle, unsigned int ms_timeout,
        const UL1D_RF_GET_PWR_DET_REPORT_REQ_T* req,
        UL1D_RF_GET_PWR_DET_REPORT_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_SetPowerControlMode(unsigned int ms_timeout, const UL1D_RF_SET_PWR_CTRL_MODE_REQ_T* req);
META_RESULT  __stdcall META_3Grf_SetPowerControlMode_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_SET_PWR_CTRL_MODE_REQ_T* req);
META_RESULT  __stdcall META_3Grf_ReplaceGainTableforCal(unsigned int ms_timeout, const unsigned char* pTableType, char* pCurState);
META_RESULT  __stdcall META_3Grf_ReplaceGainTableforCal_r(const int meta_handle, unsigned int ms_timeout, const unsigned char* pTableType, char* pCurState);
META_RESULT  __stdcall META_3Grf_QueryTargetCapability(unsigned int  ms_timeout, UMTS_MsCapabilityEx* cnf);
META_RESULT  __stdcall META_3Grf_QueryTargetCapability_r(const int meta_handle, unsigned int  ms_timeout, UMTS_MsCapabilityEx* cnf);
META_RESULT  __stdcall META_3Grf_NSFT_Start(unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req);
META_RESULT  __stdcall META_3Grf_NSFT_Start_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req);
META_RESULT  __stdcall META_3Grf_NSFT_GetBitCountForSingleEndedBER(unsigned int ms_timeout, UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_NSFT_GetBitCountForSingleEndedBER_r(const int meta_handle, unsigned int ms_timeout, UL1D_RF_NSFT_GET_BIT_CNT_FOR_BER_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_NSFT_SetILPCStep(unsigned int ms_timeout, unsigned char step);
META_RESULT  __stdcall META_3Grf_NSFT_SetILPCStep_r(const int meta_handle, unsigned int ms_timeout, unsigned char step);
META_RESULT  __stdcall META_3Grf_NSFT_StartEx(unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req, UMTS_NSFTLinkStatusReport* cnf);
META_RESULT  __stdcall META_3Grf_NSFT_StartEx_r(const int meta_handle, unsigned int ms_timeout, const UL1D_RF_NSFT_REQ_T* req, UMTS_NSFTLinkStatusReport* cnf);
META_RESULT  __stdcall META_3Grf_HsdpaNsftStart(unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);
META_RESULT  __stdcall META_3Grf_HsdpaNsftStart_r(const int meta_handle, unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);
META_RESULT  __stdcall META_3Grf_HsupaNsftStart(unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);
META_RESULT  __stdcall META_3Grf_HsupaNsftStart_r(const int meta_handle, unsigned int ms_timeout, const META_URfTestCmdHspaNsft* req, UMTS_NSFTLinkStatusReport* cnf);
#if defined(__MTK_INTERNAL__)
/* under construction !*/
/* under construction !*/
#endif /* __MTK_INTERNAL__ */
META_RESULT  __stdcall META_3Grf_FHC_StartEx(unsigned int  ms_timeout, const UL1D_RF_FHC_EX_REQ_T* req);
META_RESULT  __stdcall META_3Grf_FHC_StartEx_r(const int meta_handle, unsigned int  ms_timeout, const UL1D_RF_FHC_EX_REQ_T* req);
META_RESULT  __stdcall META_3Grf_QueryFHCExResult(unsigned int  ms_timeout, UL1D_RF_FHC_EX2_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_QueryFHCExResult_r(const int meta_handle, unsigned int  ms_timeout, UL1D_RF_FHC_EX2_CNF_T* cnf);
META_RESULT  __stdcall META_3Grf_QueryCurrentLnaMode(unsigned int  ms_timeout, unsigned char* mode);
META_RESULT  __stdcall META_3Grf_QueryCurrentLnaMode_r(const int meta_handle, unsigned int ms_timeout, unsigned char* mode);
/**
 * pass cell power to UL1 to choose the best initial gain for ICS
 **/
META_RESULT  __stdcall META_3Grf_Set_Initial_Cellpower(unsigned int ms_timeout, int confg_cell/*uints:qdbm*/);
META_RESULT  __stdcall META_3Grf_Set_Initial_Cellpower_r(const int meta_handle, unsigned int ms_timeout, int confg_cell/*uints:qdbm*/);
/**
 * R8 get RxD LNA mode
 */
META_RESULT  __stdcall META_3Grf_QueryCurrentRxDLnaMode(unsigned int ms_timeout, unsigned char* mode);
META_RESULT  __stdcall META_3Grf_QueryCurrentRxDLnaMode_r(const int meta_handle, unsigned int ms_timeout, unsigned char* mode);
META_RESULT  __stdcall META_3Grf_SetCapId(unsigned int  ms_timeout, unsigned int capId);
META_RESULT  __stdcall META_3Grf_SetCapId_r(const int meta_handle, unsigned int ms_timeout, unsigned int capId);
META_RESULT  __stdcall META_3Grf_GetMaxCapId(unsigned int  ms_timeout, unsigned int* capId);
META_RESULT  __stdcall META_3Grf_GetMaxCapId_r(const int meta_handle, unsigned int ms_timeout, unsigned int* capId);
META_RESULT  __stdcall META_3Grf_AFC_Ex(unsigned int  ms_timeout, URfTestCmdAFC* req, URfTestResultAFC_Ex* cnf);
META_RESULT  __stdcall META_3Grf_AFC_Ex_r(const int meta_handle, unsigned int  ms_timeout, URfTestCmdAFC* req, URfTestResultAFC_Ex* cnf);
/* R8 RF tool */
META_RESULT __stdcall META_3Grf_SetRxBandwidth(unsigned int ms_timeout, unsigned char is_5mhz);
META_RESULT __stdcall META_3Grf_SetRxBandwidth_r(const int meta_handle, unsigned int ms_timeout, unsigned char is_5mhz);
/**
 * Starts from R8(MT6280)
 * The RX path splits into two path: main and diversity.
 */
typedef enum
{
    RX_PATH_NONE,
    RX_PATH_MAIN,
    RX_PATH_DIVERSITY,
    RX_PATH_BOTH
} RF_RX_PATH_T;

META_RESULT __stdcall META_3Grf_SetRxAntenna(unsigned int ms_timeout, RF_RX_PATH_T is_main);
META_RESULT __stdcall META_3Grf_SetRxAntenna_r(const int meta_handle, unsigned int ms_timeout, RF_RX_PATH_T is_main);
META_RESULT __stdcall META_3Grf_SetTxPaDriftCompEnable(unsigned int ms_timeout, unsigned char is_PaDrift);
META_RESULT __stdcall META_3Grf_SetTxPaDriftCompEnable_r(const int meta_handle, unsigned int ms_timeout, unsigned char is_PaDrift);
META_RESULT __stdcall META_3Grf_GetRfTemperature(unsigned int ms_timeout, const unsigned short measureCount, URfTestResultGetRfTempSensor* cnf);
META_RESULT __stdcall META_3Grf_GetRfTemperature_r(const int meta_handle, unsigned int ms_timeout, const unsigned short measureCount, URfTestResultGetRfTempSensor* cnf);
META_RESULT __stdcall META_3Grf_GetRfCapability(unsigned int ms_timeout, const URfTestCmdGetRfCapabilityReq* req, const unsigned int requestLength, URfTestResultGetRfCapabilityCnf* cnf, const unsigned int responseLength);
META_RESULT __stdcall META_3Grf_GetRfCapability_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdGetRfCapabilityReq* req, const unsigned int requestLength, URfTestResultGetRfCapabilityCnf* cnf, const unsigned int responseLength);
META_RESULT __stdcall META_3Grf_SetMIPICodeWord(unsigned int ms_timeout, const URfTestCmdSetMIPICodeWord* req);
META_RESULT __stdcall META_3Grf_SetMIPICodeWord_r(const int meta_handle, unsigned int ms_timeout, const URfTestCmdSetMIPICodeWord* req);
META_RESULT __stdcall META_3Grf_GetMIPICodeWord(unsigned int ms_timeout, const unsigned short RfBandIndex, URfTestResultGetMIPICodeWord* cnf);
META_RESULT __stdcall META_3Grf_GetMIPICodeWord_r(const int meta_handle, unsigned int ms_timeout, const unsigned short RfBandIndex, URfTestResultGetMIPICodeWord* cnf);
META_RESULT __stdcall META_3Grf_GetTemperatureInfo(const unsigned int ms_timeout, META_3Grf_TemperatureInfo_T* info);
META_RESULT __stdcall META_3Grf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, META_3Grf_TemperatureInfo_T* info);
const char* __stdcall META_3Grf_GetRfChipIdName(unsigned int id);
#endif  // end of #ifdef __META_DLL_WCDMA__

//--------------------------------------------------------------------------//
//  RF Testing                                                              //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  RF Testing: data structure definition              //
//-----------------------------------------------------//
typedef short   ARFCN;
typedef short   Gain;
typedef char    BSIC;
typedef short   Power;
typedef unsigned char   TimingAdvance;
typedef char    TSC;
typedef char    TimeSlot;

// RF ID
#define  RF_ID_UNKNOWN     0x00000000
#define  RF_ID_BRIGHT2     0x00000001
#define  RF_ID_BRIGHT4     0x00000002
#define  RF_ID_AERO        0x00000004
#define  RF_ID_AERO1PLUS   0x00000008
#define  RF_ID_POLARIS1    0x00000010
#define  RF_ID_POLARIS2    0x00000020
#define  RF_ID_SKY74045    0x00000040
#define  RF_ID_BRIGHT5P    0x00000080
#define  RF_ID_MT6116      0x00000100
#define  RF_ID_MT6119      0x00000200
#define  RF_ID_MT6119C     0x00000400
#define  RF_ID_MT6129A     0x00000800
#define  RF_ID_MT6129B     0x00001000
#define  RF_ID_MT6129C     0x00002000
#define  RF_ID_MT6129D     0x00004000
#define  RF_ID_MT6139B     0x00008000
#define  RF_ID_MT6139C     0x00010000
#define  RF_ID_MT6140A     0x00020000
#define  RF_ID_SKY74117    0x00040000
#define  RF_ID_SKY74400    0x00080000
#define  RF_ID_AERO2       0x00100000
#define  RF_ID_MT6140B     0x00200000
#define  RF_ID_ALICEG2S    0x00400000
#define  RF_ID_MT6139E     0x00800000
#define  RF_ID_SKY74137    0x01000000
#define  RF_ID_MT6140C     0x02000000
#define  RF_ID_GRF6201     0x04000000
#define  RF_ID_IRFS3001    0x08000000
#define  RF_ID_MT6140D     0x10000000
#define  RF_ID_AG2550      0x10000001
#define  RF_ID_AERO2E      0x10000002
#define  RF_ID_AD6548      0x10000005
#define  RF_ID_AD6546      0x10000006
//#define  RF_ID_A60111A     0x10000007
#define  RF_ID_CMOSEDGE    0x10000007
#define  RF_ID_MTKSOC1     0x10000008
#define  RF_ID_MT6256RF    0x10000009
#define  RF_ID_MT6251RF    0x1000000a
#define  RF_ID_MT6252RF    0x1000000c
#define  RF_ID_MT6162      0x1000000d
#define  RF_ID_MT6163      0x1000000e
#define  RF_ID_MT6255RF    0x1000000f
#define  RF_ID_MT6250RF    0x10000010
#define  RF_ID_MT6280RF    0x10000011
#define  RF_ID_MT6167RF    0x10000012
#define  RF_ID_MT6260RF    0x10000013
#define  RF_ID_MT6166RF    0x10000014
#define  RF_ID_MT6169RF    0x10000015
#define  RF_ID_MT6165RF    0x10000016
#define  RF_ID_MT6261RF    0x10000017

typedef enum
{
    FrequencyBand400 = 0,            // GSM 450/480 band
    FrequencyBand850,                // GSM 850 band
    FrequencyBand900,                // GSM 900 band
    FrequencyBand1800,               // DCS 1800 band
    FrequencyBand1900,               // PCS 1900 band

    FrequencyBandCount               // count of supported bands
} FrequencyBand;

typedef struct
{
    ARFCN           arfcn;              // Absolute radio frequency channel number
    char            sampleNoPerFrame;   // number of samples per frame
    Gain            gain;               // Gain that should be used in power management
    short           frames;             // number of frames
} RfPm_Req;

typedef struct
{
    unsigned char   valid;              // if valid != zero, it means the extra info is meaningful.
    // otherwise, the extra info should be ignore.
    int             iOffset;
    int             qOffset;
    int             validSamples;
} RfPmExtraInfo_T;

/**
 * This request structure is used for Power scan specified if flag
 */
typedef struct
{
    /// original power scan request
    RfPm_Req        m_Pm;
    /// if flag used for specifying the if flag in power scan (override the if flag setting)
    char   m_IfFlag;
} RfIfPm_Req;

typedef struct
{
    int             power;              // average power
    int             deviation;          // deviation of power measurement
    Gain            usedGain;           // Gain that is used
    unsigned char   ok;                 // status
    RfPmExtraInfo_T extra_info;         // extra info
} RfPm_Cnf;

typedef struct
{
    ARFCN           arfcn;              // absolute radio frequency channel number
    short           dacValue;           // AFC DAC value
    Gain            gain;               // gain used for AFC testing
    short           testNumber;         // test number
} RfAfc_Req;

typedef struct
{
    short           fcb_ok_number;      // successful number of FCB decoded
    int             freqOffset;         // average frequency error
    int             deviation;          // deviation of frequency error
    unsigned char   ok;                 // status
} RfAfc_Cnf;

typedef enum
{
    AB_TX_RANDOM_WITH_SYNC_SEQ
    , NB_TX_ALL_ZEROS_WITHOUT_TSC
    , NB_TX_ALL_ONES_WITHOUT_TSC
    , NB_TX_ALTER_BITS_WITHOUT_TSC
    , NB_TX_RANDOM_WITH_TSC
    , NB_TX_PATTERN_WITHOUT_TSC
    , NB_TX_FIXED_RANDOM_WITH_TSC
    , NB_TX_FIXED_ALL_ZEROS_WITH_TSC
    , NB_TX_FIXED_ALTER_BITS_WITH_TSC
    , NB_TX_FIXED_ALL_ONES_WITH_TSC
    , NB_TX_FIXED_OE_PATTERN_WITH_TSC
} APCTxPattern;

typedef struct
{
    ARFCN           arfcn;              // Absolute radio frequency channel number
    BSIC            bsic;               // bsic value used in transmission
    Power           power;              // Tx power in the unit of PCL
    short           frames;             // the number of frames NB should transmit
    short           dacValue;           // AFC DAC value
    APCTxPattern    burstTypeNB;
} RfNbtx_Req;

typedef struct
{
    ARFCN           arfcn;              // Absolute radio frequency channel number
    Gain            gain;               // Gain that should be used
    unsigned char   OnOff;              // On or off
} RfCnRx_Req;

typedef enum
{
    CONT_TX_ALL_ZEROS
    , CONT_TX_ALL_ONES
    , CONT_TX_ALTERNATE_BITS
    , CONT_TX_PSEUDO_RANDOM
    , CONT_TX_PATTERN_WITHOUT_TSC
} ContTxPattern;

typedef struct
{
    ARFCN           arfcn;              // Absolute radio frequency channel number
    ContTxPattern   pattern;
    unsigned char   OnOff;              // On or off
} RfCnTx_Req;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
} RfSetBBTXCfg_Req;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
    char    TxCalbias;
    char    TxIQSwap;
    char    TxCMV;
    char    TxGain;
    char    TxCalrcsel;
} RfBBTXCfg2;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
    char    TxCalbias;
    char    TxIQSwap;
    char    TxCMV;
    char    TxGain;
    char    TxCalrcsel;
    char    TxPhasesel;
} RfBBTXCfg3;

typedef struct
{
    char    TxTrimI;
    char    TxTrimQ;
    char    TxOffsetI;
    char    TxOffsetQ;
    char    TxCalbias;
    char    TxIQSwap;
    char    TxCMV;
    char    TxGain;
    char    TxCalrcsel;
    char    TxPhasesel;
    char    TxCoarseI;
    char    TxCoarseQ;

} RfBBTXCfg4; //RfTestCmdSetBBTXCfg4

typedef struct
{
    unsigned char bbtx_common_mode_voltage;
    unsigned char bbtx_gain;
    unsigned char bbtx_calrcsel;
//    unsigned char bbtx_coarseI; // need to set
//   unsigned char bbtx_coarseQ; // need to set
    unsigned char bbtx_trimI;   // need to set
    unsigned char bbtx_trimQ;   // need to set
    unsigned char bbtx_dccoarseI; // need to set
    unsigned char bbtx_dccoarseQ; // need to set
    unsigned char bbtx_offsetI; // need to set
    unsigned char bbtx_offsetQ; // need to set
    unsigned char bbtx_isCalibrated; // need to set
    int           apc_bat_low_voltage;
    int           apc_bat_high_voltage;
    int           apc_bat_low_temperature;
    int           apc_bat_high_temperature;
    unsigned char bbtx_common_mode_voltage_h;
    unsigned char bbtx_gain_h;
    unsigned char bbtx_calrcsel_h;
    unsigned char bbtx_trimI_h;
    unsigned char bbtx_trimQ_h;
//    unsigned char bbtx_coarseI_h;
//    unsigned char bbtx_coarseQ_h;
    unsigned char bbtx_dccoarseI_h;
    unsigned char bbtx_dccoarseQ_h;

    unsigned char bbtx_offsetI_h;
    unsigned char bbtx_offsetQ_h;
    unsigned char bbtx_phsel;
    unsigned char bbtx_phsel_h;
//    unsigned char bbrx_gsm850_gsm900_swap;
//   unsigned char bbrx_dcs1800_pcs1900_swap;
} BBTXParameters_T;
typedef enum
{
    CodingSchemeNone = 0,
    CodingSchemeCS1,
    CodingSchemeCS2,
    CodingSchemeCS3,
    CodingSchemeCS4,
    CodingSchemePRACh8,
    CodingSchemePRACh11,
    CodingSchemeMCS1,
    CodingSchemeMCS2,
    CodingSchemeMCS3,
    CodingSchemeMCS4,
    CodingSchemeMCS5,
    CodingSchemeMCS6,
    CodingSchemeMCS7,
    CodingSchemeMCS8,
    CodingSchemeMCS9,
    CodingSchemeCount,
} CodingScheme;

typedef struct
{
    ARFCN           arfcn;          // absolute radio frequency channel number
    BSIC            bsic;           // training sequence
    char            timeSlotmask;   // time slot mask, slot_1: 0x01, slot_2: 0x02, slot_3: 0x04, slot_4: 0x08
    Power           powerLev[4];    // power level for each time slot
    CodingScheme    cs[4];          // coding scheme for each time slot
    TimingAdvance   ta;             // time advance
    int             frames;         // the number of frames should transmit
    short           dacValue;       // AFC DAC value
} RfMultiSlotTX_Req;

typedef struct
{
    FrequencyBand   rf_band;
    int             power_level;
    int             apc_dac;
} RfSetRampApcLevel_Req;

typedef struct
{
    short           dacValue;       // AFC DAC value
} RfSetAfcDacValue_Req;

typedef struct
{
    int             cap_id;
} RfSetCrystalCfg_Req;

typedef struct
{
    ARFCN           arfcn;          // absolute radio frequency channel number
    BSIC            bsic;           // training sequence
    char            timeSlotmask;   // time slot mask, slot_1: 0x01, slot_2: 0x02, slot_3: 0x04, slot_4: 0x08
    Power           powerLev[4];    // power level for each time slot
    CodingScheme    cs[4];          // coding scheme for each time slot, MCS1~9 is only valid for EPSK function
    TimingAdvance   ta;             // time advance
    int             frames;         // the number of frames should transmit
    short           dacValue;       // AFC DAC value
    APCTxPattern    pattern;        // Tx pattern is only valid for EPSK function
    unsigned short  pattern_data;   // if NB_TX_PATTERN_WITHOUT_TSC==pattern, user can input any 16bits value as pattern.
} Rf_MultiSlotTXEx_Req;

typedef struct
{
    unsigned int    id;             // please refer RF_ID_XXXX
} RFMod_ID;

typedef enum
{
    MS_GSM = 0
             , MS_GPRS
    , MS_EGPRS_RX_ONLY
    , MS_EGPRS_FULL_FUNCTION
} MS_CAPABILITY_E;

typedef struct
{
    unsigned int    GSM400;         // Zero: not support, Non-zero: support
    unsigned int    GSM850;
    unsigned int    GSM900;
    unsigned int    DCS1800;
    unsigned int    PCS1900;
} RFBandSupport_S;

typedef struct
{
    MS_CAPABILITY_E     capability;
    RFBandSupport_S     band_support;
} RfMsCapability_S;

typedef struct
{
    unsigned int    GSM: 1;
    unsigned int    GPRS: 1;
    unsigned int    EDGE_RX: 1;
    unsigned int    EDGE_8PSK_TX: 1;
    unsigned int    Calibration_8PM: 1;
} RfMsCapabilityBits;

typedef struct
{
    unsigned int    GSM400: 1;
    unsigned int    GSM850: 1;
    unsigned int    GSM900: 1;
    unsigned int    DCS1800: 1;
    unsigned int    PCS1900: 1;
} RfMsBandSupportBits;

typedef struct
{
    RfMsCapabilityBits      capability;
    RfMsBandSupportBits     band_support;
} RfMsCapabilityEx_S;


typedef struct
{
    unsigned int    GSM: 1;
    unsigned int    GPRS: 1;
    unsigned int    EDGE_RX: 1;
    unsigned int    EDGE_8PSK_TX: 1;
    unsigned int    Calibration_8PM: 1;
    unsigned int    Calibration_FDT: 1;     // new
    unsigned int    Calibration_33Steps: 1; // new
    unsigned int    NSFT: 1; // NSFT
    unsigned int    AFCType: 1; // AFC Type
    unsigned int    GMSKClosedLoopPowerControl: 1;
    unsigned int    OpenLoopPowerControl: 1;
    unsigned int    ClosedLoopPowerControlTemperature: 1;
    unsigned int    EPSKClosedLoopPowerControl: 1;
    unsigned int    MiddleLowLnaCalibration: 1;
    unsigned int    AuxTempADC: 1;
    unsigned int    BsiTempADC: 1;
} RfMsCapabilityBits_2;

typedef struct
{
    RfMsCapabilityBits_2        capability;
    RfMsBandSupportBits     band_support;
} RfMsCapabilityEx2_S;

typedef struct
{
    unsigned short support_gsm: 1;
    unsigned short support_gprs: 1;
    unsigned short support_edge_rx: 1;
    unsigned short support_epsk_tx: 1;
    unsigned short support_8pm: 1;
    unsigned short support_fhc: 1;
    unsigned short support_nsft: 1;
    unsigned short band_gsm400: 1;
    unsigned short band_gsm850: 1;
    unsigned short band_gsm900: 1;
    unsigned short band_dcs1800: 1;
    unsigned short band_pcs1900: 1;
    /**
     * base on the PS edge switch
     * 0: check the EDGE TX power
     * 1: by pass check
     */
    unsigned short ps_unsupport_edge_tx: 1;
    unsigned short reserved1: 2;
} RfCapabilityItem;


/**
 * Description: get the tx_pcl GMSK and EPSK version from the parameter field
 **/
#define TX_PCL_EPSK_VERSION_MASK (0x7F << 7)
#define GET_EPSK_VERSION(x) (((x) & TX_PCL_EPSK_VERSION_MASK) >> 7)
#define GET_GSM_VERSION(x) ((x) & 0x0001)
//Battery Compensate
/**
 * When the sw capability for EDGE Battery Compensation is equal to 1, and in 14-bits paramter, LSB of first 7 bits equals 1.
 * unit conversion for EDGE Battery Compensation becomes as dBm, Otherwise, in 14-bits paramter, LSB of first 7 bits equals 0.,
 * unit conversion for EDGE Battery Compensation do not change (still use weighting)
 */

typedef struct
{
    unsigned short is_capable: 1;
    unsigned short is_mandatory: 1;
    unsigned short parameter: 14;
} RfFactoryModeCalItem;
typedef struct
{
    RfFactoryModeCalItem cap_id; /* 0 */
    RfFactoryModeCalItem afc; /* 1 */
    RfFactoryModeCalItem rx_pathloss; /* 2 */
    RfFactoryModeCalItem tx_pcl; /* 3 */
    RfFactoryModeCalItem tx_subband; /* 4 */
    RfFactoryModeCalItem trx_offset; /* 5 */
    RfFactoryModeCalItem tx_iq; /* 6 */
    RfFactoryModeCalItem tx_fb_dac; /* 7 */
    RfFactoryModeCalItem tx_slope_skew; /* 8 */
    RfFactoryModeCalItem w_coef; /* 9 */
    RfFactoryModeCalItem txpc; /* 10 */
    RfFactoryModeCalItem temp_adc; /* 11 */
    RfFactoryModeCalItem remove_32k_xo; /* 12 */
    RfFactoryModeCalItem co_crystal; /* 13 */
    RfFactoryModeCalItem high_lna_sp; /* 14 */
    RfFactoryModeCalItem mid_lna_sp; /* 15 */
    RfFactoryModeCalItem low_lna_sp; /* 16 */
    //Battery Compensate
    /** for EPSK new feature
     * When the sw capability for EDGE Battery Compensation is equal to 1, and in 14-bits paramter, LSB of first 7 bits equals 1.
     * unit conversion for EDGE Battery Compensation becomes as dBm, Otherwise, in 14-bits paramter, LSB of first 7 bits equals 0.,
     * unit conversion for EDGE Battery Compensation do not change (still use weighting)
     */
    RfFactoryModeCalItem bat_temp_comp; /* 17 */
    RfFactoryModeCalItem dts_gain_cmb; /* 18 */
    //---------------------------------------------------------------------------
    // parameter: 0, capable: 1, mandatory: 1 ==> support FHC double-band combine, but only 50 steps (orignal interface)
    // parameter: 1, capable: 1, mandatory: 1 ==> support FHC double-band combine, but only 100 steps (Big interface)
    //---------------------------------------------------------------------------
    RfFactoryModeCalItem uts_band_cmb; /* 19 */
    //---------------------------------------------------------------------------
    // Temp ADC on TDD mode, use the same NVRAM item of 2G temperature ADC("NVRAM_EF_L1_TEMPERATURE_ADC_LID")
    // When the sw capability for co_temp_adc is equal to 1,
    // it means 2G and TDD use the same NVRAM item of 2G temperature ADC
    // (TDD: "NVRAM_EF_AST_TL1_TEMP_DAC_LID")
    //---------------------------------------------------------------------------
    RfFactoryModeCalItem co_temp_adc; /* 20 */
    //------------------------------------------------------
    // Fill middle/low mode of LNA path loss by high mode result
    //-----------------------------------------------------
    RfFactoryModeCalItem adjustable_lna_mode_pathloss; /* 21 */
    //------------------------------------------------------
    // Indicate the EDGE TX should calibrated by gain rf mechanism
    // parameter: 0, capable: 1, mandatory: 1
    //-----------------------------------------------------
    RfFactoryModeCalItem gain_rf_cal; /* 22 */
    /**
     * Indicate the AP/MD NVRAM check is required or not
     * is_capable: 0: check AP/MD NVRAM, 1: bypass AP/MD NVRAM check
     * is_mandatory: don't care
     * parameter: check capability when is_capable equal to 0
     *      1: GPS co-clock configure correct. Do GPS co-clock.
     *      Others: Error => check WMT.CFG
     **/
    RfFactoryModeCalItem bypass_check_fixafc; /* 23 */
    /**
     * Bit map used to indicate the TADC calibration data can be shared between different RAT
     * the bitmap is defined in parameter part and starts from LSB to MSB
     * new RAT can be extended upto 14 RATs
     */
    RfFactoryModeCalItem multi_rat_tadc_bitmap; /* 24 */
    /**
     * Bit map used to indicate the AFC calibration data can be shared between different RAT
     * the bitmap is defined in parameter part and starts from LSB to MSB
     * new RAT can be extended upto 14 RATs
     */
    RfFactoryModeCalItem multi_rat_afc_bitmap; /* 25 */
    /**
     * unsigned short    cal_lna_mode    :4;     // LNA mode(s) need to be calibrated (Bitwise)
     * unsigned short    dup_lna_src     :4;     // Duplicated LNA mode From (Bitwise)
     * unsigned short    dup_lna_dest    :4;     // Duplicated LNA mode To (Bitwise)
     * unsigned short    reserved        :2;
     **/
    RfFactoryModeCalItem reduce_rx_lna_cal; /* 26 */
    /**
     * Indicate the Get temperature info. API is available on the target
     * is_capable: 0: not supported, 1: supported
     * is_mandatory: don't care
     * parameter: don't care
     **/
    RfFactoryModeCalItem temperature_info; /* 27 */
    /**
     * Indicate the Get temperature info. API is available on the target
     * is_capable: 0: not supported, 1: supported
     * is_mandatory: don't care
     * parameter: the band support bit-map from of GSM850, GSM900, DCS1800, PCS1900 (from LSB to MSB)
     **/
    RfFactoryModeCalItem dt_coexistence_info; /* 28 */
} RfCalibrationItem;
typedef struct
{
    int                  valid;
    int                  status;
    RfCapabilityItem     capabilityItems;
    RfCalibrationItem    calibrationItems;
} RfMsCapabilityEx3_S;

typedef enum
{
    AFC_SINWAVE_OFF = 0,
    AFC_SINWAVE_ON
} AFC_SINWAVE_DETECTION_E;

typedef struct
{
    ARFCN           arfcn;              // Absolute radio frequency channel number
    ContTxPattern   pattern;
    unsigned short  pattern_data;
    unsigned char   OnOff;              // On or off
    unsigned short  modtype;            // modulation type: 0->GMSK, 1->EPSK
} RfCnTxEx_Req;

typedef struct
{
    ARFCN           arfcn;              // Absolute radio frequency channel number
    ContTxPattern   pattern;
    unsigned short  pattern_data;
    unsigned char   OnOff;              // On or off
    unsigned short  modtype;            // modulation type: 0->GMSK, 1->EPSK
    Power           powerLev;           // power level
} RfCnTxEx2_Req;

typedef struct
{
    short           dacValue;       // AFC DAC value
} RfGetAfcDacValueAtRTXOffsetCal;

//----------  FDT related structure -----------------------

#define MAX_STEP_CNT   50
typedef struct
{
    FrequencyBand      band;
    ARFCN              arfcn;
    short              dac_value[33];
    Gain               gain;
    short              repeat_cnt;   // repetitive test counts (frames) for each AFC DAC value
    bool               capid_cal;    // capid calibration ctrl
    bool               linear_cal;   // 33 stages calibration ctrl
    //char                 capid_min;    // min value for capid range when capid_cal is True; capid when capid_cal is False
    //char                 capid_max;    // max value for capid range
    int                capid_min;    // min value for capid range when capid_cal is True; capid when capid_cal is False
    int                capid_max;    // max value for capid range

} Rf_DSSAFC_T;

typedef struct
{
    FrequencyBand       band;
    ARFCN               arfcn;
    Gain                gain[6];     // gain for rx slot 0/1/2/3/4/5
    short               repeat_cnt;  // repetitive test counts (frames) for each ARFCN value
//   short             dac_value;   // Use InitDacValue from AFC calibration when dacValue = 0 (or -1)
} Rf_DSSPL_T;

typedef struct
{
    bool                afc_cal;
    bool                pl_cal;       // Control whether Path loss calibration is needed or not
    char                sync_sb_num; // the SB frame numbers needed for sync process before path loss calibration
    short               power;               // the power level expected to measure from test set
    Rf_DSSAFC_T         AfcDSS;
    char                step_cnt;
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_CNT - 2]; // because sync process will need 2 steps
} Rf_DTS_REQ_T;

typedef struct
{
    FrequencyBand        band;
    ARFCN                arfcn;
    char                 timeslot_per_frame;
    char                 apc_dac_pcl_sel;                // 1: apc_dac, 0: apc_pcl
    short                apc_dac_pcl_value[4];
    //unsigned char      pa_vbias_val;
    unsigned char        pa_vbias_val[4];
    unsigned char        is_low_pcl[4];

    CodingScheme         cs[4];
    int                  repeat_cnt;
    short                afc_dac_value;
    char                 tsc;
    APCTxPattern         pattern;
    unsigned short       pattern_data;
} Rf_USSAPC_T;

typedef struct
{
//   bool                pa_vbias_cal;
    char                step_cnt;
    short               high_apc_dcoffset[FrequencyBandCount];
    //int                 lowest_power[FrequencyBandCount];  // FrequencyBandCount
    Rf_USSAPC_T         ApcUSS[MAX_STEP_CNT];
} Rf_UTS_REQ_T;

typedef struct
{
    int      power[MAX_STEP_CNT - 2]; // because sync process will need 2 steps
    short    valid_sample[MAX_STEP_CNT - 2];
    bool     ok;
} Rf_DSSPL_RESULT_T;

typedef struct
{
    int      freq_offset[33];    // only valid when 33 stage calibration is ON
    int      deviation[33];      // only valid when 33 stage calibration is ON
    short    fcb_ok_number[33];  // only valid when 33 stage calibration is ON
    //char       capid;              // only valid when capid calibration is ON
    int      capid;              // only valid when capid calibration is ON
    short    init_dac_value;     // only valid when 33 stage calibration is OFF
    int      slope;              // only valid when 33 stage calibration is OFF
    bool     ok;
} Rf_DSSAFC_RESULT_T;



#define FHC_PRE_CAPID_SEARCH_NUM   9
#define FHC_MAX_CAPID_SEARCH_NUM   (7 + FHC_PRE_CAPID_SEARCH_NUM)
typedef struct
{
    int               path_loss_cnt;
    int               freq_offset;
    int               capid_freq_offset_min;
    int               capid_freq_offset[FHC_MAX_CAPID_SEARCH_NUM];       // 20 is the possible max value for FHC_MAX_CAPID_SEARCH_NUM in target side
    int               capid_search_order[FHC_MAX_CAPID_SEARCH_NUM];  // 20 is the possible max value for FHC_MAX_CAPID_SEARCH_NUM in target side
    int               capid;
    int               capid_high;
    int               capid_low;
    int               capid_best;
    short             afc_dac;
    short             arfcn;
    short             capid_cnt;
    short             repeat_index;
    char              state;
    char              capid_index;
    char              capid_okay_cnt;
    char              afc_dac_index;
    char              sb_okay_cnt;
    unsigned char     sb_fail_cnt;
    unsigned char     fb_fail_cnt;
    bool              pl_started;
    bool              pre_capid_cal_ok[FHC_PRE_CAPID_SEARCH_NUM];

} Rf_FHC_DTSM_INFO_T;

typedef enum
{
    DTS_RESULT_READY = 0,       // DTS results is ready to get back
    DTS_RESULT_NOT_READY,       // DTS result is still in progress and not ready to get back
    DTS_RESULT_NOT_REQUESTED    // Haven't called the META_Rf_StartFdtDL() in advance.
} RF_DTS_GET_RESULT_STATUS;
typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_T      PLResult;
    Rf_DSSAFC_RESULT_T     AfcResult;
    Rf_FHC_DTSM_INFO_T     DtsmInfo;
} Rf_DTS_CNF_T;

META_RESULT  __stdcall META_Rf_GetFdtDL(unsigned int ms_timeout, Rf_DTS_CNF_T* fdt_dl_get_result_cnf);
META_RESULT  __stdcall META_Rf_GetFdtDL_r(const int meta_handle, unsigned int ms_timeout, Rf_DTS_CNF_T* fdt_dl_get_result_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult(unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req);

typedef struct
{
    bool                afc_cal;
    bool                pl_cal;       // Control whether Path loss calibration is needed or not
    char                sync_sb_num; // the SB frame numbers needed for sync process before path loss calibration
    short               power;               // the power level expected to measure from test set
    Rf_DSSAFC_T         AfcDSS;
    char                step_cnt;
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_CNT - 2]; // because sync process will need 2 steps
    short               lpm_sb_num;
} RF_DTS_REQ_EX_T;
typedef struct
{
    int           cload_freq_offset;
    unsigned char ok;
    unsigned char is_perform_cal;
} RF_DSSLPM_RESULT_T;
typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_T      PLResult;
    Rf_DSSAFC_RESULT_T     AfcResult;
    Rf_FHC_DTSM_INFO_T     DtsmInfo;
    RF_DSSLPM_RESULT_T     LpmResult;
} RF_DTS_CNF_EX_T;

META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Ex(unsigned int ms_timeout, const RF_DTS_REQ_EX_T* fdt_dl_req);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Ex_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_EX_T* fdt_dl_req);
META_RESULT  __stdcall META_Rf_GetFdtDL_Ex(unsigned int ms_timeout, RF_DTS_CNF_EX_T* result);
META_RESULT  __stdcall META_Rf_GetFdtDL_Ex_r(const int meta_handle, unsigned int ms_timeout, RF_DTS_CNF_EX_T* result);

//-----------------------------------------------------//
//  FHC DTS & UTS gain mode and band combine           //
//-----------------------------------------------------//
/**
 * Description:
 *  Extenstion DTS interface for gain mode combine
 **/
#define MAX_STEP_EX_CNT   100
typedef struct
{
    bool                afc_cal;
    bool                pl_cal;       // Control whether Path loss calibration is needed or not
    char                sync_sb_num; // the SB frame numbers needed for sync process before path loss calibration
    short               power;               // the power level expected to measure from test set
    Rf_DSSAFC_T         AfcDSS;
    char                step_cnt;
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_EX_CNT - 2]; // because sync process will need 2 steps
} Rf_DTS_REQ_BIG_T;

typedef struct
{
    int      power[MAX_STEP_EX_CNT - 2]; // because sync process will need 2 steps
    short    valid_sample[MAX_STEP_EX_CNT - 2];
    bool     ok;
} Rf_DSSPL_RESULT_BIG_T;

typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_BIG_T        PLResult;
    Rf_DSSAFC_RESULT_T           AfcResult;
    Rf_FHC_DTSM_INFO_T           DtsmInfo;
} Rf_DTS_CNF_BIG_T;

typedef struct
{
    bool                afc_cal;
    bool                pl_cal;       // Control whether Path loss calibration is needed or not
    char                sync_sb_num; // the SB frame numbers needed for sync process before path loss calibration
    short               power;               // the power level expected to measure from test set
    Rf_DSSAFC_T         AfcDSS;
    char                step_cnt;
    Rf_DSSPL_T          PathLossDSS[MAX_STEP_EX_CNT - 2]; // because sync process will need 2 steps
    short               lpm_sb_num;
} RF_DTS_REQ_EX_BIG_T;

typedef struct
{
    RF_DTS_GET_RESULT_STATUS     status;
    Rf_DSSPL_RESULT_BIG_T        PLResult;
    Rf_DSSAFC_RESULT_T           AfcResult;
    Rf_FHC_DTSM_INFO_T           DtsmInfo;
    RF_DSSLPM_RESULT_T           LpmResult;
} RF_DTS_CNF_EX_BIG_T;

/**
 * Description:
 *  Extenstion UTS interface for middel chanenl tx pcl calibration band combine
 **/
typedef struct
{
//   bool                pa_vbias_cal;
    char                step_cnt;
    short               high_apc_dcoffset[FrequencyBandCount];
    //int                 lowest_power[FrequencyBandCount];  // FrequencyBandCount
    Rf_USSAPC_T         ApcUSS[MAX_STEP_EX_CNT];
} Rf_UTS_REQ_BIG_T;

/**
 * Extension interface for the target *not* supported LPM
 **/
META_RESULT  __stdcall META_Rf_GetFdtDL_Big(unsigned int ms_timeout, Rf_DTS_CNF_BIG_T* fdt_dl_get_result_cnf);
META_RESULT  __stdcall META_Rf_GetFdtDL_Big_r(const int meta_handle, unsigned int ms_timeout, Rf_DTS_CNF_BIG_T* fdt_dl_get_result_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDL_Big(unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req,  Rf_DTS_CNF_BIG_T* fdt_dl_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDL_Big_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req,  Rf_DTS_CNF_BIG_T* fdt_dl_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big(unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_BIG_T*  fdt_dl_req);

/**
 * Extension interface for the target *supported* LPM
 **/
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big_Ex(unsigned int ms_timeout, const RF_DTS_REQ_EX_BIG_T* fdt_dl_req);
META_RESULT  __stdcall META_Rf_StartFdtDLNotWaitResult_Big_Ex_r(const int meta_handle, unsigned int ms_timeout, const RF_DTS_REQ_EX_BIG_T* fdt_dl_req);
META_RESULT  __stdcall META_Rf_GetFdtDL_Big_Ex(unsigned int ms_timeout, RF_DTS_CNF_EX_BIG_T* result);
META_RESULT  __stdcall META_Rf_GetFdtDL_Big_Ex_r(const int meta_handle, unsigned int ms_timeout, RF_DTS_CNF_EX_BIG_T* result);

/**
 * Extension interface for the TX quad band combine
 **/
META_RESULT  __stdcall META_Rf_StartFdtUL_Big(unsigned int ms_timeout, const Rf_UTS_REQ_BIG_T*  fdt_ul_req);
META_RESULT  __stdcall META_Rf_StartFdtUL_Big_r(const int meta_handle, unsigned int ms_timeout, const Rf_UTS_REQ_BIG_T*  fdt_ul_req);

//-----------------------------------------------------//
//  TX Ramping Table                                   //
//-----------------------------------------------------//
#define PROFILE_NUM             16
#define ARFCN_SECTION_NUM       12
#define ARFCN_SECTION_NUM_Ex       64
typedef  struct
{
    unsigned char   point[2][16];    // ramp up/down profile

} sRAMPAREADATA;

typedef  struct
{
    short            max_arfcn;      // sub-band boundary of this PCL weighting area
    unsigned short   mid_level;      // PCLboundary level to apply high/low weighting
    unsigned short   hi_weight;      // scale factor of PCLs higher than mid_level
    unsigned short   low_weight;     // scale factor of PCLs lower than mid_level

} sARFCN_SECTION;

typedef  struct
{
    int              lowest_power;                       // The lower apc power of the indicated band
    unsigned short   power[16];                          // The mapping of power level to apc dac value
    sRAMPAREADATA    ramp[ PROFILE_NUM ];                // ramp profile
    sARFCN_SECTION   arfcn_weight[ ARFCN_SECTION_NUM ];  // profile of weighting power level by PCL and sub-band
    unsigned short   battery_compensate[3][3];           // [volt][temp]
    short            tx_afc_offset;
} sRAMPDATA;

typedef struct
{
    int              lowest_power;                       // The lower apc power of the indicated band
    unsigned short   power[16];                          // The mapping of power level to apc dac value
    sRAMPAREADATA    ramp[ PROFILE_NUM ];                // ramp profile
    sARFCN_SECTION   arfcn_weight[ ARFCN_SECTION_NUM_Ex ];   // profile of weighting power level by PCL and sub-band
    unsigned short   battery_compensate[3][3];           // [volt][temp]
    short            tx_afc_offset;
} sRAMPDATA_Ex;

typedef  struct
{
    int              lowest_power;                       // The lower apc power of the indicated band
    unsigned short   power[16];                          // The mapping of power level to apc dac value
    sRAMPAREADATA    ramp[ PROFILE_NUM ];                // ramp profile
    sARFCN_SECTION   arfcn_weight[ ARFCN_SECTION_NUM ];  // profile of weighting power level by PCL and sub-band
    unsigned short   battery_compensate[3][3];           // [volt][temp]
    short            tx_afc_offset;
    unsigned char    vbias[16];
} sRAMPDATA_Ex2;

typedef struct
{
    sRAMPDATA          rampData;                         // apc ramp profile of all bands
} l1cal_rampTable_T;

// useless: Ex and Ex2
typedef struct
{
    sRAMPDATA_Ex          rampData;                          // apc ramp profile of all bands
} l1cal_rampTable_T_Ex;

typedef struct
{
    sRAMPDATA_Ex2          rampData;                         // apc ramp profile of all bands
} l1cal_rampTable_T_Ex2;


//-----------------------------------------------------//
//  TX Inter Ramping Table                             //
//-----------------------------------------------------//

// interRampData
typedef struct
{
    unsigned char   interRampData[16];
} l1cal_interRampData_T;

// EPSK interRampData
typedef struct
{
    unsigned char   EPSK_interRampData[4][16];
} l1cal_EPSK_interRampData_T;

#ifdef __META_DLL_WCDMA__
#define  CAL_UARFCN_SECTION  15
#define  U_ARFCN_SECTION_NUM   15
#define  CAL_TEMP_SECTION     8
#define CAL_PWR_DETECTOR_SECTION 32
typedef  struct
{
    unsigned short  max_uarfcn;
    char   path_loss_H;//loss;
    char   path_loss_M;//gain_diff_HM;
    char   path_loss_L;//gain_diff_HL;
}  U_sAGCGAINOFFSET;
typedef  struct
{
    U_sAGCGAINOFFSET  gain_of_uarfcn[CAL_UARFCN_SECTION];
}  U_sTEMPAGCOFFSET;
typedef  struct
{
    unsigned short dc2dc_dac;
    unsigned short vbias_dac;
    unsigned char vm1;
    unsigned char vm2;
}  U_sPADATA;
typedef  struct
{
    unsigned short  max_uarfcn;
    short           pwr_offset;
    short           pwr_slope;
} U_sARFCN_SECTION;
typedef struct
{
    unsigned short max_uarfcn;
    short          pwr_offset_dB; /* unit: 1/32 dB, range: -8 ~ +7 dB */
    short          pwr_offset_txdac;
} U_sARFCN_SECTION_B; // for MT6268B later
typedef  struct
{
    U_sPADATA          pa_data;
    unsigned short     vga_dac[90];
    U_sARFCN_SECTION   vga_comp_by_subband[CAL_UARFCN_SECTION];
    short              vga_comp_by_temperature[8][2];  //[0]:slope, [1]:offset
} U_sTXPOWERDATA;
typedef  struct
{
    U_sPADATA           pa_data;
    unsigned short      vga_dac[96];   // number: 96/10
    U_sARFCN_SECTION_B  vga_comp_by_subband[ CAL_UARFCN_SECTION ];
    short               vga_comp_by_temperature[8][2];  //[0]:offset in dB (unit: 1/32 dB), [1]:offset in txdac
} U_sTXPOWERDATA_B;  // for MT6268B later
typedef  struct
{
    unsigned short start;
    unsigned short end;
} U_sHYSTERESISDATA;
typedef  struct
{
    unsigned char     pwr_dt_thr;
    unsigned char     pwr_dt_section;   // can not be larger than CAL_PWR_DETECTOR_SECTION
    unsigned short    pwr_dt_dac[CAL_PWR_DETECTOR_SECTION];
    short             pwr_dt_value[CAL_PWR_DETECTOR_SECTION]; //bit0~4 is used for fractions
    U_sARFCN_SECTION  pwr_dt_comp_by_subband[CAL_UARFCN_SECTION];   // for compensation, no need calibration, after test, will auto-store
    short             pwr_dt_comp_by_temperature[8][2];  //[0]:slope, [1]:offset
}  U_sPWTDTDATA;
typedef  struct
{
    unsigned char       pwr_dt_thr;
    unsigned char       pwr_dt_section;
    unsigned short      pwr_dt_dac[ CAL_PWR_DETECTOR_SECTION ];
    short               pwr_dt_value[ CAL_PWR_DETECTOR_SECTION ]; //bit0~4 is used for fractions
    U_sARFCN_SECTION_B  pwr_dt_comp_by_subband[ CAL_UARFCN_SECTION ];
    short               pwr_dt_comp_by_temperature[8][2];  //[0]:offset in dB (unit: 1/32 dB), [1]:offset in txdac
}  U_sPWTDTDATA_B;   // for MT6268B later
typedef  struct
{
    unsigned short level_0;
    unsigned short level_1;
} U_sDC2DC;

typedef struct
{
    unsigned char level[8];
} U_sDC2DCOCTLVL;

typedef struct
{
    unsigned char   pa_mode;
    char            prf;
    unsigned char   dc2dc_lvl;
    unsigned char   vm1;
    unsigned char   vm2;
    unsigned short  vbias_dac;
    unsigned short  pa_gain;
} U_sPMULEVHANDLE;

typedef  struct
{
    /* These two control parameters belong to BB TX HW funtionality
     * and all related to PA, though PA phase compensation only has
     * three modes. PD coupler loss by PA modes stored in power_dac[]->vga_dac[9].
     */
    unsigned char     octlev_num_section;
    unsigned int      pa_phase_compensation[3]; // 0: PA high mode, 1: PA mid mode
    U_sPMULEVHANDLE   pmu_level_handle[8];
} U_sPAOCTLVLSETTING;

typedef  struct
{
    U_sDC2DC          pa_dc2dc;       // 2009,Nov add, need to check DB to compose/decompose it automatically
    U_sTXPOWERDATA    power_dac[3];   //0:PA high mode, 1:PA mid mode, 2:PA low mode (use 0&1 if only 2 mode)
    U_sHYSTERESISDATA tx_hysteresis[2];
    U_sPWTDTDATA      pwr_dt_data;
} U_sRAMPDATA;
typedef  struct
{
    U_sDC2DC              pa_dc2dc;       //need to check DB to compose/decompose it automatically
    U_sTXPOWERDATA_B      power_dac[3];   //0:PA high mode, 1:PA mid mode, 2:PA low mode (use 0&1 if only 2 mode)
    U_sHYSTERESISDATA     tx_hysteresis[2];
    U_sPWTDTDATA_B        pwr_dt_data;
} U_sRAMPDATA_B;   // for MT6268B later
typedef struct
{
    unsigned short tempdacData[8];
} ul1cal_tempdacData_T;
typedef struct
{
    U_sTEMPAGCOFFSET  pathlossData[CAL_TEMP_SECTION];
} ul1cal_pathlossData_T;
typedef struct
{
    U_sRAMPDATA txdacData;
} ul1cal_txdacData_T;
typedef struct
{
    U_sRAMPDATA_B txdacData;
} ul1cal_txdacData_T_B;  // for MT6268B or later
typedef struct
{
    U_sPAOCTLVLSETTING txPaOctLevData;
} ul1cal_txPaOctLevData_T;
typedef struct
{
    unsigned char band;
    ul1cal_txdacData_T_B txdacData;
} ul1cal_txdacData_T_B_ByBand;
META_RESULT  __stdcall META_3Grf_SetTxDacData_B(unsigned int  ms_timeout, const ul1cal_txdacData_T_B_ByBand* req);
META_RESULT  __stdcall META_3Grf_SetTxDacData_B_r(const int meta_handle, unsigned int  ms_timeout, const ul1cal_txdacData_T_B_ByBand* req);

typedef struct
{
    /// band indicator (in local parameter)
    unsigned char band;
    /// PA Oct level data (in peer buffer)
    ul1cal_txPaOctLevData_T txPaOctLevData;
} URfTestCmdSetTxPaOctLevData;
META_RESULT  __stdcall META_3Grf_SetTxPaOctLevData(unsigned int ms_timeout, const URfTestCmdSetTxPaOctLevData* req);
META_RESULT  __stdcall META_3Grf_SetTxPaOctLevData_r(const int meta_handle, unsigned int  ms_timeout, const URfTestCmdSetTxPaOctLevData* req);

typedef struct
{
    /// band indicator (in local parameter)
    unsigned char           band;
    /// pa mode (in local parameter)
    unsigned char           pa_mode;
    /// tx dac data (only the power_dac is composed into peer buffer)
    ul1cal_txdacData_T_B    txdacData;
} URfTestCmdSetTxDacPowerDac;
META_RESULT  __stdcall META_3Grf_SetTxDacPowerDac(unsigned int ms_timeout, const URfTestCmdSetTxDacPowerDac* req);
META_RESULT  __stdcall META_3Grf_SetTxDacPowerDac_r(const int meta_handle, unsigned int  ms_timeout, const URfTestCmdSetTxDacPowerDac* req);

typedef struct
{
    char temper_offset[CAL_TEMP_SECTION];
    U_sAGCGAINOFFSET gain_of_uarfcn[CAL_UARFCN_SECTION];
} U_sAGCOFFSETRXD;
typedef struct
{
    U_sAGCOFFSETRXD pathlossData;
} ul1cal_pathlossRxdData_T;
#endif //#ifdef __META_DLL_WCDMA__


//-----------------------------------------------------//
//  RF Module Special Coef                             //
//-----------------------------------------------------//

//mt6140D
typedef struct
{
    short        pcl_index;
    unsigned char pa_vbias1;
} pa_vbias;

typedef struct
{
    pa_vbias GSM850_pa_vbias[8];
    pa_vbias GSM900_pa_vbias[8];
    pa_vbias DCS1800_pa_vbias[8];
    pa_vbias PCS1900_pa_vbias[8];
    //pa_vbias low_band_pa_vbias[8];
    //pa_vbias high_band_pa_vbias[8];
} mt6140tx_pa_vbias;

typedef struct
{
    mt6140tx_pa_vbias data;
} mt6140tx;
// Skyworks
typedef struct
{
    unsigned int        icorrection;
    unsigned int        qcorrection;
} RF_SKY74045_IP2_Coef;

typedef struct
{
    RF_SKY74045_IP2_Coef    coef[5/*band*/];
} RF_SKY74045_RX_Coef;

typedef struct
{
    RF_SKY74045_RX_Coef     rx;
} RF_SKY74045_Coef_T;

typedef struct
{
    unsigned int            ipol;
    unsigned int            qpol;
} RF_SKY74117_IP2_Pol;

typedef struct
{
    RF_SKY74045_IP2_Coef    coef[5/*band*/];
    RF_SKY74117_IP2_Pol     pol[5/*band*/];
} RF_SKY74117_RX_Coef;

typedef struct
{
    RF_SKY74117_RX_Coef     rx;
} RF_SKY74117_Coef_T;

// MT6139B
typedef struct
{
    unsigned int        acode;
    unsigned int        amcode;
} RF_MT6139B_IP2_Coef;

typedef struct
{
    RF_MT6139B_IP2_Coef     coef[5/*band*/];
    unsigned int            rxamcalmode;
} RF_MT6139B_RX_Coef;

typedef struct
{
    RF_MT6139B_RX_Coef      rx;
} RF_MT6139B_Coef_T;

// Bright5P
typedef struct
{
    unsigned int        word6_4_0;
    unsigned int        word6_5_0;
    unsigned int        word6_6_0;
    unsigned int        word6_7_0;
    unsigned int        bvmode;
    unsigned int        c3mode;
    unsigned int        wordC3;
} RF_BRIGHT5P_TX_Coef;

typedef struct
{
    RF_BRIGHT5P_TX_Coef     tx;
} RF_BRIGHT5P_Coef_T;


typedef struct
{
    unsigned char REFDET_SLOPE_SKEW ;
    unsigned char AM_FB_DAC;
} ad6546txcoef;

typedef struct
{
    char MID_GAMA_THRESHOLD;
    char LOW_GAMA_THRESHOLD;
    char MID_DELTA_SLOPE_SKEW;
    char LOW_DELTA_SLOPE_SKEW;
    char MID_DELTA_APC_CAP;
    char LOW_DELTA_APC_CAP;
} ad6546tx_reg8_highband_delta;

typedef struct
{
    unsigned long Address           : 7;
    unsigned long POLAR_APC_CAP     : 5;
    unsigned long VGA_SLOPE         : 4;
    unsigned long REFDET_SLOPE_SKEW : 4;
    unsigned long AM_FB_DAC         : 4;
    unsigned long reserved          : 8;
} AM_LOOP;
// 20090920 YH: add for support reg8 setting
typedef union  // for AD6546 REG8
{
    AM_LOOP AMLoop;
    unsigned long RegData;
} ad6546tx_reg8;

typedef  struct
{
    ad6546txcoef   CalData[4];
    ad6546tx_reg8  Reg8_default[4];
} ad6546tx;

typedef struct
{
    //int rf_band;
    short afc_offset[FrequencyBandCount];

} RF_SET_AFC_DAC_OFFSET_REQ_T;

typedef struct
{
    short afc_offset[FrequencyBandCount];

} RF_GET_AFC_DAC_OFFSET_CNF_T;


//-----------------------------------------------------//
//  RF Testing: callback function definition           //
//-----------------------------------------------------//
typedef void (__stdcall* META_RF_PM_CNF)(const RfPm_Cnf* cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_AFC_CNF)(const RfAfc_Cnf* cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_NB_TX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_CONT_RX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_CONT_TX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SETBBTX_CFG_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SELBAND_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_STOP_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_MULTISLOT_TX_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SET_RAMPAPCLEVEL_CNF)(const unsigned char cnf, const short token, void* usrData);
typedef void (__stdcall* META_RF_SET_AFCDACVALUE_CNF)(const unsigned char cnf, const short token, void* usrData);

//-----------------------------------------------------//
//  RF Testing: exported function definition           //
//-----------------------------------------------------//
META_RESULT  __stdcall META_Rf_PM(const RfPm_Req* req, const META_RF_PM_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_PM_r(const int meta_handle, const RfPm_Req* req, const META_RF_PM_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_PmEx(unsigned int ms_timeout, const RfPm_Req* req, RfPm_Cnf* cnf);
META_RESULT  __stdcall META_Rf_PmEx_r(const int meta_handle, unsigned int ms_timeout, const RfPm_Req* req, RfPm_Cnf* cnf);
META_RESULT  __stdcall META_Rf_IfPm(unsigned int ms_timeout, const RfIfPm_Req* req, RfPm_Cnf* cnf);
META_RESULT  __stdcall META_Rf_IfPm_r(const int meta_handle, unsigned int ms_timeout, const RfIfPm_Req* req, RfPm_Cnf* cnf);

META_RESULT  __stdcall META_Rf_AFC(const RfAfc_Req* req, const META_RF_AFC_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_AFC_r(const int meta_handle, const RfAfc_Req* req, const META_RF_AFC_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_NB_TX(const RfNbtx_Req* req, const META_RF_NB_TX_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_NB_TX_r(const int meta_handle, const RfNbtx_Req* req, const META_RF_NB_TX_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_RX(const RfCnRx_Req* req, const META_RF_CONT_RX_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_RX_r(const int meta_handle, const RfCnRx_Req* req, const META_RF_CONT_RX_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_TX(const RfCnTx_Req* req, const META_RF_CONT_TX_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_r(const int meta_handle, const RfCnTx_Req* req, const META_RF_CONT_TX_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SetBBTXCfg(const RfSetBBTXCfg_Req* req, const META_RF_SETBBTX_CFG_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SetBBTXCfg_r(const int meta_handle, const RfSetBBTXCfg_Req* req, const META_RF_SETBBTX_CFG_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900(const unsigned char selectPCS1900, const META_RF_SELBAND_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_r(const int meta_handle, const unsigned char selectPCS1900, const META_RF_SELBAND_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_Stop(const META_RF_STOP_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_Stop_r(const int meta_handle, const META_RF_STOP_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_MultiSlot_TX(const RfMultiSlotTX_Req* req, const META_RF_MULTISLOT_TX_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_r(const int meta_handle, const RfMultiSlotTX_Req* req, const META_RF_MULTISLOT_TX_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SetAfcDacValue(const RfSetAfcDacValue_Req* req, const META_RF_SET_AFCDACVALUE_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SetAfcDacValue_r(const int meta_handle, const RfSetAfcDacValue_Req* req, const META_RF_SET_AFCDACVALUE_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SetBBTxCfg2(unsigned int ms_timeout, const RfBBTXCfg2*  tx_cfg_req, RfBBTXCfg2*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg2_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg2*  tx_cfg_req, RfBBTXCfg2*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg2(unsigned int ms_timeout, RfBBTXCfg2*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg2_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg2*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetCrystalCapId(unsigned int ms_timeout, const RfSetCrystalCfg_Req*  req);
META_RESULT  __stdcall META_Rf_SetCrystalCapId_r(const int meta_handle, unsigned int ms_timeout, const RfSetCrystalCfg_Req*  req);
META_RESULT  __stdcall META_Rf_BBTXAutoCal(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_BBTXAutoCal_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_QueryMSCapability(unsigned int ms_timeout, RfMsCapability_S*  p_type);
META_RESULT  __stdcall META_Rf_QueryMSCapability_r(const int meta_handle, unsigned int ms_timeout, RfMsCapability_S*  p_type);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx(unsigned int ms_timeout, RfMsCapabilityEx_S*  p_ms_cap);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx_r(const int meta_handle, unsigned int ms_timeout, RfMsCapabilityEx_S*  p_ms_cap);
META_RESULT  __stdcall META_Rf_SetAfcSinWaveDetection(unsigned int ms_timeout, AFC_SINWAVE_DETECTION_E  bIsAfcSinWaveOn);
META_RESULT  __stdcall META_Rf_SetAfcSinWaveDetection_r(const int meta_handle, unsigned int ms_timeout, AFC_SINWAVE_DETECTION_E  bIsAfcSinWaveOn);
META_RESULT  __stdcall META_Rf_QueryIfTwoApcDCOffsetSupport(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_QueryIfTwoApcDCOffsetSupport_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex(unsigned int ms_timeout, const Rf_MultiSlotTXEx_Req* req);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const Rf_MultiSlotTXEx_Req* req);
META_RESULT  __stdcall META_Rf_GetRFID(unsigned int ms_timeout, RFMod_ID* cnf);
META_RESULT  __stdcall META_Rf_GetRFID_r(const int meta_handle, unsigned int ms_timeout, RFMod_ID* cnf);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex(unsigned int ms_timeout, const RfCnTxEx_Req* req);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfCnTxEx_Req* req);
META_RESULT  __stdcall META_Rf_SetBBTxCfg3(unsigned int ms_timeout, const RfBBTXCfg3*  tx_cfg_req, RfBBTXCfg3*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg3_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg3*  tx_cfg_req, RfBBTXCfg3*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg3(unsigned int ms_timeout, RfBBTXCfg3*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg3_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg3*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex2(unsigned int ms_timeout, const RfCnTxEx2_Req* req);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex2_r(const int meta_handle, unsigned int ms_timeout, const RfCnTxEx2_Req* req);
META_RESULT  __stdcall META_Rf_GetAfcDacValueAtRTXOffsetCal(unsigned int ms_timeout, RfGetAfcDacValueAtRTXOffsetCal* cnf);
META_RESULT  __stdcall META_Rf_GetAfcDacValueAtRTXOffsetCal_r(const int meta_handle, unsigned int ms_timeout, RfGetAfcDacValueAtRTXOffsetCal* cnf);

META_RESULT  __stdcall META_Rf_SetBBTxCfg4(unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg4_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg4(unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg4_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);


META_RESULT  __stdcall META_Rf_SetBBTxCfg5(unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg5_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg5(unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg5_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);


META_RESULT  __stdcall META_Rf_SetBBTxCfg6(unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_SetBBTxCfg6_r(const int meta_handle, unsigned int ms_timeout, const RfBBTXCfg4*  tx_cfg_req, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg6(unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);
META_RESULT  __stdcall META_Rf_GetBBTxCfg6_r(const int meta_handle, unsigned int ms_timeout, RfBBTXCfg4*  tx_cfg_cnf);



//-----------------------------------------------------//
//  RunTime Setting Functions Without Update NVRAM     //
//-----------------------------------------------------//
META_RESULT  __stdcall META_Rf_SetRampTable(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_SetRampApcLevel(const RfSetRampApcLevel_Req* req, const META_RF_SET_RAMPAPCLEVEL_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_SetRampApcLevel_r(const int meta_handle, const RfSetRampApcLevel_Req* req, const META_RF_SET_RAMPAPCLEVEL_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex2(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);
META_RESULT  __stdcall META_Rf_EPSK_SetRampTable_Ex2_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);

/**
 * Function: META_Rf_TXPC_CL_ResetPdData
 *
 * Description: reset pd value and let L1D knowing that currently
 *              is calibrating normal mode, TXADC, or subband.
 *
 * @Parameters:
 *      meta_handle  : meta handler
 *      ms_timeout   : time out (ms)
 *
 * typedef struct
 * {
 *      eFreqBand    : band indicator
 *      cTxAdc_State : 0: normal mode, 1: cal TXADC, 2:cal subband
 *      is_EPSK      : 1: EPSK, 0: GMSK
 * } MEAT_RF_RESET_PD_DATA_T
 *
 **/
typedef struct
{
    FrequencyBand eFreqBand;
    char          cTxAdc_State;
    char          is_EPSK;
} MEAT_RF_RESET_PD_DATA_T;

META_RESULT  __stdcall META_Rf_TXPC_CL_ResetPdData(unsigned int ms_timeout, const MEAT_RF_RESET_PD_DATA_T* pTxPc_ResetPD);
META_RESULT  __stdcall META_Rf_TXPC_CL_ResetPdData_r(const int meta_handle, unsigned int ms_timeout, const MEAT_RF_RESET_PD_DATA_T* pTxPc_ResetPD);

//===================================

/**V \brief  the number of pa control levels */
#define  PA_OCT_16_LEVEL 16
/* R8 epsk new feature */
typedef struct
{
    short          pcl_index;
    unsigned char  pa_vbias;
    unsigned short pa_gain;
} epsk_pa_vbias;

typedef struct
{
    epsk_pa_vbias GSM850_8pa_vbias[PA_OCT_16_LEVEL];
    epsk_pa_vbias GSM900_8pa_vbias[PA_OCT_16_LEVEL];
    epsk_pa_vbias DCS1800_8pa_vbias[PA_OCT_16_LEVEL];
    epsk_pa_vbias PCS1900_8pa_vbias[PA_OCT_16_LEVEL];
} EPSK_8PA_VBIAS;

typedef struct
{
    EPSK_8PA_VBIAS data;
} RF_EPSK_8PA_TX_Coef;

typedef struct
{
    RF_EPSK_8PA_TX_Coef  tx;
} RF_EPSK_8PA_SPECIAL_Coef_T;

typedef struct
{
    /// band indicator (in local parameter)
    unsigned char band;
    /// PA Oct level data (in peer buffer)
    unsigned short pa_gain[PA_OCT_16_LEVEL];
} RfEpskSetTxPaOctLevData;
META_RESULT  __stdcall META_Rf_EPSK_SetTxPaOctLevData_Ex(unsigned int ms_timeout, const RfEpskSetTxPaOctLevData*  p_pa_oct_data);
META_RESULT  __stdcall META_Rf_EPSK_SetTxPaOctLevData_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfEpskSetTxPaOctLevData*  p_pa_oct_data);

META_RESULT  __stdcall META_NVRAM_Compose_EPSKtxPaOctLevData(const RF_EPSK_8PA_SPECIAL_Coef_T* epsk_specialCoef, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_DeCompose_EPSKtxPaOctLevData(RF_EPSK_8PA_SPECIAL_Coef_T* epsk_specialCoef, const char* buf, const int buf_len);
//===================================

/**
 * Function: META_Rf_GainRf_TX
 *
 * Description: start EDGE TX signal indicated by gain index
 *
 * @Parameters:
 *      meta_handle  : meta handler
 *      ms_timeout   : time out (ms)
 *      req          : Rf_GainRfTx_Req
 **/
typedef struct
{
    ARFCN           arfcn;          // absolute radio frequency channel number
    BSIC            bsic;            // training sequence
    CodingScheme    cs;     // coding scheme for each time slot, MCS1~9 is only valid for EPSK function
    TimingAdvance   ta;       // time advance
    int             frames;        // the number of frames should transmit
    short           dacValue;    // AFC DAC value
    APCTxPattern    pattern;            // Tx pattern is only valid for EPSK function
    unsigned short  pattern_data;   // if NB_TX_PATTERN_WITHOUT_TSC==pattern, user can input any 16bits value as pattern.
    unsigned short  pa_gain;           // pa gain from ini file
    unsigned short  pa_vbias;         // pa vbias from ini file
    unsigned char   rf_gain_index; // gain rf index
} Rf_GainRfTx_Req;

META_RESULT  __stdcall META_Rf_GainRf_TX(unsigned int ms_timeout, const Rf_GainRfTx_Req* req);
META_RESULT  __stdcall META_Rf_GainRf_TX_r(const int meta_handle, unsigned int ms_timeout, const Rf_GainRfTx_Req* req);
/**
 * Function: META_Rf_QueryNumOfGainRf
 *
 * Description: RF gain number query API
 *
 * @Parameters:
 *      meta_handle  : meta handler
 *      ms_timeout   : time out (ms)
 *      ucNumOfGainRf: the space to store result
 **/
META_RESULT  __stdcall META_Rf_QueryNumOfGainRf(unsigned int ms_timeout, unsigned char* ucNumOfGainRf);
META_RESULT  __stdcall META_Rf_QueryNumOfGainRf_r(const int meta_handle, unsigned int ms_timeout, unsigned char* ucNumOfGainRf);
/**
 * Function: META_Rf_QueryBBPowerList
 *
 * Description: Gain power array query function
 *
 * @Parameters:
 *      meta_handle  : meta handler
 *      ms_timeout   : time out (ms)
 *      sBBPowerArrary: the space to store the gain power array
 *      ucArraySize   : the size of the storing space
 **/
#define MAX_GAIN_RF_NUM 64
META_RESULT  __stdcall META_Rf_QueryBBPowerList(unsigned int ms_timeout, short* sBBPowerArrary, unsigned char ucArraySize);
META_RESULT  __stdcall META_Rf_QueryBBPowerList_r(const int meta_handle, unsigned int ms_timeout, short* sBBPowerArrary, unsigned char ucArraySize);


META_RESULT  __stdcall META_Rf_EPSK_SetRampApcLevel(unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);
META_RESULT  __stdcall META_Rf_EPSK_SetRampApcLevel_r(const int meta_handle, unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);
META_RESULT  __stdcall META_Rf_SetRFImmediateBSI(unsigned int ms_timeout, const unsigned int bsi_data);
META_RESULT  __stdcall META_Rf_SetRFImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, const unsigned int bsi_data);
META_RESULT  __stdcall META_Rf_GetRFImmediateBSI(unsigned int ms_timeout, unsigned int bsi_addr, unsigned int* p_bsi_data);
META_RESULT  __stdcall META_Rf_GetRFImmediateBSI_r(const int meta_handle, unsigned int ms_timeout, unsigned int bsi_addr, unsigned int* p_bsi_data);

META_RESULT  __stdcall META_Rf_SetRampTable_Ex(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_Ex_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex*  ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_Ex2(unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);
META_RESULT  __stdcall META_Rf_SetRampTable_Ex2_r(const int meta_handle, unsigned int ms_timeout, FrequencyBand  band, const l1cal_rampTable_T_Ex2*  ramp);
// Skyworks
META_RESULT  __stdcall META_Rf_SKY74045_SetSpecialCoef(unsigned int ms_timeout, const RF_SKY74045_Coef_T* rf_mod_coef);
META_RESULT  __stdcall META_Rf_SKY74045_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_SKY74045_Coef_T* rf_mod_coef);
META_RESULT  __stdcall META_Rf_SKY74117_SetSpecialCoef(unsigned int ms_timeout, const RF_SKY74117_Coef_T* rf_mod_coef);
META_RESULT  __stdcall META_Rf_SKY74117_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_SKY74117_Coef_T* rf_mod_coef);
// MT6139B
META_RESULT  __stdcall META_Rf_MT6139B_SetSpecialCoef(unsigned int ms_timeout, const RF_MT6139B_Coef_T* rf_mod_coef);
META_RESULT  __stdcall META_Rf_MT6139B_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_MT6139B_Coef_T* rf_mod_coef);
// Renesas Bright5P
META_RESULT  __stdcall META_Rf_BRIGHT5P_SetSpecialCoef(unsigned int ms_timeout, const RF_BRIGHT5P_Coef_T* rf_mod_coef);
META_RESULT  __stdcall META_Rf_BRIGHT5P_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const RF_BRIGHT5P_Coef_T* rf_mod_coef);

//---------------------------------------------------------------------------------------------------
META_RESULT  __stdcall META_Rf_32kCalibration(unsigned int ms_timeout, int* p_result);
META_RESULT  __stdcall META_Rf_32kCalibration_r(const int meta_handle, unsigned int ms_timeout, int* p_result);

META_RESULT  __stdcall META_Rf_AD6546_SetSpecialCoef(unsigned int ms_timeout, const ad6546tx* rf_mod_coef, const char* buf, const int buf_len);
META_RESULT  __stdcall META_Rf_AD6546_SetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, const ad6546tx* rf_mod_coef, const char* buf, const int buf_len);

META_RESULT  __stdcall META_Rf_StartFdtDL(unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req,  Rf_DTS_CNF_T* fdt_dl_cnf);
META_RESULT  __stdcall META_Rf_StartFdtDL_r(const int meta_handle, unsigned int ms_timeout, const Rf_DTS_REQ_T*  fdt_dl_req,  Rf_DTS_CNF_T* fdt_dl_cnf);

META_RESULT  __stdcall META_Rf_StartFdtUL(unsigned int ms_timeout, const Rf_UTS_REQ_T*  fdt_ul_req);
META_RESULT  __stdcall META_Rf_StartFdtUL_r(const int meta_handle, unsigned int ms_timeout, const Rf_UTS_REQ_T*  fdt_ul_req);


META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx2(unsigned int ms_timeout, RfMsCapabilityEx2_S*  p_ms_cap);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx2_r(const int meta_handle, unsigned int ms_timeout, RfMsCapabilityEx2_S*  p_ms_cap);

typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} RfMsCapabilityEx3_REQ_S;
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx3(unsigned int ms_timeout, const RfMsCapabilityEx3_REQ_S* req, RfMsCapabilityEx3_S* ms_cap);
META_RESULT  __stdcall META_Rf_QueryMSCapabilityEx3_r(const int meta_handle, unsigned int ms_timeout, const RfMsCapabilityEx3_REQ_S* req, RfMsCapabilityEx3_S* ms_cap);



META_RESULT  __stdcall META_Rf_GetAFCDacTRxOffset(unsigned int ms_timeout, //const int rf_band_req,
        RF_GET_AFC_DAC_OFFSET_CNF_T* cnf);
//short *p_afc_offset_cnf);

META_RESULT  __stdcall META_Rf_GetAFCDacTRxOffset_r(const int meta_handle,
        unsigned int ms_timeout,
        //const int rf_band_req,
        RF_GET_AFC_DAC_OFFSET_CNF_T* cnf);
//short *p_afc_offset_cnf);




META_RESULT  __stdcall META_Rf_SetAFCDacTRxOffset(unsigned int ms_timeout, const RF_SET_AFC_DAC_OFFSET_REQ_T* req);
META_RESULT  __stdcall META_Rf_SetAFCDacTRxOffset_r(const int meta_handle,
        unsigned int ms_timeout,
        const RF_SET_AFC_DAC_OFFSET_REQ_T* req);


//--------------------------------------------------------------------------//
//  BER NSFT (Bit Error Rate in Non-signaling Final Test) : not release     //
//--------------------------------------------------------------------------//
typedef struct
{
    FrequencyBand   band;
    ARFCN           BCH_ARFCN;
    ARFCN           TCH_ARFCN;
    Gain            BCH_gain;
    Gain            TCH_gain;
    TSC             tsc;
    TimeSlot        TCH_slot;
    Power           tx_power_level;
    bool            is_EPSK_tx;
    CodingScheme    epsk_cs;
} Rf_NSFT_REQ_T;

typedef struct
{
    Power tx_power_level;
} Rf_NSFT_TX_POWERE_REQ_T;

typedef struct
{
    Power           tx_power_level;
    CodingScheme    epsk_cs;
    TimeSlot        TCH_slot;
} Rf_NSFT_EPSK_MOD_CHANGE_REQ_T;

// Start the BER NSFT process
META_RESULT  __stdcall META_Rf_NSFT_Start(unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);
META_RESULT  __stdcall META_Rf_NSFT_Start_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);
// In NSFT process, change the frequency channel
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings(unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);
META_RESULT  __stdcall META_Rf_NSFT_ChangeSettings_r(const int meta_handle, unsigned int ms_timeout, const  Rf_NSFT_REQ_T* req);
// Stop the BER NSFT porcess
META_RESULT  __stdcall META_Rf_NSFT_Stop(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_NSFT_Stop_r(const int meta_handle, unsigned int ms_timeout);
// In NSFT TX performance test, change different tx power.
META_RESULT  __stdcall META_Rf_NSFT_ChangePower(unsigned int ms_timeout, const Rf_NSFT_TX_POWERE_REQ_T* req);
META_RESULT  __stdcall META_Rf_NSFT_ChangePower_r(const int meta_handle, unsigned int ms_timeout, const Rf_NSFT_TX_POWERE_REQ_T* req);
// In NSFT TX performance test, change to EPSK mode and set tx power.
META_RESULT  __stdcall META_Rf_NSFT_ChangeToEPSK(unsigned int ms_timeout, const Rf_NSFT_EPSK_MOD_CHANGE_REQ_T* req);
META_RESULT  __stdcall META_Rf_NSFT_ChangeToEPSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_NSFT_EPSK_MOD_CHANGE_REQ_T* req);

// query OE PATTERN ready (NO OP function, just for query)
META_RESULT  __stdcall META_Rf_OE_Pattern_Ready();
META_RESULT  __stdcall META_Rf_AFC_Type_Query_Ready();


META_RESULT  __stdcall META_Rf_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_PowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_PowerOff_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_QueryPowerState(unsigned int ms_timeout, char* pRfPwrState);
META_RESULT  __stdcall META_Rf_QueryPowerState_r(const int meta_handle, unsigned int ms_timeout,  char* pRfPwrState);

typedef struct
{
    char rollback_2t;
    char rollback_3t;
    char rollback_4t;
    char rollback_5t;
} sTX_POWERROLLBACK;

typedef struct
{
    int band;
    sTX_POWERROLLBACK PowerRollbackTable;
} Rf_TX_ROLLBACK_REQ_T;

typedef struct
{
    sTX_POWERROLLBACK   rollback_data[FrequencyBandCount];
} l1cal_tx_power_rollback_T;

META_RESULT  __stdcall META_Rf_SetTXPowerRollbackGMSK(unsigned int ms_timeout, Rf_TX_ROLLBACK_REQ_T* req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackGMSK_r(const int meta_handle, unsigned int ms_timeout,  Rf_TX_ROLLBACK_REQ_T* req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackEPSK(unsigned int ms_timeout, Rf_TX_ROLLBACK_REQ_T* req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackEPSK_r(const int meta_handle, unsigned int ms_timeout,  Rf_TX_ROLLBACK_REQ_T* req);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableGMSK(unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableGMSK_r(const int meta_handle, unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableEPSK(unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);
META_RESULT  __stdcall META_Rf_SetTXPowerRollbackTableEPSK_r(const int meta_handle, unsigned int ms_timeout, const l1cal_tx_power_rollback_T*  table);

typedef struct
{
    unsigned short data[16];
} sTXPC_ADCDATA;

typedef struct
{
    unsigned short data[8];
} sTXPC_TEMPDATA;

typedef struct
{
    char           is_calibrated;
    sTXPC_ADCDATA  adc[FrequencyBandCount];
    short          temperature;
    sTXPC_TEMPDATA temp[FrequencyBandCount];
} sTXPC_L1CAL;

typedef sTXPC_L1CAL l1cal_txpc_T;

typedef struct
{
    unsigned char  band;
    short pcl;
} Rf_GET_TXPC_PD_REQ_T;


META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLGMSK(unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLGMSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLEPSK(unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueByPCLEPSK_r(const int meta_handle, unsigned int ms_timeout, const Rf_GET_TXPC_PD_REQ_T* req, unsigned short* PDValue);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueGMSK(unsigned int ms_timeout, l1cal_txpc_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueGMSK_r(const int meta_handle, unsigned int ms_timeout, l1cal_txpc_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueEPSK(unsigned int ms_timeout, l1cal_txpc_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCDetectorValueEPSK_r(const int meta_handle, unsigned int ms_timeout, l1cal_txpc_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSK(unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSK_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSK(unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSK_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, l1cal_rampTable_T*  ramp);
typedef struct
{
    short data[11];
} txpc_subband_comp_T;
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSKEx(unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationGMSKEx_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSKEx(unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCSubbandCompensationEPSKEx_r(const int meta_handle, unsigned int ms_timeout, const unsigned char band, txpc_subband_comp_T* table);
META_RESULT  __stdcall META_Rf_GetTXPCTemperature(unsigned int ms_timeout, unsigned short* temperature);
META_RESULT  __stdcall META_Rf_GetTXPCTemperature_r(const int meta_handle, unsigned int ms_timeout, unsigned short* temperature);
typedef struct
{
    short w_re[19];
    short w_im[19];
} RF_AvgW_Coef_T;

META_RESULT  __stdcall META_Rf_GetSpecialCoef(unsigned int ms_timeout, unsigned int rfid, void* coef_struct);
META_RESULT  __stdcall META_Rf_GetSpecialCoef_r(const int meta_handle, unsigned int ms_timeout, unsigned int rfid, void* coef_struct);

META_RESULT  __stdcall META_Rf_NSFT_ConfigSBER(unsigned int ms_timeout, const unsigned int test_frame_count);
META_RESULT  __stdcall META_Rf_NSFT_ConfigSBER_r(const int meta_handle, unsigned int ms_timeout, const unsigned int test_frame_count);
typedef struct
{
    unsigned int m_u4NSFTSBERSum;
    unsigned int m_u4NSFTSBERCurrentCount;
} RF_NSFT_SBERResult_T;

META_RESULT  __stdcall META_Rf_NSFT_GetSBER(unsigned int ms_timeout, RF_NSFT_SBERResult_T* sber_result);
META_RESULT  __stdcall META_Rf_NSFT_GetSBER_r(const int meta_handle, unsigned int ms_timeout, RF_NSFT_SBERResult_T* sber_result);
META_RESULT  __stdcall META_Rf_NSFT_StartRxLevel(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_NSFT_StartRxLevel_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_NSFT_GetRxLevel(unsigned int ms_timeout, unsigned short* rx_level);
META_RESULT  __stdcall META_Rf_NSFT_GetRxLevel_r(const int meta_handle, unsigned int ms_timeout, unsigned short* rx_level);
META_RESULT  __stdcall META_Rf_NSFT_GetRxQual(unsigned int ms_timeout, const unsigned short ber_decile, unsigned char* rx_qual);
META_RESULT  __stdcall META_Rf_NSFT_GetRxQual_r(const int meta_handle, unsigned int ms_timeout, const unsigned short ber_decile, unsigned char* rx_qual);

META_RESULT  __stdcall META_Rf_AFC_Ex(unsigned int ms_timeout, const RfAfc_Req* req, RfAfc_Cnf* cnf);
META_RESULT  __stdcall META_Rf_AFC_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfAfc_Req* req, RfAfc_Cnf* cnf);
META_RESULT  __stdcall META_Rf_NB_TX_Ex(unsigned int ms_timeout, const RfNbtx_Req* req);
META_RESULT  __stdcall META_Rf_NB_TX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfNbtx_Req* req);
META_RESULT  __stdcall META_Rf_CONTINUE_RX_Ex(unsigned int ms_timeout, const RfCnRx_Req* req);
META_RESULT  __stdcall META_Rf_CONTINUE_RX_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfCnRx_Req* req);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex1(unsigned int ms_timeout, const RfCnTx_Req* req);
META_RESULT  __stdcall META_Rf_CONTINUE_TX_Ex1_r(const int meta_handle, unsigned int ms_timeout, const RfCnTx_Req* req);
META_RESULT  __stdcall META_Rf_SetBBTXCfg_Ex(unsigned int ms_timeout, const RfSetBBTXCfg_Req* req);
META_RESULT  __stdcall META_Rf_SetBBTXCfg_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfSetBBTXCfg_Req* req);
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_Ex(unsigned int ms_timeout, unsigned char selectPCS1900);
META_RESULT  __stdcall META_Rf_SelectFrequencyBand1900_Ex_r(const int meta_handle, unsigned int ms_timeout, unsigned char selectPCS1900);
META_RESULT  __stdcall META_Rf_Stop_Ex(unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_Stop_Ex_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex1(unsigned int ms_timeout, const RfMultiSlotTX_Req* req);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex1_r(const int meta_handle, unsigned int ms_timeout, const RfMultiSlotTX_Req* req);
META_RESULT  __stdcall META_Rf_SetAfcDacValue_Ex(unsigned int ms_timeout, const RfSetAfcDacValue_Req* req);
META_RESULT  __stdcall META_Rf_SetAfcDacValue_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfSetAfcDacValue_Req* req);
META_RESULT  __stdcall META_Rf_SetRampApcLevel_Ex(unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);
META_RESULT  __stdcall META_Rf_SetRampApcLevel_Ex_r(const int meta_handle, unsigned int ms_timeout, const RfSetRampApcLevel_Req* req);
META_RESULT  __stdcall META_Rf_SetDcxoPowerMode(unsigned int ms_timeout, unsigned char mode);
META_RESULT  __stdcall META_Rf_SetDcxoPowerMode_r(const int meta_handle, unsigned int ms_timeout, unsigned char mode);

/********************************
 * CO TSX
 ********************************/
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_AuxADCRead(unsigned int ms_timeout, const RfMultiSlotTX_Req* req, unsigned short* piTemp);
META_RESULT  __stdcall META_Rf_MultiSlot_TX_Ex_AuxADCRead_r(const int meta_handle, unsigned int ms_timeout, const RfMultiSlotTX_Req* req, unsigned short* piTemp);

META_RESULT __stdcall META_Rf_GetTemperatureInfo(const unsigned int ms_timeout, META_Rf_TemperatureInfo_T* info);
META_RESULT __stdcall META_Rf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, META_Rf_TemperatureInfo_T* info);

/**
 * Set GSM path to other path
 * 0: first path
 * 1: second path
 * the path will be restored to default path (first path) after RF stop
 */
META_RESULT __stdcall META_Rf_SetDtPathFlag(const unsigned int ms_timeout, unsigned char path_flag);
META_RESULT __stdcall META_Rf_SetDtPathFlag_r(const int meta_handle, const unsigned int ms_timeout, unsigned char path_flag);
const char* __stdcall META_Rf_GetRfChipIdName(unsigned int id);
#if defined(__META_LTE__)
//--------------------------------------------------------------------------//
//  LTE RF                                                                  //
//--------------------------------------------------------------------------//
#define MAX_LTE_BAND (44)
typedef struct
{
    unsigned char band;
#define ERF_TX_TEST_COMMAND_CONFIG_TDD 0
#define ERF_TX_TEST_COMMAND_CONFIG_FDD 1
    unsigned char duplexMode; /* tdd,fdd */
    unsigned char tddConfig;
    unsigned char tddSfConfig;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_6RB 0
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_15RB 1
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_25RB 2
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_50RB 3
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_75RB 4
#define ERF_TX_TEST_COMMAND_CONFIG_UL_BANDWIDTH_100RB 5
    unsigned char ulBandwidth; /* 6,15,25,50,75,100RB */
    unsigned char vrbStart;
    unsigned char vrbLength;
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_QPSK 0
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_16QAM 1
#define ERF_TX_TEST_COMMAND_CONFIG_PUSCH_MSC_64QAM 2
    unsigned char mcsMode;
    short txPower;
    unsigned char networkSelection; /* 0~31 */
    unsigned char txPowerMode;
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
    short bbBackoff;
    unsigned char rfGain;
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_HIGH 0
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_MIDDLE 1
#define ERF_TX_TEST_COMMAND_CONFIG_PA_MODE_LOW 2
    unsigned char paMode;
    unsigned char paVcc;
    unsigned char vm0;
    unsigned char vm1;
} ERfTestCmdPuschTx;

META_RESULT __stdcall META_ERf_TxPusch( const ERfTestCmdPuschTx* req, const unsigned int ms_timeout );
META_RESULT __stdcall META_ERf_TxPusch_r( const int meta_handle, const  ERfTestCmdPuschTx* req, const unsigned int  ms_timeout );

typedef struct
{
    unsigned char band;
    unsigned char duplexMode /* tdd,fdd */;
    unsigned char tddConfig;
    unsigned char tddSfConfig;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
    unsigned char ulBandwidth; /* 6,15,25,50,75,100RB */
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1 0
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1A 1
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_1B 2
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2 3
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2_CPACK 4
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2A 5
#define ERF_TX_TEST_COMMAND_CONFIG_PUCCH_FORMAT_2B 6
    unsigned char format; /* 1,1a,1b,2,2_cpack,2a,2b */
    short txPower;
    unsigned char networkSelection; /* 0~31 */
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
} ERfTestCmdPucchTx;
META_RESULT __stdcall META_ERf_TxPucch( const ERfTestCmdPucchTx* req, const unsigned int ms_timeout );
META_RESULT __stdcall META_ERf_TxPucch_r( const int meta_handle, const  ERfTestCmdPucchTx* req, const unsigned int  ms_timeout );

typedef struct
{
    unsigned char band;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_FDD_TIME_MASK 0
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_TDD_TIME_MASK 1
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_FDD_EVM 2
#define ERF_TX_TEST_COMMAND_CONFIG_PRACH_CONFIG_INDEX_TDD_EVM 3
    unsigned char configIndex; /* fdd time mask,tdd time mask,fdd evm,tdd evm*/
    short txPower;
    unsigned char networkSelection; /* 0~31 */
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
} ERfTestCmdPrachTx;
META_RESULT __stdcall META_ERf_TxPrach( const ERfTestCmdPrachTx* req, const unsigned int ms_timeout );
META_RESULT __stdcall META_ERf_TxPrach_r( const int meta_handle, const  ERfTestCmdPrachTx* req, const unsigned int  ms_timeout );

typedef struct
{
    unsigned char band;
    unsigned char duplexMode /* tdd,fdd */;
    unsigned short ulFrequency;
    unsigned short cellId;
    short afcdac;
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_0 0
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_2 2
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_5 5
#define ERF_TX_TEST_COMMAND_CONFIG_SRS_BANDWIDTH_CONFIG_7 7
    unsigned char tddCsSrsBwCfg;
    short txPower;
    unsigned char networkSelection; /* 0~31 */
    unsigned char disableCloseLoop;
    unsigned char enableAmpr;
} ERfTestCmdSrsTx;
META_RESULT __stdcall META_ERf_TxSrs( const ERfTestCmdSrsTx* req, const unsigned int ms_timeout );
META_RESULT __stdcall META_ERf_TxSrs_r( const int meta_handle, const  ERfTestCmdSrsTx* req, const unsigned int  ms_timeout );

typedef struct
{
#define MAX_ERF_TEST_MIXRX_DLRX_MODE (0)
#define MAX_ERF_TEST_MIXRX_TXRX_MODE (1)
#define MAX_ERF_TEST_MIXRX_PSEUDO_TXRX_MODE (2)
    unsigned char mode;
#define MAX_ERF_TEST_MIXRX_REPORT_COUNT 10
    unsigned char measCnt;
    unsigned char measBandwidth; /* Refer to Tx ulBandwidth - 6,15,25,50,75,100RB */
    short afcdac;
    unsigned short dlFrequency;
    unsigned char band;
    unsigned char duplexMode; /* Refer to Tx duplexMode - tdd,fdd */
    unsigned char tddConfig;
    unsigned char tddSfConfig;
    unsigned char bandwidth; /* Refer to Tx ulBandwidth - 6,15,25,50,75,100RB */
    unsigned char rxPath0Enbl;
    unsigned char rxPath1Enbl;
    unsigned short ulFrequency;
    short txPowerValue;
    unsigned char vrbStart;
    unsigned char vrbLength;
    unsigned char mcsMode; /* Refer to Tx mcsMode */
} ERfTestCmdMixRx;
META_RESULT __stdcall META_ERf_StartMixRx( const unsigned int ms_timeout, ERfTestCmdMixRx* req );
META_RESULT __stdcall META_ERf_StartMixRx_r( const int meta_handle, ERfTestCmdMixRx* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned char measRptCnt; //0 ~ MAX_ERF_TEST_MIXRX_REPORT_COUNT
    short rssiPath0[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rssiPath1[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrpPath0[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrpPath1[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrqPath0[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    short rsrqPath1[MAX_ERF_TEST_MIXRX_REPORT_COUNT];
    unsigned int crcOK_cnt;
    unsigned int crcNG_cnt;
} ERfTestCmdGetMixRxRpt;
META_RESULT __stdcall META_ERf_GetMixRxReport( const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt* resp );
META_RESULT __stdcall META_ERf_GetMixRxReport_r( const int meta_handle, const unsigned int ms_timeout, ERfTestCmdGetMixRxRpt* resp );

META_RESULT __stdcall META_ERf_ResetCounter( const unsigned int ms_timeout );
META_RESULT __stdcall META_ERf_ResetCounter_r( const int meta_handle, const unsigned int  ms_timeout );

META_RESULT __stdcall META_ERf_StopTestMode( const unsigned int ms_timeout );
META_RESULT __stdcall META_ERf_StopTestMode_r( const int meta_handle, const unsigned int  ms_timeout );

typedef struct
{
    //PA Control
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE 8
    unsigned char paControlLevel; /* 2~8 */
    unsigned char calRoomTempIdx;
    short hysteresisStart0;
    short hysteresisEnd0;
    short hysteresisStart1;
    short hysteresisEnd1;
    unsigned char paMode[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    short pRf[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short paGain[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char dc2dcLevel[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short vBiasDac[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm0[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm1[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    //Tx Compensation
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE 8
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE 21
    unsigned short ulFrequency[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short couplerLossHigh;
    short couplerLossMiddle;
    short couplerLossLow;
    short powerDetectorHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
} ERfTestCmdGetSetTpcSetting;

META_RESULT  __stdcall META_ERf_GetTpcSetting( unsigned char band,  const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
META_RESULT  __stdcall META_ERf_GetTpcSetting_r( const int meta_handle, unsigned char band, const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
META_RESULT  __stdcall META_ERf_SetTpcSetting( unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );
META_RESULT  __stdcall META_ERf_SetTpcSetting_r( const int meta_handle, unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );

// WARNNING: backward compatible(BC) function, these will be removed after MP
typedef struct
{
    //PA Control
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE 8
    unsigned char paControlLevel; /* 2~8 */
    short hysteresisStart0;
    short hysteresisEnd0;
    short hysteresisStart1;
    short hysteresisEnd1;
    unsigned char paMode[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    short pRf[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short paGain[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char dc2dcLevel[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned short vBiasDac[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm0[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    unsigned char vm1[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE];
    //Tx Compensation
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE 8
#define MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE 21
    unsigned short earfcn[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short paGainLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_TEMPERATURE_SIZE][MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short couplerLossHigh;
    short couplerLossMiddle;
    short couplerLossLow;
    short powerDetectorHigh[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorMiddle[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
    short powerDetectorLow[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_SUBBAND_SIZE];
} ERfTestCmdGetSetTpcSetting_Bc;

META_RESULT  __stdcall META_ERf_GetTpcSetting_Bc( unsigned char band,  const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
META_RESULT  __stdcall META_ERf_GetTpcSetting_Bc_r( const int meta_handle, unsigned char band, const unsigned int ms_timeout, ERfTestCmdGetSetTpcSetting* resp );
META_RESULT  __stdcall META_ERf_SetTpcSetting_Bc( unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );
META_RESULT  __stdcall META_ERf_SetTpcSetting_Bc_r( const int meta_handle, unsigned char band, ERfTestCmdGetSetTpcSetting* req, const unsigned int ms_timeout );

typedef struct
{
    unsigned int capabilityItemsSize;
    unsigned int calibrationItemsSize;
} ERfTestCmdRfCapabilityReq;

typedef struct
{
    unsigned int  supportBandMap[2];  // supportBandMap[0]:Band01(LSB)~Band32(MSB) supportBandMap[1]Band33(LSB)~Band64(MSB)
    unsigned int  supportMipiBandMap[2]; // supportMipiBandMap[2]:Band01(LSB)~Band32(MSB) supportMipiBandMap[2 1]Band33(LSB)~Band64(MSB)
    unsigned int  supportCoexistenceBandMap[2]; // supportMipiBandMap[2]:Band01(LSB)~Band32(MSB) supportMipiBandMap[2 1]Band33(LSB)~Band64(MSB)
} ErfCapabilityItemSet;

typedef struct
{
    unsigned int is_capable: 1;
    unsigned int is_mandatory: 1;
    unsigned int parameter: 30;
} ErfCalibrationItem;

typedef struct
{
    ErfCalibrationItem tadc_cal; /*<! [0] TADC calibration capability */
    ErfCalibrationItem multi_rat_tadc_bitmap; /*<! [1] bit map of multi-rat TADC calibration */
    ErfCalibrationItem multi_rat_afc_bitmap; /*<! [2] bit map of multi-rat AFC calibration */
    ErfCalibrationItem pd_temp_comp; /* [3] Target support PD temperature compensation*/
    ErfCalibrationItem mipi_pa_level_and_cw_num; /*<! [4] MIPI PA power level and codeword number*/
    ErfCalibrationItem temperature_info; /* [5] Target support temperature info. API; is_capable (0: not supported, 1: supported) */
    ErfCalibrationItem et_module_support; /*<! support ET module or not*/
} ErfCalibrationItemSet;

#define ERF_RF_ID_UNSUPPORT (0)
#define ERF_RF_ID_MT6169    (1)

typedef struct
{
    int                    valid;
    int                    status;
    unsigned int           rfId;
    ErfCapabilityItemSet   capabilityItems;
    ErfCalibrationItemSet  calibrationItems;
} ERfTestCmdRfCapabilityCnf;

META_RESULT __stdcall META_ERf_GetRfCapability( const unsigned int ms_timeout, const ERfTestCmdRfCapabilityReq* req, const unsigned int requestLength, ERfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );
META_RESULT __stdcall META_ERf_GetRfCapability_r( const int meta_handle, const unsigned int ms_timeout, const ERfTestCmdRfCapabilityReq* req, const unsigned int requestLength, ERfTestCmdRfCapabilityCnf* resp, const unsigned int responseLength );

/**
 * Description:
 *     AFC single tone TX for calibrating frequency error.
 * Parameters:
 *     ms_timeout: time out in ms
 *     req: The single TX control parameters to target
 * ENUM command:
 *     ERF_TEST_CMD_START_AFC_SINGLE_TONE_TX
 * Return:
 *     TODO
 **/
typedef struct
{
    unsigned char duplexMode /* 0:tdd, 1:fdd */;
    unsigned char band;
    unsigned short ulFrequency;/* range: 7280~26900 (100KHz unit) */
    unsigned char capid;    /* 0 ~ 255 */
    short afcdac;  /* 0 ~ 8191 */
    unsigned char afcDataType ; /* 0: calibration data, 1: interface */
    short txPowerValue;/*S(8,8),  x dB * 256.0 */
} ERfTestCmdAfcSingleToneTx;

META_RESULT  __stdcall META_ERf_AfcSingleToneTx( const ERfTestCmdAfcSingleToneTx* req, const unsigned int ms_timeout);
META_RESULT  __stdcall META_ERf_AfcSingleToneTx_r( const int meta_handle, const ERfTestCmdAfcSingleToneTx* req, const unsigned int ms_timeout);

/**
 * Description:
 *     AFC NVRAM item write/read API
 * Parameters:
 *     req: the pointer to a memory space which is stored the AFC data for
 *          writing to target NVRAM.
 *     ms_timeout: time out in ms
 *     resp: the pointer to a memory space for storing the result of AFC
 *           NVRAM item acquired from target.
 * ENUM command:
 *     ERF_TEST_CMD_SET_AFC_SETTING
 *     ERF_TEST_CMD_GET_AFC_SETTING
 * Return:
 *     TODO
 **/
typedef struct
{
    unsigned char     capid;       /* 0 ~ 255 */
    unsigned short    afcdac;     /* 0 ~ 8191 */
    int               slopeInv;
} ERfFreqAdjustTable;

// GET AFC table from target
META_RESULT  __stdcall META_ERf_GetAfcSetting( const unsigned int ms_timeout, ERfFreqAdjustTable* resp );
META_RESULT  __stdcall META_ERf_GetAfcSetting_r( const int meta_handle, const unsigned int ms_timeout, ERfFreqAdjustTable* resp );
// SET AFC table to nvram
META_RESULT  __stdcall META_ERf_SetAfcSetting( const ERfFreqAdjustTable* req, const unsigned int ms_timeout );
META_RESULT  __stdcall META_ERf_SetAfcSetting_r( const int meta_handle, const ERfFreqAdjustTable* req, const unsigned int ms_timeout );

/**
 * Description:
 *     APC single tone TX for calibrating TX power.
 * Parameters:
 *     req: The single TX control parameters to target
 *     ms_timeout: time out in ms
 * ENUM command:
 *     ERF_TEST_CMD_START_TPC_SINGLE_TONE_TX
 * Return:
 *     TODO
 **/
typedef struct
{
    unsigned char duplexMode /* 0:tdd, 1:fdd */;
    unsigned char band;
    unsigned short ulFrequency;/* range: 7280~26900 (100KHz unit) */
    unsigned char bandwidth;//(UL BW) 0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB
    short ulFrequencyOffset;/* range: -32768~32767, 6 ==> 90K (1:15K), 6*/
    short afcdac;
    unsigned char afcDataType ; /* 0: calibration data, 1: interface */
    short txPowerValue;/*S(8,8), x dB * 256.0 */
    unsigned char txCloseLoopDisbl;
    unsigned char pa_mode;
} ERfTestCmdTpcSingleToneTx;

META_RESULT  __stdcall META_ERf_ApcSingleToneTx( const ERfTestCmdTpcSingleToneTx* req, const unsigned int ms_timeout);
META_RESULT  __stdcall META_ERf_ApcSingleToneTx_r( const int meta_handle, const ERfTestCmdTpcSingleToneTx* req, const unsigned int ms_timeout );

/**
 * Description:
 *     The API for changing the TX PA gain in DRAM (runtime value)
 *     for calibrating TX power.
 * Parameters:
 *     req: The pa gain of 8-level DC2DC table
 *     ms_timeout: time out in ms
 * ENUM command:
 *     ERF_TEST_CMD_SET_TPC_PA_GAIN
 * Return:
 *     TODO
 **/
typedef struct
{
    unsigned char   band; /* 1~40 */
    short           txPaGain[MAX_ERF_TEST_TX_TPC_SETTING_TABLE_POWER_LEVEL_SIZE]; /* resolution 1/32 */
} ERfTestCmdSetTpcPaGain;

META_RESULT  __stdcall META_ERf_UpdateRunTimePaGains( const ERfTestCmdSetTpcPaGain* req, const unsigned int ms_timeout );
META_RESULT  __stdcall META_ERf_UpdateRunTimePaGains_r( const int meta_handle, const ERfTestCmdSetTpcPaGain* req, const unsigned int ms_timeout );

/**
 * Description:
 *     The API for acquiring the DAC value of power detector.
 * Parameters:
 *     ms_timeout: time out in ms
 *     *txPowerDetectorValue: the short space for storing the DAC value of
 *                 power detector acquiring from target.
 * ENUM command:
 *     ERF_TEST_CMD_GET_POWER_DETECTOR_VALUE
 * Return:
 *     TODO
 **/
META_RESULT  __stdcall META_ERf_GetPowerDectorValue( const unsigned int ms_timeout, short* txPowerDetectorValue );
META_RESULT  __stdcall META_ERf_GetPowerDectorValue_r( const int meta_handle, const unsigned int ms_timeout, short* txPowerDetectorValue );

/**
 * Description:
 *     The API for calibrating RX path loss.
 *     Set the command to target and get back the RSSI value.
 * Parameters:
 *     *req: RSSI commands to target
 *     ms_timeout: time out in ms
 *     *resp: RSSI results acquired from target
 * ENUM command:
 *     ERF_TEST_CMD_START_RSSI
 * Return:
 *     TODO
 **/
typedef struct
{
#define MAX_ERF_TEST_RX_RSSI_FREQ_NUM 36
    unsigned char   duplexMode;/* 0:tdd, 1:fdd */
    unsigned char   band; /* 1~40 */
    unsigned char   num_freq; /* 1~36 */
    unsigned short  dl_freq[MAX_ERF_TEST_RX_RSSI_FREQ_NUM];
    unsigned char   temperatureIndex; /* 0~7 */
    short           gain1; /* main path, resolution 1/32 */
    short           gain2; /* rx diversity path, resolution 1/32 */
} ERfTestCmdRSSI;

typedef struct
{
    unsigned char   num_freq;
    short           dl_freq[MAX_ERF_TEST_RX_RSSI_FREQ_NUM];
    short           rssi[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /* resolution 1/32 */
    unsigned char   lna_mode[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /* 0 ~ 5 */
    short           rssi_rxd[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /* resolution 1/32 */
    unsigned char   lna_mode_rxd[MAX_ERF_TEST_RX_RSSI_FREQ_NUM]; /* 0 ~ 5 */
} ERfTestResultRSSI;

META_RESULT  __stdcall META_ERf_Rssi( const ERfTestCmdRSSI* req, const unsigned int ms_timeout, ERfTestResultRSSI* resp );
META_RESULT  __stdcall META_ERf_Rssi_r( const int meta_handle, const ERfTestCmdRSSI* req, const unsigned int ms_timeout, ERfTestResultRSSI* resp );

/**
 * Description:
 *     SET/GET gain offset table to/from target for a specific band
 * Parameters:
 *     band: band index
 *     *req: RSSI commands to target
 *     ms_timeout: time out in ms
 *     *resp: RSSI results acquired from target
 * ENUM command:
 *     ERF_TEST_CMD_GET_RSSI_SETTING
 *     ERF_TEST_CMD_SET_RSSI_SETTING
 * Return:
 *     TODO
 **/
typedef struct
{
#define MAX_ERF_TEST_RX_LNA_MODE_NUM 6
    short   lna_mode[MAX_ERF_TEST_RX_LNA_MODE_NUM]; //loss of mode 0~5; resolution 1/32
} ERfRSSIGainOffsetTable;

typedef struct
{
#define MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM 15
    ERfRSSIGainOffsetTable gain_of_dl_freq[MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM];
} ERfRSSITempOffsetTable;

typedef struct
{
#define MAX_ERF_TEST_RX_RSSI_TEMP_INDEX_NUM 8
    unsigned short  dlMainFrequency[MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM];
    unsigned short  dlDiversityFrequency[MAX_ERF_TEST_RX_RSSI_TABLE_SUBBAND_NUM];
    ERfRSSITempOffsetTable  pathlossMainData[MAX_ERF_TEST_RX_RSSI_TEMP_INDEX_NUM];
    ERfRSSITempOffsetTable  pathlossDiversityData[MAX_ERF_TEST_RX_RSSI_TEMP_INDEX_NUM];
} ERfRSSIBandGainTable;

// SET gain offset table to nvram
META_RESULT  __stdcall META_ERf_SetPathLossSetting( const unsigned char band, const ERfRSSIBandGainTable* req, const unsigned int ms_timeout );
META_RESULT  __stdcall META_ERf_SetPathLossSetting_r( const int meta_handle, const unsigned char band, const ERfRSSIBandGainTable* req, const unsigned int ms_timeout ); // WARN: do not miss this ;
// GET gain offset table from target
META_RESULT  __stdcall META_ERf_GetPathLossSetting( const unsigned char band, const unsigned int ms_timeout, ERfRSSIBandGainTable* resp );
META_RESULT  __stdcall META_ERf_GetPathLossSetting_r( const int meta_handle, const unsigned char band, const unsigned int ms_timeout, ERfRSSIBandGainTable* resp ); // WARN: do not miss this ;

/**
 * Description:
 *     Trigger DUT starts continuous RX
 * Parameters:
 *     *req: Continuous RX commands to target
 *     ms_timeout: time out in ms
 * ENUM command:
 *     ERF_TEST_CMD_START_CONT_RX
 *     ERF_TEST_CMD_START_CONT_RX
 * Return:
 *     TODO
 **/
typedef struct
{
    unsigned char   duplexMode;/* 0:tdd, 1:fdd */
    unsigned char   band; /* 1~40 */
    unsigned short  dl_freq;
    unsigned char   bandwidth;//(DL BW) 0: 6 RB, 1: 15 RB, 2: 25 RB, 3: 50 RB, 4: 75 RB, 5: 100 RB
    short           gain1; /* main path, resolution 1/32 */
    short           gain2;  /* rx diversity path, resolution 1/32 */
} ERfTestCmdContRx;

META_RESULT  __stdcall META_ERf_ContRx( const ERfTestCmdContRx* req, const unsigned int ms_timeout);
META_RESULT  __stdcall META_ERf_ContRx_r( const int meta_handle, const ERfTestCmdContRx* req, const unsigned int ms_timeout);

/********************
 *   FHC interface  *
 ********************/

#define MAX_FHC_BAND_NUM 10
#define MAX_FHC_RX_FREQ_NUM 22  // MAX( MAX_FHC_RX_FREQ_NUM, MAX_FHC_TX_FREQ_NUM )
#define MAX_FHC_TX_FREQ_NUM 22  // subband nubmer + middle channel
#define MAX_FHC_PWR_STEP_NUM 27     // 8 pa section * 3 + 3 PD values(H,M,L)

/* uplink arrangements */
typedef struct
{
    unsigned short   ul_freq;//100kHz unit
    unsigned char    ul_bw;//0(1.4M)~5(20M)
    unsigned char    pwr_step_num;
    short            pwr_step_value[MAX_FHC_PWR_STEP_NUM];//S(8, 8)
    short            pwr_step_pa_gain [MAX_FHC_PWR_STEP_NUM];
    unsigned char    pwr_step_pa_gain_tbl_indx [MAX_FHC_PWR_STEP_NUM];
    unsigned char    pwr_step_pa_mode [MAX_FHC_PWR_STEP_NUM];  /* 0: high, 1: middle, 2: low */
} ERf_FHC_Tx_Freq_Param;

typedef struct
{
    unsigned char    band_index;
    unsigned char    freq_num;
    ERf_FHC_Tx_Freq_Param freq_param[MAX_FHC_TX_FREQ_NUM];
} ERf_FHC_Tx_Band_Param;

typedef struct
{
    unsigned char    tx_step_width;//ms unit
    unsigned char    band_num;
    ERf_FHC_Tx_Band_Param     band_param[MAX_FHC_BAND_NUM];
    short            freq_offst;//range -32768~32767
    short            afc_dac;
    unsigned char    afc_data_type;//0: calibration data, 1: from interface value
    unsigned char    close_loop_disable;
} ERf_FHC_Tx_Cfg;

/* uplink arrangements */
typedef struct
{
    unsigned short   dl_freq;//100kHz unit
    unsigned char    temperature_indx;
    unsigned char    pwr_step_num;
    short            gain1[MAX_FHC_PWR_STEP_NUM];
    short            gain2[MAX_FHC_PWR_STEP_NUM];
} ERf_FHC_Rx_Freq_Param;

typedef struct
{
    unsigned char    band_index;
    unsigned char    freq_num;
    ERf_FHC_Rx_Freq_Param freq_param[MAX_FHC_RX_FREQ_NUM];
} ERf_FHC_Rx_Band_Param;

typedef struct
{
    unsigned char   tx_to_rx_time;//ms unit
    unsigned char   band_num;
    ERf_FHC_Rx_Band_Param    band_param[MAX_FHC_BAND_NUM];
} ERf_FHC_Rx_Cfg;

/* FHC TRX command parameter */
typedef struct
{
    unsigned char    phy_cell_id;//no used for single tone?
    unsigned char    fdd_band_start_index;
    unsigned char    fdd_band_end_index;
    unsigned char    tdd_band_start_index;
    unsigned char    tdd_band_end_index;
    unsigned char    fdd_to_tdd_switch_time;//ms unit
    unsigned char    tdd_to_fdd_switch_time;//ms unit
    unsigned char    tdd_tx_rx_switch_time;//ms unit
    unsigned char    freq_switch_time;//ms unit
    unsigned char    band_switch_time;//ms unit
    ERf_FHC_Tx_Cfg   txCmd;
    ERf_FHC_Rx_Cfg   rxCmd;
} ERf_FHC_Cmd;


/* FHC TRX results */
typedef struct
{
    unsigned short    ul_freq;//100kHz unit
    short             txPowerDetectorValue[MAX_FHC_PWR_STEP_NUM];
    unsigned char     pwr_step_num;
} ERf_FHC_Tx_Freq_Rpt;

typedef struct
{
    unsigned short   dl_freq;//100kHz unit
    short            rssi[MAX_FHC_PWR_STEP_NUM];
    short            rssi_rxd[MAX_FHC_PWR_STEP_NUM];
    unsigned char    lna_mode[MAX_FHC_PWR_STEP_NUM];
    unsigned char    lna_mode_rxd[MAX_FHC_PWR_STEP_NUM];
    unsigned char    pwr_step_num;
} ERf_FHC_Rx_Freq_Rpt;

typedef struct
{
    unsigned char    band_index;
    unsigned char    tx_freq_num;
    unsigned char    rx_freq_num;
    ERf_FHC_Tx_Freq_Rpt  tx_freq_rpt[MAX_FHC_TX_FREQ_NUM];
    ERf_FHC_Rx_Freq_Rpt  rx_freq_rpt[MAX_FHC_RX_FREQ_NUM];
} ERf_FHC_TRx_Band_Rpt;

typedef struct
{
    unsigned char           band_num;
    ERf_FHC_TRx_Band_Rpt    band_rpt[MAX_FHC_BAND_NUM];
} ERf_FHC_TRx_Rpt;

/**
 * Description:
 *     Command target to execute FHC arrangements and blocking until result returns
 * Parameters:
 *     *req: FHC arrangements
 *     ms_timeout: time out in ms
 *     *resp: RSSI results and PD values acquired from target
 * ENUM command:
 *     ERF_TEST_CMD_START_FHC
 *     ERF_TEST_CMD_START_FHC
 * Return:
 *     TODO
 **/
META_RESULT  __stdcall META_ERf_FHC( const ERf_FHC_Cmd* req, const unsigned int ms_timeout, ERf_FHC_TRx_Rpt* resp );
META_RESULT  __stdcall META_ERf_FHC_r( const int meta_handle, const ERf_FHC_Cmd* req, const unsigned int ms_timeout, ERf_FHC_TRx_Rpt* resp );

typedef struct
{
    bool         ok;
    unsigned int sum;
} ERf_TemperatureResult;

META_RESULT __stdcall META_ERf_GetRfTemperature(const unsigned int ms_timeout, const unsigned short measureCount, ERf_TemperatureResult* result);
META_RESULT __stdcall META_ERf_GetRfTemperature_r(const int meta_handle, const unsigned int ms_timeout, const unsigned short measureCount, ERf_TemperatureResult* result);

typedef struct
{
#define MAX_ERF_TEST_TADC_INDEX_NUM 8
    unsigned short data[MAX_ERF_TEST_TADC_INDEX_NUM];
} ERfTadcSetting;

META_RESULT __stdcall META_ERf_GetTadcSetting(const unsigned int ms_timeout, ERfTadcSetting* table);
META_RESULT __stdcall META_ERf_GetTadcSetting_r(const int meta_handle, const unsigned int ms_timeout, ERfTadcSetting* table);
META_RESULT __stdcall META_ERf_SetTadcSetting(const unsigned int ms_timeout, const ERfTadcSetting* table);
META_RESULT __stdcall META_ERf_SetTadcSetting_r(const int meta_handle, const unsigned int ms_timeout, const ERfTadcSetting* table);
#define MAX_ERF_MIPI_POWER_LEVEL   16
#define MAX_ERF_MIPI_CODE_WORD_NUM 16
typedef struct
{
    unsigned short       rf_band_idx;
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_ERF_MIPI_POWER_LEVEL][MAX_ERF_MIPI_CODE_WORD_NUM];
} ERfSetMIPICodeWord;
typedef struct
{
    unsigned short       power_level_num;
    unsigned short       code_word_num;
    unsigned int         codeword[MAX_ERF_MIPI_POWER_LEVEL][MAX_ERF_MIPI_CODE_WORD_NUM];
} ERfGetMIPICodeWord;
META_RESULT __stdcall META_ERf_SetMIPICodeWord(const ERfSetMIPICodeWord* req,  unsigned int ms_timeout);
META_RESULT __stdcall META_ERf_SetMIPICodeWord_r(const int meta_handle, const ERfSetMIPICodeWord* req, const unsigned int ms_timeout);
META_RESULT __stdcall META_ERf_GetMIPICodeWord(const unsigned int ms_timeout, const unsigned short RfBandIndex, ERfGetMIPICodeWord* cnf);
META_RESULT __stdcall META_ERf_GetMIPICodeWord_r(const int meta_handle, const unsigned int ms_timeout, const unsigned short RfBandIndex, ERfGetMIPICodeWord* cnf);
typedef struct
{
    unsigned char band;
    unsigned char bandwidth;
    short txPower;
    unsigned short ulFrequency;
} ERfEtTxSetting;
typedef struct
{
    short output_vpa_voltage;
} ERfEtFdModeSetting;
typedef struct
{
    unsigned short mode; // ET:0 FD:1 Bypass:2
    short outer_gain;
    short input_offset_voltage;
    short main_sw_output_voltage;
    short aux_sw_output_voltage;
} ERfEtSpModeSetting;
typedef struct
{
    unsigned short et_mode; // ET:0 FD:1 static performance mode:2
    ERfEtTxSetting tx_setting;
    ERfEtFdModeSetting fd_mode_setting;
    ERfEtSpModeSetting sp_mode_setting;
} ERfEtModeSetting;
META_RESULT __stdcall META_ERf_SetEtMode(ERfEtModeSetting* req, const unsigned int ms_timeout);
META_RESULT __stdcall META_ERf_SetEtMode_r(const int meta_handle, ERfEtModeSetting* req , const unsigned int ms_timeout);
/***********************
 *     LTE TX NSFT
 ***********************/

// NSFT TX power step arrange type 0
typedef struct
{
#define MAX_NSFT_LIST_TX_PWR_STEP_NUM 8
    unsigned char    pwr_step_num;//0~8;
    short            pwr_step_tx_power[MAX_NSFT_LIST_TX_PWR_STEP_NUM];//S(8,8)
    unsigned char    pwr_step_VRB_strt[MAX_NSFT_LIST_TX_PWR_STEP_NUM];
    unsigned char    pwr_step_VRB_len[MAX_NSFT_LIST_TX_PWR_STEP_NUM];
} ERf_NSFT_List_Tx_Specify_Pwr_Param;
// NSFT TX power step arrange type 1
typedef struct
{
    short            start_power;//S(8,8)
    short            pwr_step_value;//S(8,8)
    unsigned char    pwr_step_num;
    unsigned char    pwr_step_VRB_strt_p1; //start VRB for the first period
    unsigned char    pwr_step_VRB_len_p1;
    unsigned char    pwr_step_VRB_strt_p2; //start VRB for the second period
    unsigned char    pwr_step_VRB_len_p2;
    unsigned char    step_for_change_tx_VRB; //0: Tx VRB will be changed to p2 at step 0
} ERf_NSFT_List_Tx_Specify_Step_Param;
// NSFT TX frequency step setting
typedef struct
{
    unsigned short   ul_freq;//100kHz unit
    unsigned char    ul_bw;//0(1.4M)~5(20M)
    unsigned char    pwr_step_MCS_mode; //0:QPSK, 1:16QAM, 2:64QAM
    char             cmd_type;     //0: NSFT_List_Tx_Specify_Pwr_Param, 1: NSFT_List_Tx_Specify_Step_Param
    union
    {
        ERf_NSFT_List_Tx_Specify_Pwr_Param     specify_tx_pwr_cmd;
        ERf_NSFT_List_Tx_Specify_Step_Param    specify_pwr_step_cmd;
    };
} ERf_NSFT_List_Tx_Freq_Param;
// NSFT TX band step setting
typedef struct
{
    unsigned char    band_index;
    unsigned char    freq_num;
    unsigned short   dl_sync_freq;//100kHz unit
#define MAX_NSFT_LIST_TX_FREQ_NUM 13
    ERf_NSFT_List_Tx_Freq_Param     freq_param[MAX_NSFT_LIST_TX_FREQ_NUM];
} ERf_NSFT_List_Tx_Band_Param;
// NSFT TX configure
typedef struct
{
    unsigned char    fdd_tx_step_width;//ms unit
    unsigned char    tdd_tx_step_width;//ms unit
    unsigned char    band_num;
#define MAX_NSFT_LIST_TX_BAND_NUM 10
    ERf_NSFT_List_Tx_Band_Param     band_param[MAX_NSFT_LIST_TX_BAND_NUM];
    short            freq_offst;//range -32768~32767
    short            afc_dac;
    unsigned char    afc_data_type;//0: calibration data, 1: from interface value
    unsigned char    close_loop_disable;
} ERf_NSFT_List_Tx_Cfg;

// NSFT TX command
typedef struct
{
    unsigned char       phy_cell_id;//no used for single tone?
    unsigned char       fdd_band_start_index;
    unsigned char       fdd_band_end_index;
    unsigned char       tdd_band_start_index;
    unsigned char       tdd_band_end_index;
    unsigned char       fdd_to_tdd_switch_time;//ms unit
    unsigned char       fdd_freq_switch_time;//ms unit
    unsigned char       tdd_freq_switch_time;//ms unit
    unsigned char       fdd_band_switch_time;//ms unit
    unsigned char       tdd_band_switch_time;//ms unit
    unsigned short      fdd_dl_sync_time;//ms unit
    unsigned short      tdd_dl_sync_time;//ms unit
    ERf_NSFT_List_Tx_Cfg    txCmd;
} ERf_NSFT_List_Cmd;

/**
 * Description:
 *     Command target to execute TX NSFT arrangements and blocking until result returns
 * Parameters:
 *     *req: TX NSFT arrangements
 *     ms_timeout: time out in ms
 *     *p_iTxNsftStatus: the pointer point to a space to store TX NSFT status
 * ENUM command:
 *     ERF_TEST_CMD_START_NSFT_LIST
 *     ERF_TEST_CMD_START_NSFT_LIST
 * Return:
 *     TODO
 **/
META_RESULT  __stdcall META_ERf_Start_TxNsft( const ERf_NSFT_List_Cmd* req, const unsigned int ms_timeout, unsigned int* p_iTxNsftStatus );
META_RESULT  __stdcall META_ERf_Start_TxNsft_r( const int meta_handle, const ERf_NSFT_List_Cmd* req, const unsigned int ms_timeout, unsigned int* p_iTxNsftStatus );

typedef META_Rf_TemperatureInfo_T META_ERf_TemperatureInfo_T;

META_RESULT __stdcall META_ERf_GetTemperatureInfo(const unsigned int ms_timeout, META_ERf_TemperatureInfo_T* info);
META_RESULT __stdcall META_ERf_GetTemperatureInfo_r(const int meta_handle, const unsigned int ms_timeout, META_ERf_TemperatureInfo_T* info);
const char* __stdcall META_ERf_GetRfChipIdName(unsigned int id);
META_RESULT __stdcall META_ERf_SetPathFlag(const unsigned int ms_timeout);
META_RESULT __stdcall META_ERf_SetPathFlag_r(const int meta_handle, const unsigned int ms_timeout);
#endif /* __META_LTE__ */

//--------------------------------------------------------------------------//
//  NVRAM                                                                   //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  NVRAM: data structure definition                   //
//-----------------------------------------------------//

// Reset NVRAM
typedef enum
{
    NVRAM_RESET_ALL,        // Reset all data items in both of user and system category
    NVRAM_RESET_USER,       // Reset data items in user category    --> obsolete! just keep the enum value for backward compatibility.
    NVRAM_RESET_SYSTEM,     // Reset data items in system category  --> obsolete! just keep the enum value for backward compatibility.
    NVRAM_RESET_CERTAIN,    // Reset certain data item according to LID
    NVRAM_RESET_FACTORY     // Reset to factory default value, all the LIDs has FACTORY attribute will be reseted
} ResetCategory;

typedef struct
{
    ResetCategory   category;   // Reset category

    const char*      LID;       // The name of logical data item ID , it will be used
    // if and only if ResetCategory = NVRAM_RESET_CERTAIN,
    // in other case you can just assign NULL.
} FT_NVRAM_RESET_REQ;

typedef struct
{
    unsigned char   status;     // The status of Reset
} FT_NVRAM_RESET_CNF;

// Read from NVRAM
typedef struct
{
    const char*          LID;       // The name of logical data item ID
    unsigned short      RID;        // Record ID (the first record is 1)
} FT_NVRAM_READ_REQ;

typedef struct
{
    unsigned short      LID;        // Logical data item ID of a EF
    unsigned short      RID;        // Record ID (the first record is 1)
    unsigned char       status;     // 0: read ok; others: read failed.

    unsigned int        len;        // [IN] Length of Buffer, [OUT] Length of read data
    // The "len" field indicates the size of "buf" you
    // allocated. When the data is read back, "len" will
    // be replaced with the actual size of the data.

    unsigned char*       buf;       // Buffer that will contains the content of record
} FT_NVRAM_READ_CNF;

//Write to NVRAM
typedef struct
{
    const char*          LID;       // The name of logical data item ID
    unsigned short      RID;        // Record ID (the first record is 1)
    unsigned int        len;        // Length of write data
    unsigned char*       buf;       // Buffer that contains the content of record
} FT_NVRAM_WRITE_REQ;

typedef struct
{
    unsigned short      LID;        // Logical data item ID of a EF
    unsigned short      RID;        // Record ID (the first record is 1)
    unsigned char       status;     // 0: write ok; others: write failed.
} FT_NVRAM_WRITE_CNF;

// AGC path loss
#define  PLTABLE_SIZE  13           // element count of path loss table

typedef  struct
{
    short        max_arfcn;          // The maximum ARFCN of the indicated sub-band
    char         gain_offset;        // The maximum available gain of transceiver of the indicated sub-band
} sAGCGAINOFFSET;

typedef struct
{
    sAGCGAINOFFSET     agcPathLoss[FrequencyBandCount][PLTABLE_SIZE];
} l1cal_agcPathLoss_T;

typedef struct
{
    char gain_offset_middle;
    char gain_offset_low;
} sLNAGAINOFFSET;
/*****************************************************************
 * The lna middle/low depends on the high mode max_arfcn setting
 * (l1cal_agcPathLoss_T: high mode)
 * (l1cal_agcLnaPathLoss_T: middle/low mode)
 ****************************************************************/
typedef struct
{
    sLNAGAINOFFSET     lnaPathLoss[FrequencyBandCount][PLTABLE_SIZE];
} l1cal_lnaPathLoss_T;

typedef struct
{
    unsigned short data[8];    /* for temperature ADC */
} sTEMPERATURE_ADC_L1CAL;

typedef sTEMPERATURE_ADC_L1CAL l1cal_temperatureADC_T;

// Speech Coefficient
typedef struct
{
    short       Speech_8k_Input_Coeff[30];      // FIR for input speech (microphone) with 8k sampling rate
    short       Speech_8k_Output_Coeff[30];     // FIR for output speech (speaker) with 8k sampling rate
    short       Speech_16k_Input_Coeff[62];     // FIR for input speech (microphone) with 16k sampling rate
    short       Speech_16k_Output_Coeff[62];    // FIR for output speech (speaker) with 16k sampling rate

    short       Additional_Speech_8k_Output_Coeff[5][30];   // The additional FIR for output speech (speaker) with 8k sampling rate

    unsigned short  Speech_8k_Output_Coeff_Index;   // The active FIR index
    // 0 -> Speech_8k_Output_Coeff
    // 1 -> Additional_Speech_8k_Output_Coeff[0]
    // 2 -> Additional_Speech_8k_Output_Coeff[1]
    // 3 -> Additional_Speech_8k_Output_Coeff[2]
    // 4 -> Additional_Speech_8k_Output_Coeff[3]
    // 5 -> Additional_Speech_8k_Output_Coeff[4]
} L1_SpeechCoeff_T;

// Melody Coefficient
typedef struct
{
    short       Melody_32k_Output_Coeff[45];    // FIR for melody playback with with 32k sampling rate
} L1_MelodyCoeff_T;

// L1Audio Param
typedef struct
{
    L1_SpeechCoeff_T    Speech_FIR[2];  // [0]: normal mode
    // [1]: headset mode
    // NOTE: In headset mode, Additional_Speech_8k_Output_Coeff and
    //       Speech_8k_Output_Coeff_Index are ignored! you can just
    //       leave them alone.

    L1_MelodyCoeff_T    Melody_FIR[2];  // [0]: loud speaker mode
    // [1]: stereo speaker mode
    unsigned short      ES_TimeConst;
    unsigned short      ES_VolConst;
    unsigned short      ES_TimeConst2;
    unsigned short      ES_VolConst2;
    unsigned short      Media_Playback_Maximum_Swing;
} l1audio_param_T;

// L1Audio Param from W0547

#define SPEECH_NORMAL_MODE          0
#define SPEECH_EARPHONE_MODE        1
#define SPEECH_LOUDSPEAKER_MODE     2
#define SPEECH_BT_ERAPHONE_MODE     3
#define SPEECH_BT_CORDLESS_MODE     4
#define SPEECH_AUX1_MODE            5
#define SPEECH_AUX2_MODE            6
#define SPEECH_AUX3_MODE            7

typedef struct
{
    L1_SpeechCoeff_T    Speech_FIR[2];  // [0]: normal mode
    // [1]: headset mode
    // NOTE: In headset mode, Additional_Speech_8k_Output_Coeff and
    //       Speech_8k_Output_Coeff_Index are ignored! you can just
    //       leave them alone.

    L1_MelodyCoeff_T    Melody_FIR[2];  // [0]: loud speaker mode
    // [1]: stereo speaker mode

    unsigned short      Speech_Common_Para[12];

    unsigned short      Speech_ModeDependent_Para[8][8];    // [0]: Normal Mode
    // [1]: Earphone Mode
    // [2]: Loud Speaker Mode
    // [3]: BlueTooth Earphone Mode
    // [4]: BlueTooth Cordless Mode
    // [5]: AUX1 Mode
    // [6]: AUX2 Mode
    // [7]: AUX3 Mode
    unsigned short      Media_Playback_Maximum_Swing;
} l1audio_param_W0547_T;


typedef struct
{
    short speech_input_FIR_coeffs[6][45];
    short speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_normal_mode_para[8];
    unsigned short speech_earphone_mode_para[8];
    unsigned short speech_loudspk_mode_para[8];
    unsigned short speech_bt_earphone_mode_para[8];
    unsigned short speech_bt_cordless_mode_para[8];
    unsigned short speech_aux1_mode_para[8];
    unsigned short speech_aux2_mode_para[8];
    unsigned short speech_aux3_mode_para[8];
    unsigned short Media_Playback_Maximum_Swing;
    short Melody_FIR_Output_Coeff_32k_Tbl1[45];
} l1audio_param_W0547_45_T;

typedef struct
{
    short speech_input_FIR_coeffs[6][45];
    short speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_normal_mode_para[8];
    unsigned short speech_earphone_mode_para[8];
    unsigned short speech_loudspk_mode_para[8];
    unsigned short speech_bt_earphone_mode_para[8];
    unsigned short speech_bt_cordless_mode_para[8];
    unsigned short speech_aux1_mode_para[8];
    unsigned short speech_aux2_mode_para[8];
    unsigned short speech_aux3_mode_para[8];
    unsigned short Media_Playback_Maximum_Swing;
    short Melody_FIR_Output_Coeff_32k_Tbl1[25];
} l1audio_param_W0712_T;


typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][8];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[2][45];  // new added, so different with others structure

} l1audio_param_W0740_T;


typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][16];
    unsigned short speech_volume_para[3][7][4];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[2][45];  // new added, so different with others structure

} l1audio_param_W0809_T; //l1audio_param_W0748_T;


typedef struct
{
    short          speech_input_FIR_coeffs[6][45];
    short          speech_output_FIR_coeffs[6][45];
    unsigned short selected_FIR_output_index;
    unsigned short speech_common_para[12];
    unsigned short speech_mode_para[8][16];
    unsigned short speech_volume_para[3][7][4];
    unsigned short Media_Playback_Maximum_Swing;
    short          Melody_FIR_Coeff_Tbl[25];
    short          audio_compensation_coeff[3][45];  // three ACFs for special branches in w10.18

} l1audio_param_EX_T;  // from W10.21

typedef struct
{
    /* Volume */
    short vol_calibration_shift[8];
    short vol_calibration_subband[8];
    /* Delay */
    short delay_cal_int;
    short delay_cal_frac;
    short delay_cal_subband[8];
    /* Leakage */
    short power_ratio_scale;
    short wind_index_threshold;
    short subband_bmg[8];
    /* Mockup Diagnosis */
    short mockup_level;
    short shielding_level;
    short NR_Level;
    /* Reserve */
    short reserve[5];
} audio_dual_mic_nb_param_struct;

typedef struct
{
    /* Volume */
    short vol_calibration_shift[16];
    short vol_calibration_subband[16];
    /* Delay */
    short delay_cal_int;
    short delay_cal_frac;
    short delay_cal_subband[16];
    /* Leakage */
    short power_ratio_scale;
    short wind_index_threshold;
    short subband_bmg[16];
    /* Mockup Diagnosis */
    short mockup_level;
    short shielding_level;
    short NR_Level;
    /* Reserve */
    short reserve[5];
} audio_dual_mic_wb_param_struct;

typedef struct
{
    audio_dual_mic_nb_param_struct nb_param; /* narrow band parameter */
    audio_dual_mic_wb_param_struct wb_param; /* wide   band parameter */
} audio_dual_mic_param_struct;

typedef struct
{
    short audio_compensation_filter_sw_ver_coeffs[3][3][45];
} l1audio_swfir_T;

typedef struct
{
    short         count;
    short         index;
    char          magnitude[8][30];
    unsigned char setting_name[9][48];
} nvram_ef_audio_equalizer_struct;

typedef struct
{
    unsigned char audio_bes_eq_initial_parameter[122];
} nvram_ef_audio_bes_eq_flexible_struct;

// crystalAfcData
#define XO_SlopeArea_Num       33  // change from 8 to 33, 8 is obsolete

typedef struct
{
    int     min_freq;
    short   min_dac;
    //int       inv_slope;
} XO_SLOPE_AREA_DATA;

typedef struct
{
    XO_SLOPE_AREA_DATA      XO_SlopeAreaData[XO_SlopeArea_Num];
} l1cal_crystalAfcData_T;

// IMEISV
typedef struct
{
    char            imei[16];
    unsigned char   svn;
    unsigned char   pad;
} IMEISV_struct_T;

// Custom Acoustic Volume
#define MAX_VOL_CATE        3
#define MAX_VOL_TYPE        7
#define MAX_VOL_LEVEL       7
typedef struct
{
    unsigned char   volume_gain[MAX_VOL_CATE][MAX_VOL_TYPE][MAX_VOL_LEVEL];
    // Volume Gain: [Mode (Normal, Headset, LoudSpeaker)]
    //              [Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]
    //              [Level (1~7)]

    unsigned char   volume[MAX_VOL_CATE][MAX_VOL_TYPE];
    // Current Volume Level:    [Mode (Normal, Headset, LoudSpeaker)]
    //                          [Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]
    //                          value: 0~6 [ Level_1(0) ~ Level_7(6) ]

} CustAcousticVol_T;
typedef struct
{
    unsigned char   volume_gain[MAX_VOL_CATE][MAX_VOL_TYPE][MAX_VOL_LEVEL];
    // Volume Gain: [Mode (Normal, Headset, LoudSpeaker)]
    //              [Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]
    //              [Level (1~7)]

    unsigned char   volume[MAX_VOL_CATE][MAX_VOL_TYPE];
    // Current Volume Level:    [Mode (Normal, Headset, LoudSpeaker)]
    //                          [Tone type (CallTone, Keytone, MIC, GMI, Speech, SideTone, Melody) ]
    //                          value: 0~6 [ Level_1(0) ~ Level_7(6) ]
    unsigned char max_melody_volume_gain[MAX_VOL_CATE + 1];
    unsigned char melody_volume_gain_step[MAX_VOL_CATE + 1];
    unsigned char tv_out_volume_gain[MAX_VOL_LEVEL];
} CustAcousticVol16lvl_T;

// S/W Change
typedef enum
{
    LID_VER_SAME = 0,
    LID_VER_CHANGED
} LID_STATUS;

typedef struct
{
    int     OldVer;
    int     NewVer;
    char    LID[64];
} LID_Info;

typedef struct
{
    int      target_nvramsize;   // current NVRAM size on target FAT file system
    int      target_freespace;   // current freespace of target FAT file system
    int      target_overhead;    // S/W upgrade operation overhead
    int      newdb_nvramsize;    // new NVRAM size
    unsigned char    status;     // 0 -> [OK] safe to upgrade to new NVRAM
    // 1 -> [ERROR] can't retrieve info from target
    // 2 -> [ERROR] freespace is not enough to upgrade to new NVRAM
} NVRAM_GetDiskInfo_Cnf;

// WiFi
typedef struct
{
    unsigned char   mac_addr[6];
} WiFi_MacAddress_S;

typedef struct
{
    unsigned char   CCKTxPWR[14];
    unsigned char   OFDMTxPWR[14];
} WiFi_TxPower_2400M_S;

typedef struct
{
    unsigned char   TxPWR[34];
} WiFi_TxPower_5000M_S;

typedef struct
{
    unsigned char   i_ch_offset;
    unsigned char   q_ch_offset;
} WiFi_DAC_DC_Offset_S;

typedef struct
{
    unsigned char txAlcCCK[14];
    unsigned char txOutputPowerDBCCK[14];
    unsigned char txAlcOFDM [8][14];
    unsigned char txOutputPowerDBOFDM[8][14];
} WiFi_ALC_2400M_S;

typedef struct
{
    unsigned char alcSlop1Divider;
    unsigned char alcSlop1Dividend;
    unsigned char alcSlop2Divider;
    unsigned char alcSlop2Dividend;
} WiFi_TxALC_2400M_S;
typedef struct
{
    unsigned char BluetoothAddress[6];
    unsigned char MinEncryptionSize[1];
    unsigned char MaxEncryptionSize[1];
    unsigned char HCITransportLayerParameters[3];
    unsigned char FixedPIN[16];
    unsigned char FixedPINLength[1];
    unsigned char SleepEnableMask[1];
    unsigned char LowPowerClockParameter[8];
    unsigned char PowerControlConfiguration[13];
    unsigned char SleepControlParameters[12];
    unsigned char DebugControl[4];
    unsigned char LCandRMOverrideEnable[4];
    unsigned char RadioRegisterOverride[6];
    unsigned char CodecConfiguration[8];
    unsigned char CVSDGainVolumeSettings[6];
    unsigned char VoiceSettings[2];
    unsigned char UserBaudRate[3];

    unsigned char LowPowerDriftRate[1];
    unsigned char MaxTxPowerLevel[1];
    unsigned char AdaptiveFrequencyHoppingParameters[29];
    unsigned char BufferSize[4];
    unsigned char GpioMapping[16];
    unsigned char GpioPolarity[4];
}  nvram_ef_btradio_rfmd3500_struct;

typedef struct
{
    unsigned char BDAddr[6];
    unsigned char ClassOfDevice[3];
    unsigned char LinkKeyType[1];
    unsigned char UnitKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[1];
    unsigned char Radio[30];
    unsigned char Sleep[6];
    unsigned char MainOscillatorInfo[5];
    unsigned char LPOInfo[4];
    unsigned char AFH[9];
    unsigned char PTA[49];
    unsigned char WDT[2];
    unsigned char Debug[1];
    unsigned char UART[2];
}  nvram_ef_btradio_mt6601_struct;

// this is common for MT6611/MT6612/MT6236
typedef struct
{
    unsigned char BDAddr[6];
    unsigned char CapId[1];
    unsigned char LinkKeyType[1];
    unsigned char UnitKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[1];
    unsigned char Radio[6];
    unsigned char Sleep[7];
    unsigned char Reserved[2];
} nvram_ef_btradio_mt6611_struct;

// MT6612 (from 10AW1108MP and later)
// MT6236 (from 11AW1112MP and later)
typedef struct
{
    unsigned char BDAddr[6];
    unsigned char CapId[1];
    unsigned char LinkKeyType[1];
    unsigned char UnitKey[16];
    unsigned char Encryption[3];
    unsigned char PinCodeType[1];
    unsigned char Voice[2];
    unsigned char Codec[1];
    unsigned char Radio[6];
    unsigned char Sleep[7];
    unsigned char Reserved[2];
    unsigned char ECLK_SEL;
} nvram_ef_btradio_mtk_bt_chip_struct;

typedef struct // LID: NVRAM_EF_WNDRV_EXT_SETTING_TRIMVAL_THERMOVAL_LID
{
    char           cAbsTemp;
    unsigned char  ucThermoValue;
    unsigned char  ucXtalTrim;
} wndrv_cal_setting_trim_thermo_struct;

typedef struct
{
    unsigned short tst_port_ps;
    unsigned short         ps_port;
    unsigned long   tst_baudrate_ps;
    unsigned long   ps_baudrate;
    bool           High_Speed_SIM_Enabled;
    unsigned char          swdbg;
    unsigned char          uart_power_setting; /* For DCM, Start [Set UART POWER], CTI  */
    unsigned char          cti_uart_port;
    unsigned long   cti_baudrate;
    unsigned char           tst_port_l1;
    unsigned long   tst_baudrate_l1;
    // Support tst output to memory card
    unsigned char          tst_output_mode;
    unsigned char  usb_logging_mode;
    unsigned short  tst_port_dsp;
    unsigned long   tst_baud_rate_dsp;
} port_setting_struct;
// from: mcu\interface\hwdrv\uart_sw.h

//-----------------------------------------------------//
//  NVRAM: callback function definition                //
//-----------------------------------------------------//
typedef void (__stdcall* META_NVRAM_Reset_CNF)(const FT_NVRAM_RESET_CNF* cnf, const short token, void* usrData);
typedef void (__stdcall* META_NVRAM_Read_CNF)(const FT_NVRAM_READ_CNF* cnf, const short token, void* usrData);
typedef void (__stdcall* META_NVRAM_Write_CNF)(const FT_NVRAM_WRITE_CNF* cnf, const short token, void* usrData);
typedef void (__stdcall* CB_META_NVRAM_GET_DISK_INFO_CNF)(const NVRAM_GetDiskInfo_Cnf* cnf, const short token, void* usrData);

//-----------------------------------------------------//
//  NVRAM: exported function definition                //
//-----------------------------------------------------//
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_KEY_LENGTH)(unsigned int* const length, void* usrData);
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_KEY)(char* const key, unsigned int key_length, void* usrData);
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_DATABASE_LENGTH)(unsigned int* const length, void* usrData);
typedef int (__stdcall* CB_META_NVRAM_GET_REMOTE_DATABASE)(char* const database, unsigned int database_length, void* usrData);
/**
 * Please set before calling META_NVRAM_Init_r if you need to customize the load database/load key operation.
 * getKey/ getKeyLength must be set at the same time (if one of the callback is NULL, then the key is retrieved by file system operation)
 * getDatabase/getDatabaseLength must be set at the same time (if one of the callback is NULL, then database is retrieved by file system operation)
 */
META_RESULT  __stdcall META_NVRAM_SetCallback(
    CB_META_NVRAM_GET_REMOTE_KEY_LENGTH      getKeyLength,      void* getKeyLengthArgument,
    CB_META_NVRAM_GET_REMOTE_KEY             getKey,            void* getKeyArgument,
    CB_META_NVRAM_GET_REMOTE_DATABASE_LENGTH getDatabaseLength, void* getDatabaseLengthArgument,
    CB_META_NVRAM_GET_REMOTE_DATABASE        getDatabase,       void* getDatabaseArgument
);
META_RESULT  __stdcall META_NVRAM_Init(const char* PathName, unsigned long* p_nvram_CatcherTranAddr);
META_RESULT  __stdcall META_NVRAM_Init_r(const int meta_handle, const char* PathName, unsigned long* p_nvram_CatcherTranAddr);
/* Dual Talk */
/**
 * \brief non-reentrant version of META_NVRAM_Init_Ex_r
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex(const unsigned int md_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \brief init NVRAM database for specified MD
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_r(const int meta_handle, const unsigned int md_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \brief non-reentrant version of META_NVRAM_Init_2_r
 */
META_RESULT  __stdcall META_NVRAM_Init_2(const char* db1_path, const char* db2_path, unsigned long* p_active_db_addr);
/**
 * \brief non-reentrant version of META_NVRAM_Init_Ex_Mdtype_r
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_Mdtype(const unsigned int md_index, const unsigned int mdtype_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \brief init NVRAM database for specified MD and MDType
 */
META_RESULT  __stdcall META_NVRAM_Init_Ex_Mdtype_r(const int meta_handle, const unsigned int md_index, const unsigned int mdtype_index, const char* db_path, unsigned long* p_active_db_addr);
/**
 * \brief init NVRAM database for dual-talk project
 */
META_RESULT  __stdcall META_NVRAM_Init_2_r(const int meta_handle, const char* db1_path, const char* db2_path, unsigned long* p_active_db_addr);
META_RESULT  __stdcall META_NVRAM_Reset(const FT_NVRAM_RESET_REQ* req, const META_NVRAM_Reset_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_Reset_r(const int meta_handle, const FT_NVRAM_RESET_REQ* req, const META_NVRAM_Reset_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_Read(const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf, const META_NVRAM_Read_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_Read_r(const int meta_handle, const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf, const META_NVRAM_Read_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_Write(const FT_NVRAM_WRITE_REQ* req, const META_NVRAM_Write_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_Write_r(const int meta_handle, const FT_NVRAM_WRITE_REQ* req, const META_NVRAM_Write_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_GetAllLIDNameLength(int* len);
META_RESULT  __stdcall META_NVRAM_GetAllLIDName(char* buf, const int buf_len, int* NofLID);
META_RESULT  __stdcall META_NVRAM_GetLIDVersion(const char* LID, unsigned short* ver);
META_RESULT  __stdcall META_NVRAM_GetRecStructNameLength(const char* LID, int* len);
META_RESULT  __stdcall META_NVRAM_GetRecStructName(const char* LID, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_GetAllRecFieldNameLength(const char* LID, int* len);
META_RESULT  __stdcall META_NVRAM_GetAllRecFieldName(const char* LID, char* buf, const int buf_len, int* NofField);
META_RESULT  __stdcall META_NVRAM_CheckFieldNameExist(const char* LID, const char* Field, bool* result);
META_RESULT  __stdcall META_NVRAM_GetRecNum(const char* LID, int* num);
META_RESULT  __stdcall META_NVRAM_GetRecLen(const char* LID, int* len);
META_RESULT  __stdcall META_NVRAM_SetRecFieldValue(const char* LID, const char* field, char* buf, const int buf_len, void* value, const int value_len);
META_RESULT  __stdcall META_NVRAM_GetRecFieldValue(const char* LID, const char* field, const char* buf, const int buf_len, void* value, const int value_len);
META_RESULT  __stdcall META_NVRAM_SetRecFieldBitValue(const char* LID, const char* field, const char* bitname, char* buf, const int buf_len, const int bitvalue);
META_RESULT  __stdcall META_NVRAM_GetRecFieldBitValue(const char* LID, const char* field, const char* bitname, const char* buf, const int buf_len, int* bitvalue);
META_RESULT  __stdcall META_NVRAM_QueryRecField(const char* LID, const char* field, unsigned int* fieldSize, unsigned int* fieldOffset);
META_RESULT  __stdcall META_NVRAM_QueryIsLIDExist(const char* LID);
META_RESULT  __stdcall META_NVRAM_ResetToFactoryDefault(unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_ResetToFactoryDefault_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_LockDown(unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_LockDown_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_OTP_LockDown(unsigned int ms_timeout);
META_RESULT  __stdcall META_NVRAM_OTP_LockDown_r(const int meta_handle, unsigned int ms_timeout);
// S/W Change
META_RESULT  __stdcall META_NVRAM_SWC_RetrieveChangeList(void);
META_RESULT  __stdcall META_NVRAM_SWC_RetrieveChangeList_r(const int meta_handle);
META_RESULT  __stdcall META_NVRAM_SWC_UpdateChangeList(void);
META_RESULT  __stdcall META_NVRAM_SWC_UpdateChangeList_r(const int meta_handle);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDCount(int* NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDCount_r(const int meta_handle, int* NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDName(LID_Info* p_ArrayOfLID, const int NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_GetAllChangedLIDName_r(const int meta_handle, LID_Info* p_ArrayOfLID, const int NofLID);
META_RESULT  __stdcall META_NVRAM_SWC_QueryIfLIDChanged(const char* LID, LID_STATUS*  result);
META_RESULT  __stdcall META_NVRAM_SWC_QueryIfLIDChanged_r(const int meta_handle, const char* LID, LID_STATUS*  result);
META_RESULT  __stdcall META_NVRAM_SWC_ImportData(LID_Info* p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
META_RESULT  __stdcall META_NVRAM_SWC_ImportData_r(const int meta_handle, LID_Info* p_import_multiple_lid, int num_of_import_multiple_lid, int import_1st_sys_record_size );
META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare(const char* PathName, int* p_NumOfNewAddLID, int* p_NumOfModifiedLID, int* p_NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Database_Compare_r(const int meta_handle, const char* PathName, int* p_NumOfNewAddLID, int* p_NumOfModifiedLID, int* p_NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Get_Database_Compare_Result(LID_Info* p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info* p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info* p_ArrayOfDeletedLID, const int NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Get_Database_Compare_Result_r(const int meta_handle, LID_Info* p_ArrayOfNewAddLID, const int NumOfNewAddLID, LID_Info* p_ArrayOfModifiedLID, const int NumOfModifiedLID, LID_Info* p_ArrayOfDeletedLID, const int NumOfDeletedLID);
META_RESULT  __stdcall META_NVRAM_SWC_Check_FAT_FreeSpace(const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_SWC_Check_FAT_FreeSpace_r(const int meta_handle, const CB_META_NVRAM_GET_DISK_INFO_CNF  cb, short* token, void* usrData);
META_RESULT  __stdcall META_NVRAM_SWC_Enable_ForceUpgrade(void);
META_RESULT  __stdcall META_NVRAM_SWC_Enable_ForceUpgrade_r(const int meta_handle);
META_RESULT  __stdcall META_NVRAM_SWC_Disable_ForceUpgrade(void);
META_RESULT  __stdcall META_NVRAM_SWC_Disable_ForceUpgrade_r(const int meta_handle);



// AGC path loss
META_RESULT  __stdcall META_NVRAM_agcPathLoss_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_agcPathLoss(const l1cal_agcPathLoss_T* loss, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_agcPathLoss(l1cal_agcPathLoss_T* loss, const char* buf, const int buf_len);
// AGC path loss (middle/low mode)
META_RESULT  __stdcall META_NVRAM_lnaPathLoss_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_lnaPathLoss(const l1cal_lnaPathLoss_T* loss, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_lnaPathLoss(l1cal_lnaPathLoss_T* loss, const char* buf, const int buf_len);
// rampTable
META_RESULT  __stdcall META_NVRAM_rampTable_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_rampTable(const l1cal_rampTable_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable(l1cal_rampTable_T* tbl, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex(const l1cal_rampTable_T_Ex* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex(l1cal_rampTable_T_Ex* tbl, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_rampTable_Len_Ex2(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_rampTable_Ex2(const l1cal_rampTable_T_Ex2* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_rampTable_Ex2(l1cal_rampTable_T_Ex2* tbl, const char* buf, const int buf_len);
// GGE temperature ADC
META_RESULT  __stdcall META_NVRAM_Compose_temperatureADC(const l1cal_temperatureADC_T* dac, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_temperatureADC(l1cal_temperatureADC_T* dac, const char* buf, const int buf_len);

// gain rf table : NVRAM_EF_L1_GAINRF_LID
typedef struct
{
    unsigned char m_ucNumOfGainRf;
    short         gain_rf[FrequencyBandCount][MAX_GAIN_RF_NUM];
} l1cal_gainrf_T;
META_RESULT  __stdcall META_NVRAM_Compose_gainRf(const l1cal_gainrf_T* gainrf, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_gainRf(l1cal_gainrf_T* gainrf, const char* buf, const int buf_len);

// L1Audio Param
META_RESULT  __stdcall META_NVRAM_AudioParam_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam(const l1audio_param_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam(l1audio_param_T* param, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_If_AudioParam_W0547_Support(void);
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0547(const l1audio_param_W0547_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0547(l1audio_param_W0547_T* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0547_45(const l1audio_param_W0547_45_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0547_45(l1audio_param_W0547_45_T* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0712(const l1audio_param_W0712_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0712(l1audio_param_W0712_T* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AC_SWFIR_Param(const l1audio_swfir_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AC_SWFIR_Param(l1audio_swfir_T* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_DMNR_Param(const audio_dual_mic_param_struct* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_DMNR_Param(audio_dual_mic_param_struct* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_Equalizer_Param(const nvram_ef_audio_equalizer_struct* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_Equalizer_Param(nvram_ef_audio_equalizer_struct* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_Bes_EQ_Flexible_Param(const nvram_ef_audio_bes_eq_flexible_struct* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_Bes_EQ_Flexible_Param(nvram_ef_audio_bes_eq_flexible_struct* param, const char* buf, const int buf_len);

// L1Audio Param for WB
typedef struct
{
    short coeff[6][90];
} l1audio_wb_speech_fir_struct;

typedef struct
{
    unsigned short param[8][16];
} l1audio_wb_speech_mode_struct;

META_RESULT  __stdcall META_NVRAM_Compose_AudioFIRParam_WB(const l1audio_wb_speech_fir_struct* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioFIRParam_WB(l1audio_wb_speech_fir_struct* param, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_AudioSpeechParam_WB(const l1audio_wb_speech_mode_struct* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioSpeechParam_WB(l1audio_wb_speech_mode_struct* param, const char* buf, const int buf_len);

typedef struct
{
    unsigned int hsf_coeffs[9][4];
    unsigned int bpf_coeffs[4][6][3];
    /// BesLoudness V3
    unsigned int audio_besloudness_DRC_Forget_Table[9][2];
    unsigned int audio_besloudness_WS_Gain_Max;
    unsigned int audio_besloudness_WS_Gain_Min;
    unsigned int audio_besloudness_Filter_First;
    char         audio_besloudness_Gain_Map_In[5];
    char         audio_besloudness_Gain_Map_Out[5];
} l1audio_besloudness_T;

META_RESULT  __stdcall META_NVRAM_AudioBesLoudNess_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_AudioBesLoudNess(const l1audio_besloudness_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioBesLoudNess(l1audio_besloudness_T* param, const char* buf, const int buf_len);

typedef struct
{
    unsigned int audio_besloudness_spk_hsf_coeffs[2][9][5];
    unsigned int audio_besloudness_spk_bpf_coeffs[6][6][3];
    unsigned int audio_besloudness_spk_lpf_coeffs[6][3];
    unsigned int audio_besloudness_hdp_hsf_coeffs[2][9][5];
    unsigned int audio_besloudness_hdp_bpf_coeffs[6][6][3];
    unsigned int audio_besloudness_hdp_lpf_coeffs[6][3];
    unsigned int audio_besloudness_WS_Gain_Max;
    unsigned int audio_besloudness_WS_Gain_Min;
    unsigned int audio_besloudness_Filter_First;
    unsigned int audio_besloudness_Att_Time;
    unsigned int audio_besloudness_Rel_Time;
    char         audio_besloudness_Gain_Map_In[5];
    char         audio_besloudness_Gain_Map_Out[5];
} l1audio_besloudness_v4_T;

META_RESULT  __stdcall META_NVRAM_Compose_AudioBesLoudNessV4(const l1audio_besloudness_v4_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioBesLoudNessV4(l1audio_besloudness_v4_T* param, const char* buf, const int buf_len);

// interRampData
META_RESULT  __stdcall META_NVRAM_interRampData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_interRampData(const l1cal_interRampData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_interRampData(l1cal_interRampData_T* tbl, const char* buf, const int buf_len);
// crystalAfcData
META_RESULT  __stdcall META_NVRAM_crystalAfcData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_crystalAfcData(const l1cal_crystalAfcData_T* xo_afc, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_crystalAfcData(l1cal_crystalAfcData_T* xo_afc, const char* buf, const int buf_len);
// IMEISV
META_RESULT  __stdcall META_NVRAM_Calculate_IMEI_CD(const char* imei, unsigned short* p_cd);
META_RESULT  __stdcall META_NVRAM_IMEISV_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV(const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_NoCheck(const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_IMEISV_ex(const IMEISV_struct_T*  p_imeisv, char* buf, const int buf_len, bool DoCheckSum);
META_RESULT  __stdcall META_NVRAM_Decompose_IMEISV(IMEISV_struct_T*  p_imeisv, const char* buf, const int buf_len);
// Custom Acoustic Volume
META_RESULT  __stdcall META_NVRAM_CustAcousticVol_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_CustAcousticVol(const CustAcousticVol_T* cust_acoustic_vol, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_CustAcousticVol(CustAcousticVol_T* cust_acoustic_vol, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_16lvlCustAcousticVol(const CustAcousticVol16lvl_T* cust_acoustic_vol, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_16lvlCustAcousticVol(CustAcousticVol16lvl_T* cust_acoustic_vol, const char* buf, const int buf_len);
// RF Module Configuration
META_RESULT  __stdcall META_NVRAM_RFSpecialCoef_Len(int* len);
// Skyworks
META_RESULT  __stdcall META_NVRAM_Compose_SKY74045_RFSpecialCoef(const RF_SKY74045_Coef_T* rf_mod_coef, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_SKY74045_RFSpecialCoef(RF_SKY74045_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_SKY74117_RFSpecialCoef(const RF_SKY74117_Coef_T* rf_mod_coef, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_SKY74117_RFSpecialCoef(RF_SKY74117_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
// MT6139B
META_RESULT  __stdcall META_NVRAM_Compose_MT6139B_RFSpecialCoef(const RF_MT6139B_Coef_T* rf_mod_coef, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_MT6139B_RFSpecialCoef(RF_MT6139B_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
// MT6140
//META_RESULT  __stdcall META_NVRAM_Compose_MT6140tx_RFSpecialCoef(const mt6140tx *rf_mod_coef, char *buf, const int buf_len);
//META_RESULT  __stdcall META_NVRAM_Decompose_MT6140tx_RFSpecialCoef(mt6140tx *rf_mod_coef, const char *buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_Compose_MT6140tx_PaVbias(const mt6140tx* pavbias, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_MT6140tx_PaVbias(mt6140tx* pavbias, const char* buf, const int buf_len);

// Renesas Bright5P
META_RESULT  __stdcall META_NVRAM_Compose_BRIGHT5P_RFSpecialCoef(const RF_BRIGHT5P_Coef_T* rf_mod_coef, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_BRIGHT5P_RFSpecialCoef(RF_BRIGHT5P_Coef_T* rf_mod_coef, const char* buf, const int buf_len);
// EPSK interRampData
META_RESULT  __stdcall META_NVRAM_EPSK_interRampData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_EPSK_interRampData(const l1cal_EPSK_interRampData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_EPSK_interRampData(l1cal_EPSK_interRampData_T* tbl, const char* buf, const int buf_len);
// TX power rollback table
META_RESULT  __stdcall META_NVRAM_TX_Rollback_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_TX_Rollback(const l1cal_tx_power_rollback_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TX_Rollback(l1cal_tx_power_rollback_T* tbl, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_ClosedLoopTXPC_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_ClosedLoopTXPC(const l1cal_txpc_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_ClosedLoopTXPC(l1cal_txpc_T* tbl, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_AvgW_RFSpecialCoef(const RF_AvgW_Coef_T* rf_mod_coef, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AvgW_RFSpecialCoef(RF_AvgW_Coef_T* rf_mod_coef, const char* buf, const int buf_len);

// WiFi
META_RESULT  __stdcall META_NVRAM_WiFi_MacAddress_Len(int* len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_MacAddress(const WiFi_MacAddress_S*  mac, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_MacAddress(WiFi_MacAddress_S*  mac, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_TxPower2400M_Len(int* len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TxPower2400M(const WiFi_TxPower_2400M_S*  txpwr, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TxPower2400M(WiFi_TxPower_2400M_S*  txpwr, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_TxPower5000M_Len(int* len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TxPower5000M(const WiFi_TxPower_5000M_S*  txpwr, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TxPower5000M(WiFi_TxPower_5000M_S*  txpwr, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_DacDcOffset_Len(int* len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_DacDcOffset(const WiFi_DAC_DC_Offset_S*  dac, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_DacDcOffset(WiFi_DAC_DC_Offset_S*  dac, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_ALC_2400M(const WiFi_ALC_2400M_S*  alc, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_ALC_2400M(WiFi_ALC_2400M_S*  alc, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_ALC_2400M_Len(int* len);

META_RESULT  __stdcall META_NVRAM_WiFi_TxALC2400M_Len(int* len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TxALC2400M(const WiFi_TxALC_2400M_S*  txalc, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TxALC2400M(WiFi_TxALC_2400M_S*  txalc, const char* buf, const int buf_len);

#ifdef __META_DLL_WCDMA__
META_RESULT  __stdcall META_NVRAM_3G_Compose_tempdacData(const ul1cal_tempdacData_T*  dac, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_tempdacData(ul1cal_tempdacData_T*  dac, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Compose_pathlossData(const ul1cal_pathlossData_T*  pathloss, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_pathlossData(ul1cal_pathlossData_T*  pathloss, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Compose_txdacData(const ul1cal_txdacData_T*  txdac, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txdacData(ul1cal_txdacData_T*  txdac, const char* buf, const int buf_len);

META_RESULT  __stdcall META_NVRAM_3G_Compose_txdacData_B(const ul1cal_txdacData_T_B* txdac, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txdacData_B(ul1cal_txdacData_T_B*  txdac, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Compose_txPaOctLevData(const ul1cal_txPaOctLevData_T* paoctlevdata, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPaOctLevData(ul1cal_txPaOctLevData_T* paoctlevdata, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Compose_pathlossRxdData(const ul1cal_pathlossRxdData_T*  pathloss, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_pathlossRxdData(ul1cal_pathlossRxdData_T*  pathloss, const char* buf, const int buf_len);

/* PA drift compensation data */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txPaDriftCompData(const ul1Cal_txPaDriftCompData_T* txPaDriftCompData, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPaDriftCompData(ul1Cal_txPaDriftCompData_T* txPaDriftCompData, const char* buf, const int buf_len);

/*20130425 for PRACH TX Temp. Comp. */
META_RESULT  __stdcall META_NVRAM_3G_Compose_txPRACHTempCompData(const ul1cal_txPrachTmCompData_T* txPrachTmCompData, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_3G_Decompose_txPRACHTempCompData(ul1cal_txPrachTmCompData_T* txPrachTmCompData, const char* buf, const int buf_len);

#endif //#ifdef __META_DLL_WCDMA__
//BT
META_RESULT  __stdcall META_NVRAM_BT_Compose_RFMD3500Radio(const nvram_ef_btradio_rfmd3500_struct*  radio, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_RFMD3500Radio(nvram_ef_btradio_rfmd3500_struct*  radio, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Compose_MT6601Radio(const nvram_ef_btradio_mt6601_struct*  radio, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_MT6601Radio(nvram_ef_btradio_mt6601_struct*  radio, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Compose_MT6611Radio(const nvram_ef_btradio_mt6611_struct*  radio, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_MT6611Radio(nvram_ef_btradio_mt6611_struct*  radio, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Compose_MediatekBtChip(const nvram_ef_btradio_mtk_bt_chip_struct*  radio, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_BT_Decompose_MediatekBtChip(nvram_ef_btradio_mtk_bt_chip_struct*  radio, const char* buf, const int buf_len);



// sBBTxParameters
META_RESULT  __stdcall META_NVRAM_BBTXParameters_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_BBTXParameters(const BBTXParameters_T* bbtx, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_BBTXParameters(BBTXParameters_T* bbtx, const char* buf, const int buf_len);

//l1audio_param_W0740_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0740(const l1audio_param_W0740_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0740(l1audio_param_W0740_T* param, const char* buf, const int buf_len);

// l1audio_param_W0809_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_W0809(const l1audio_param_W0809_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_W0809(l1audio_param_W0809_T* param, const char* buf, const int buf_len);

// l1audio_param_EX_T
META_RESULT  __stdcall META_NVRAM_Compose_AudioParam_EX(const l1audio_param_EX_T* param, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_AudioParam_EX(l1audio_param_EX_T* param, const char* buf, const int buf_len);

// ad6546tx
META_RESULT  __stdcall META_NVRAM_Compose_ad6546tx(const ad6546tx* adtx, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_ad6546tx(ad6546tx* adtx, const char* buf, const int buf_len);

//wndrv_cal_setting_trim_thermo_struct
META_RESULT  __stdcall META_NVRAM_TRIM_THERMO_Len(int* len);
META_RESULT  __stdcall META_NVRAM_WiFi_Compose_TrimThermo(const wndrv_cal_setting_trim_thermo_struct*  trim_struct, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_WiFi_Decompose_TrimThermo(wndrv_cal_setting_trim_thermo_struct*  trim_struct, const char* buf, const int buf_len);


// PORT setting
META_RESULT  __stdcall META_NVRAM_PortSetting_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_PortSetting(const port_setting_struct* port_setting, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting(port_setting_struct* port_setting, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Compose_PortSetting_ex(const port_setting_struct* port_setting, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_PortSetting_ex(port_setting_struct* port_setting, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_GetAutoTestiFlagEnumValue(int* value);
META_RESULT  __stdcall META_NVRAM_SetAutoTestiFlag(void);

//META_RESULT  __stdcall META_NVRAM_Read_Ex(const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf);
//META_RESULT  __stdcall META_NVRAM_Read_Ex_r(const int meta_handle, const FT_NVRAM_READ_REQ *req, FT_NVRAM_READ_CNF *cnf);
//META_RESULT  __stdcall META_NVRAM_Write_Ex(const FT_NVRAM_WRITE_REQ *req);
//META_RESULT  __stdcall META_NVRAM_Write_Ex_r(const int meta_handle, const FT_NVRAM_WRITE_REQ *req);

META_RESULT  __stdcall META_NVRAM_Read_Ex( const unsigned int  ms_timeout, const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf);
META_RESULT  __stdcall META_NVRAM_Read_Ex_r( const int meta_handle, unsigned int  ms_timeout, const FT_NVRAM_READ_REQ* req, FT_NVRAM_READ_CNF* cnf);
META_RESULT  __stdcall META_NVRAM_Write_Ex(const unsigned int  ms_timeout, const FT_NVRAM_WRITE_REQ* req, FT_NVRAM_WRITE_CNF* cnf);
META_RESULT  __stdcall META_NVRAM_Write_Ex_r(const int meta_handle, const unsigned int  ms_timeout, const FT_NVRAM_WRITE_REQ* req, FT_NVRAM_WRITE_CNF* cnf);


//---------------------------------------------------------------------------//
//  ASTRONAUT: NVRAM                                                         //
//---------------------------------------------------------------------------//
#ifdef __META_DLL_TD_A__
#define TD_A_CAL_TEMP_SECTION 8
#define TD_A_CAL_UARFCN_SECTION 15
#define META_TD_A_CAL_LNA_MODE_NUM 3
#define META_TD_A_CAL_PA_MODE_NUM 3
#define META_TD_A_CAL_PA_DATA_NUM 4
#define META_TD_A_CAL_HYSTERESIS_NUM 2
#define META_TD_A_CAL_HYSTERESIS_POINTS 2
typedef struct
{
    unsigned short  tempdacData[TD_A_CAL_TEMP_SECTION];
} a_tl1cal_tempdacData_T;
typedef struct
{
    unsigned short initDac;
    unsigned short slope;
} a_tl1cal_afcData_T;
typedef struct
{
    unsigned int capId;
} a_tl1cal_capData_T;
typedef struct
{
    unsigned short freqTable[TD_A_CAL_UARFCN_SECTION];
    short  compByFreq[META_TD_A_CAL_LNA_MODE_NUM][TD_A_CAL_UARFCN_SECTION];
    short  compByTemp[META_TD_A_CAL_LNA_MODE_NUM][TD_A_CAL_TEMP_SECTION];
} a_tl1cal_pathlossData_T;
typedef struct
{
    unsigned short paData[META_TD_A_CAL_PA_MODE_NUM][META_TD_A_CAL_PA_DATA_NUM];
    short          paPower[META_TD_A_CAL_PA_MODE_NUM][META_TD_A_CAL_PA_DATA_NUM];
    unsigned short freqTable[TD_A_CAL_UARFCN_SECTION];
    short          compByFreq[META_TD_A_CAL_PA_MODE_NUM][TD_A_CAL_UARFCN_SECTION];
    short          compByTemp[META_TD_A_CAL_PA_MODE_NUM][TD_A_CAL_TEMP_SECTION];
    unsigned short paSwitch[META_TD_A_CAL_HYSTERESIS_NUM][META_TD_A_CAL_HYSTERESIS_POINTS];
    short          maxPaPower;
    unsigned short maxPaData;
} a_tl1cal_txdacData_T;
typedef struct
{
    short          pdCompMidChannel[3];
    short          pdCompByFreq[15];
} a_tl1cal_txPdData_T;
META_RESULT  __stdcall META_NVRAM_TD_A_TempADC_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TempADC(const a_tl1cal_tempdacData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TempADC(a_tl1cal_tempdacData_T* tbl, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_AFCData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_AFCData(const a_tl1cal_afcData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_AFCData(a_tl1cal_afcData_T* tbl, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_PathLossData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_PathLossData(const a_tl1cal_pathlossData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_PathLossData(a_tl1cal_pathlossData_T* tbl, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_TxDacData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxDacData(const a_tl1cal_txdacData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxDacData(a_tl1cal_txdacData_T* tbl, const char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_TD_A_TxPdData_Len(int* len);
META_RESULT  __stdcall META_NVRAM_Compose_TD_A_TxPdData(const a_tl1cal_txPdData_T* tbl, char* buf, const int buf_len);
META_RESULT  __stdcall META_NVRAM_Decompose_TD_A_TxPdData(a_tl1cal_txPdData_T* tbl, const char* buf, const int buf_len);
#endif // end of #ifdef __META_DLL_TD_A__

//--------------------------------------------------------------------------//
//  Audio Testing                                                           //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  Audio Testing: data structure definition           //
//-----------------------------------------------------//

// audio testing result
typedef enum
{
    AUD_RES_OK = 0,                     // OK
    AUD_RES_FAIL,                       // General Fail
    AUD_RES_BUSY,                       // system busy
    AUD_RES_DISC_FULL,                  // Memory full
    AUD_RES_OPEN_FILE_FAIL,             // open file fail
    AUD_RES_END_OF_FILE,                // play finish
    AUD_ERR_OP_NOT_SUPPORT = 0xFB,       // added by ShuMin, for error handler enhancements// filepath too long
    AUD_ERR_STILL_PLAYING = 0xFC,       // added by ShuMin, because I found target had this error value
    AUD_ERR_PEER_BUF_ERROR = 0xFD,      // peer buf error
    AUD_ERR_FILEPATH_ERROR = 0xFE,      // filepath error
    AUD_ERR_FILEPATH_TOO_LONG = 0xFF    // filepath too long
} AUDIO_RESULT;

// play style enum
typedef enum
{
    FT_L4AUD_AUDIO_PLAY_CRESCENDO = 0,  // Play sound for crescendo.
    FT_L4AUD_AUDIO_PLAY_INFINITE,       // Play sound for infinite.
    FT_L4AUD_AUDIO_PLAY_ONCE,           // Play sound for once.
    FT_L4AUD_AUDIO_PLAY_DESCENDO        // Play sound for descendo.
} AUDIO_PLAY_STYLE;

// default system embeded audio id query
typedef struct
{
    unsigned short      MinRingTone_ID;
    unsigned short      MaxRingTone_ID;
    unsigned short      MinMIDI_ID;
    unsigned short      MaxMIDI_ID;
    unsigned short      MinSound_ID;
    unsigned short      MaxSound_ID;
    AUDIO_RESULT        status;
} Audio_Query_ID_Cnf;

// play default system embeded audio by the given audio id
typedef struct
{
    unsigned short      audio_id;       // default system embeded audio id
    AUDIO_PLAY_STYLE    play_style;     // play style
} Audio_Play_Req;

// play audio from FAT by the given filepath
typedef struct
{
    const char*          fat_filepath;  // filepath on target FAT file system
    AUDIO_PLAY_STYLE    play_style;     // play style
} Audio_Play_ByName_Req;

// play imelody by the buffer from PC side
typedef struct
{
    const char*          imy_buf;       // buffer that stores iMelody content
    unsigned int        imy_buf_len;    // length of buffer
    unsigned char       imy_instrument; // instrument id, 1 ~ 128
    AUDIO_PLAY_STYLE    play_style;     // play style
} Audio_Play_IMY_ByBuf_Req;

// play mp3 from FAT by the given filepath
typedef struct
{
    const char*          fat_filepath;  // filepath on target FAT file system
    AUDIO_PLAY_STYLE    play_style;     // play style
} Audio_MEDIA_Play_Req;

// set volume
typedef struct
{
    unsigned char       volume;         // play volume, 0 ~ 255
} Audio_Set_Volume_Req;

typedef struct
{
    unsigned char       echoflag;           // echofalg true
} Audio_Set_Echo_Req;

typedef struct
{
    unsigned char       modeflag;           // modeflag: 0: normal, 1: headset, 2: loudspeaker  (totally 3 modes)
} Audio_Set_Mode_Req;

typedef struct
{
    unsigned char       type;
    unsigned char       gain;
} Audio_Set_Gain_Req;

typedef struct
{
    short       in_fir_coeffs[45];
    short       out_fir_coeffs[45];
} Audio_Set_LoudSpk_FIR_Coeffs_Req;

typedef struct
{
    unsigned short speech_common_para[12];  // 8 or 12, so at most 12
} Audio_Set_Speech_Common_Req;

typedef struct
{
    unsigned short speech_loudspk_mode_para[16];  // change from 8 to 16, because at most: 16
} Audio_Set_LoudSpk_Mode_Req;

typedef struct
{
    unsigned short Media_Playback_Maximum_Swing;
} Audio_Set_Playback_Maximum_Swing_Req;

typedef struct
{
    short Melody_FIR_Output_Coeff_32k_Tbl1[25];
} Audio_Set_Melody_FIR_Output_Coeffs_Req;

typedef struct
{
    unsigned short speech_common_para[12];
    unsigned short speech_loudspk_mode_para[16];  // change from 8 to 16, because at most: 16
} Audio_Set_Speech_Common_And_Mode_Req;

typedef struct
{
    unsigned short      fre;
    unsigned char       spkgain;
    unsigned char       micgain;
    unsigned short      ulgain;
    unsigned short      dlgain;
    unsigned short      amp;

} Audio_Tone_LoopBackRec_Req;

typedef struct
{
    unsigned int        buffer[2000];
} Audio_Tone_LoopBackRec_Cnf;

typedef struct
{
    unsigned int        buffer[500];
} Audio_Tone_LoopBackRec_Cnf_2K;

typedef struct
{
    unsigned char  m_ucVolume;
    unsigned short m_u2Freq;
} Audio_Set_Freq_Vol_Tone_Req_T;

typedef struct
{
    unsigned char  m_ucMode;
} Audio_Get_Profile_Settings_By_Mode_Req_T;

typedef struct
{
    unsigned char mode;
    unsigned char melody[7];
    unsigned char sound[7];
    unsigned char keytone[7];
    unsigned char speech[7];
    unsigned char mic[7];
    unsigned char sidetone;
    unsigned char max_melody_volume_gain;
    unsigned char melody_volume_gain_step;
    unsigned char tv_out_volume_gain[MAX_VOL_LEVEL];  // 7 here

} Audio_Get_Profile_Settings_By_Mode_Cnf_T;

typedef struct
{
    unsigned char mode;
    unsigned char melody[7];
    unsigned char sound[7];
    unsigned char keytone[7];
    unsigned char speech[7];
    unsigned char mic[7];
    unsigned char sidetone;
    unsigned char max_melody_volume_gain;
    unsigned char melody_volume_gain_step;
    unsigned char tv_out_volume_gain[MAX_VOL_LEVEL];  // 7 here

} Audio_Set_Profile_Settings_By_Mode_Req_T;

typedef struct
{

    unsigned short m_u2FailReason;  // possible fail resons

} Audio_Set_Profile_Settings_By_Mode_Cnf_T;


typedef struct
{

    unsigned short m_u2FailReason;  // possible fail resons, (2 means the format is not matched with Target side)

} Audio_Set_Param_Cnf_T;

//-----------------------------------------------------//
//  Audio Testing: callback function definition        //
//-----------------------------------------------------//
typedef void (__stdcall* META_AUDIO_QUERY_ID_CNF)(const Audio_Query_ID_Cnf* cnf, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_PLAY_CNF)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_PLAY_BYNAME_CNF)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_PLAY_IMY_BYBUF_CNF)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_PLAY_OVER_IND)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_STOP_CNF)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_MEDIA_PLAY_CNF)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_MEDIA_PLAY_OVER_IND)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_MEDIA_STOP_CNF)(const AUDIO_RESULT status, const short token, void* usrData);
typedef void (__stdcall* META_AUDIO_SET_VOLUME_CNF)(const AUDIO_RESULT status, const short token, void* usrData);

//-----------------------------------------------------//
//  Audio Testing: exported function definition        //
//-----------------------------------------------------//
META_RESULT  __stdcall META_Audio_Query_ID(const META_AUDIO_QUERY_ID_CNF  cnf_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Query_ID_r(const int meta_handle, const META_AUDIO_QUERY_ID_CNF  cnf_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Play(const Audio_Play_Req*  req, const META_AUDIO_PLAY_CNF cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Play_r(const int meta_handle, const Audio_Play_Req*  req, const META_AUDIO_PLAY_CNF cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Play_ByName(const Audio_Play_ByName_Req*  req, const META_AUDIO_PLAY_BYNAME_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Play_ByName_r(const int meta_handle, const Audio_Play_ByName_Req*  req, const META_AUDIO_PLAY_BYNAME_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Play_IMY_ByBuf(const Audio_Play_IMY_ByBuf_Req*  req, const META_AUDIO_PLAY_IMY_BYBUF_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Play_IMY_ByBuf_r(const int meta_handle, const Audio_Play_IMY_ByBuf_Req*  req, const META_AUDIO_PLAY_IMY_BYBUF_CNF  cnf_cb, const META_AUDIO_PLAY_OVER_IND  ind_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Stop(const META_AUDIO_STOP_CNF  cnf_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Stop_r(const int meta_handle, const META_AUDIO_STOP_CNF  cnf_cb, short* token, void* usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Play(const Audio_MEDIA_Play_Req  *req, const META_AUDIO_MEDIA_PLAY_CNF  cnf_cb, const META_AUDIO_MEDIA_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Play_r(const int meta_handle, const Audio_MEDIA_Play_Req  *req, const META_AUDIO_MEDIA_PLAY_CNF  cnf_cb, const META_AUDIO_MEDIA_PLAY_OVER_IND  ind_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Stop(const META_AUDIO_MEDIA_STOP_CNF  cnf_cb, short *token, void *usrData);
//META_RESULT  __stdcall META_Audio_MEDIA_Stop_r(const int meta_handle, const META_AUDIO_MEDIA_STOP_CNF  cnf_cb, short *token, void *usrData);
META_RESULT  __stdcall META_Audio_Set_Volume(const Audio_Set_Volume_Req*  req, const META_AUDIO_SET_VOLUME_CNF  cnf_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Set_Volume_r(const int meta_handle, const Audio_Set_Volume_Req*  req, const META_AUDIO_SET_VOLUME_CNF  cnf_cb, short* token, void* usrData);
META_RESULT  __stdcall META_Audio_Set_Echo_Loop(unsigned int  ms_timeout, const Audio_Set_Echo_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Echo_Loop_r(const int meta_handle, unsigned int  ms_timeout , const Audio_Set_Echo_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Mode(unsigned int  ms_timeout, const Audio_Set_Mode_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Mode_r(const int meta_handle, unsigned int  ms_timeout , const Audio_Set_Mode_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Gain(unsigned int  ms_timeout, const Audio_Set_Gain_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Gain_r(const int meta_handle, unsigned int  ms_timeout , const Audio_Set_Gain_Req*  req);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec(unsigned int  ms_timeout, Audio_Tone_LoopBackRec_Req*  req, Audio_Tone_LoopBackRec_Cnf* cnf);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_r(const int meta_handle, unsigned int  ms_timeout , Audio_Tone_LoopBackRec_Req*  req, Audio_Tone_LoopBackRec_Cnf* cnf);
//  for loud-speaker mode
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K(unsigned int  ms_timeout, Audio_Tone_LoopBackRec_Req*  req, Audio_Tone_LoopBackRec_Cnf_2K* cnf);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K_r(const int meta_handle, unsigned int  ms_timeout , Audio_Tone_LoopBackRec_Req*  req, Audio_Tone_LoopBackRec_Cnf_2K* cnf);
// for normal mode
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K_Normal(unsigned int  ms_timeout, Audio_Tone_LoopBackRec_Req*  req, Audio_Tone_LoopBackRec_Cnf_2K* cnf);
META_RESULT  __stdcall META_Audio_Tone_Loop_Back_Rec_2K_Normal_r(const int meta_handle, unsigned int  ms_timeout , Audio_Tone_LoopBackRec_Req*  req, Audio_Tone_LoopBackRec_Cnf_2K* cnf);

META_RESULT  __stdcall META_Audio_Set_LoudSpk_FIR_Coeffs(unsigned int  ms_timeout, const Audio_Set_LoudSpk_FIR_Coeffs_Req*  req);
META_RESULT  __stdcall META_Audio_Set_LoudSpk_FIR_Coeffs_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_LoudSpk_FIR_Coeffs_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common(unsigned int  ms_timeout, const Audio_Set_Speech_Common_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_Speech_Common_Req*  req);
META_RESULT  __stdcall META_Audio_Set_LoudSpk_Mode(unsigned int  ms_timeout, const Audio_Set_LoudSpk_Mode_Req*  req);
META_RESULT  __stdcall META_Audio_Set_LoudSpk_Mode_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_LoudSpk_Mode_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Playback_Maximum_Swing(unsigned int  ms_timeout, const Audio_Set_Playback_Maximum_Swing_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Playback_Maximum_Swing_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_Playback_Maximum_Swing_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Melody_FIR_Output_Coeffs(unsigned int  ms_timeout, const Audio_Set_Melody_FIR_Output_Coeffs_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Melody_FIR_Output_Coeffs_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_Melody_FIR_Output_Coeffs_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common_And_Mode(unsigned int  ms_timeout, const Audio_Set_Speech_Common_And_Mode_Req*  req);
META_RESULT  __stdcall META_Audio_Set_Speech_Common_And_Mode_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_Speech_Common_And_Mode_Req*  req);

META_RESULT  __stdcall META_Audio_Play_Freq_Vol_Tone(unsigned int  ms_timeout, const Audio_Set_Freq_Vol_Tone_Req_T*  req);
META_RESULT  __stdcall META_Audio_Play_Freq_Vol_Tone_r(const int meta_handle, unsigned int  ms_timeout, const Audio_Set_Freq_Vol_Tone_Req_T*  req);
META_RESULT  __stdcall META_Audio_Stop_Freq_Vol_Tone(unsigned int  ms_timeout);
META_RESULT  __stdcall META_Audio_Stop_Freq_Vol_Tone_r(const int meta_handle, unsigned int  ms_timeout);


META_RESULT  __stdcall META_Audio_Get_Audio_Profile_Settings(unsigned int ms_timeout,
        Audio_Get_Profile_Settings_By_Mode_Req_T* req,
        Audio_Get_Profile_Settings_By_Mode_Cnf_T* cnf);
META_RESULT  __stdcall META_Audio_Get_Audio_Profile_Settings_r(const int meta_handle,
        unsigned int  ms_timeout,
        Audio_Get_Profile_Settings_By_Mode_Req_T* req,
        Audio_Get_Profile_Settings_By_Mode_Cnf_T* cnf);
META_RESULT  __stdcall META_Audio_Set_Audio_Profile_Settings(unsigned int ms_timeout,
        Audio_Set_Profile_Settings_By_Mode_Req_T* req,
        Audio_Set_Profile_Settings_By_Mode_Cnf_T* cnf);
META_RESULT  __stdcall META_Audio_Set_Audio_Profile_Settings_r(const int meta_handle,
        unsigned int  ms_timeout,
        Audio_Set_Profile_Settings_By_Mode_Req_T* req,
        Audio_Set_Profile_Settings_By_Mode_Cnf_T* cnf);

META_RESULT  __stdcall META_Audio_Get_Audio_Param_Settings_0809(unsigned int ms_timeout,
        l1audio_param_W0809_T* cnf);
META_RESULT  __stdcall META_Audio_Get_Audio_Param_Settings_0809_r(const int meta_handle,
        unsigned int  ms_timeout,
        l1audio_param_W0809_T* cnf) ;

META_RESULT  __stdcall META_Audio_Set_Audio_Param_Settings_0809(unsigned int ms_timeout,
        l1audio_param_W0809_T* req,
        Audio_Set_Param_Cnf_T* cnf);

META_RESULT  __stdcall META_Audio_Set_Audio_Param_Settings_0809_r(const int meta_handle,
        unsigned int  ms_timeout,
        l1audio_param_W0809_T* req,
        Audio_Set_Param_Cnf_T* cnf);


META_RESULT  __stdcall META_Audio_Set_Output_Dev(unsigned int ms_timeout,
        unsigned char* output_dev_req);

META_RESULT  __stdcall META_Audio_Set_Output_Dev_r(const int meta_handle,
        unsigned int ms_timeout,
        unsigned char* output_dev_req);
META_RESULT  __stdcall META_Audio_Set_Output_Vol(unsigned int ms_timeout,
        unsigned char* output_vol);

META_RESULT  __stdcall META_Audio_Set_Output_Vol_r(const int meta_handle,
        unsigned int ms_timeout,
        unsigned char* output_vol);


typedef struct
{
    unsigned char          u1_set_output_device;
    unsigned short         u2_digital_gain;
} Audio_SetOutputDevEx_Req_T;


META_RESULT  __stdcall META_Audio_Set_Output_Dev_With_DG(unsigned int ms_timeout,
        Audio_SetOutputDevEx_Req_T* req);

META_RESULT  __stdcall META_Audio_Set_Output_Dev_With_DG_r(const int meta_handle,
        unsigned int ms_timeout,
        Audio_SetOutputDevEx_Req_T* req);



META_RESULT  __stdcall META_Audio_FreeMemory(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_FreeMemory_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_PlayCurMemContent(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_PlayCurMemContent_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_StopPlaying(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_StopPlaying_r(const int meta_handle, unsigned int ms_timeout);


typedef int (__stdcall* CALLBACK_META_AUDIO_PROGRESS)(unsigned char percent, int sent_bytes, int total_bytes, const short token, void* usr_arg);

typedef struct
{

    bool bCheckHdr;
    unsigned int u4StartFilePos; // only valid when bCheckHdr = false;

    char* pFilePath;

    bool bIsStereo;
    char i1BitPerSample;
    unsigned short u2SampleFreq;
    bool  bForceVoice;       // always set true?

    CALLBACK_META_AUDIO_PROGRESS  cb_progress;
    void*  cb_progress_arg;


} Audio_Play_Wave_File_REQ_T;



META_RESULT __stdcall META_Audio_Play_Wave_File(unsigned int ms_timeout, Audio_Play_Wave_File_REQ_T* req, int* pStopFlag, bool* bSaveAllOnTargetMem);
META_RESULT __stdcall META_Audio_Play_Wave_File_r(const int meta_handle, unsigned int ms_timeout, Audio_Play_Wave_File_REQ_T* req, int* pStopFlag, bool* bSaveAllOnTargetMem);


typedef enum
{
    AC_Filter_DSP_FIR = 0
                        , AC_Filter_HW_FIR
    , AC_Filter_DSP_IIR
    , AC_Filter_UNKNOWN = 100
} E_Audio_Compensation_Filter_Type;

META_RESULT  __stdcall META_Audio_GetACFilterType(unsigned int ms_timeout, E_Audio_Compensation_Filter_Type* p_type);
META_RESULT  __stdcall META_Audio_GetACFilterType_r(const int meta_handle, unsigned int ms_timeout, E_Audio_Compensation_Filter_Type* p_type);

typedef struct
{
    unsigned char u1_ac_mode; // loudspeaker: 0, normal: 1
    short i2_ac_coef[45];
} Audio_Compensation_Filter_Coef;

META_RESULT  __stdcall META_Audio_SetACFilterCoef(unsigned int ms_timeout, const Audio_Compensation_Filter_Coef* p_req);
META_RESULT  __stdcall META_Audio_SetACFilterCoef_r(const int meta_handle, unsigned int ms_timeout, const Audio_Compensation_Filter_Coef* p_req);
META_RESULT  __stdcall META_Audio_GetGainTypeSupport(unsigned int ms_timeout);
META_RESULT  __stdcall META_Audio_GetGainTypeSupport_r(const int meta_handle, unsigned int ms_timeout);

typedef struct
{
    short          i2MaxGain;
    unsigned short u2Step;
    unsigned short u2TotalLevel;
} Audio_Ex_GetDLGainCap_T;

typedef struct
{
    unsigned int              u4_dl_buf_type_by_mode[4]; //0:handset, 1:headset, 2: handsfree, 3: bt earphone
    Audio_Ex_GetDLGainCap_T   buf_info[2];               // 0: audio buffer, 1: voice buffer, 2: unknown
    bool                      b_digital_gain_support;


} Audio_Ex_GetDLGainCap_CNF_T; // stored in peer buffer


META_RESULT __stdcall META_Audio_EX_GetDLGainCapability(const unsigned int ms_timeout, Audio_Ex_GetDLGainCap_CNF_T* cnf);
META_RESULT __stdcall META_Audio_EX_GetDLGainCapability_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_GetDLGainCap_CNF_T* cnf);


typedef struct
{

    unsigned int     iir_coeff_int[4][6][3];
    unsigned int     hsf_coeff_int[9][4];
} Audio_Ex_SetACFToTarget_REQ_T;

META_RESULT __stdcall META_Audio_EX_SetACFIIRToTarget(const unsigned int ms_timeout, Audio_Ex_SetACFToTarget_REQ_T* req);
META_RESULT __stdcall META_Audio_EX_SetACFIIRToTarget_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_SetACFToTarget_REQ_T* req);

typedef struct
{
    /// the buffer for the compose function sink
    char         buffer[2000];
    /// the buffer length (must be retrieved by META_NVRAM_AudioBesLoudNess_Len)
    unsigned int bufferLength;
} Audio_Ex_SetACFToTarget_REQ_EX_T;

META_RESULT __stdcall META_Audio_EX_SetACFIIRToTargetEx(const unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T* req);
META_RESULT __stdcall META_Audio_EX_SetACFIIRToTargetEx_r(const int meta_handle, const unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T* req);

META_RESULT  __stdcall META_Audio_EX_SetACFilterCoefEx(unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T* p_req);
META_RESULT  __stdcall META_Audio_EX_SetACFilterCoefEx_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_SetACFToTarget_REQ_EX_T* p_req);

META_RESULT __stdcall META_Audio_EX_QueryBesLoudnessVersion(unsigned int ms_timeout, unsigned int* version);
META_RESULT __stdcall META_Audio_EX_QueryBesLoudnessVersion_r(const int meta_handle, unsigned int ms_timeout, unsigned int* version);

#define META_NVRAM_DESC_DEPTH    3
#define META_NVRAM_DESC_LENGTH   255
#define META_NVRAM_DESC_NUM      255

typedef struct
{
    unsigned int    u4ByteOffset;
    unsigned int    u4Length;  // unit: u1ElementSize, not bytes!
    unsigned char   u1ElementSize; // unit: bytes
    int             i4ElementNum; // element number
    unsigned char   u1ValidDepth;
    char            desc[META_NVRAM_DESC_DEPTH][META_NVRAM_DESC_LENGTH];

} meta_nvram_lid_desc_entry;

typedef struct
{
    int valid_num;
    int struct_size;
    meta_nvram_lid_desc_entry list[META_NVRAM_DESC_NUM];
} meta_nvram_lid_desc_t;

META_RESULT __stdcall META_NVRAM_AudioGainTableDescription(meta_nvram_lid_desc_t* pDescList);
META_RESULT __stdcall META_NVRAM_AudioGainTable_Len(int* len);

//--------------------------------------------------------------------------//
//  BaseBand Testing                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BaseBand Testing: data structure definition        //
//-----------------------------------------------------//
typedef struct
{
    unsigned int    addr;       // The address of register that is to be read.
} RegRead_Req;

typedef struct
{
    unsigned short  value;      // The read back value
    unsigned char   status;     // 0: success, others: read register fail.
} RegRead_Cnf;

typedef struct
{
    unsigned int    addr;       // The address of register that is to be written.
    unsigned short  value;      // The value that is to be written.
} RegWrite_Req;

typedef struct
{
    unsigned char   status;     // 0: success, others: write register fail.
} RegWrite_Cnf;

typedef struct
{
    unsigned char   channel;    // ADC channel number.
    unsigned short  Meacount;   // Number of measure times.
} ADCMeaData_Req;

typedef struct
{
    unsigned int    value;      // ADC value, it a sum value of each measurement data.
    unsigned char   status;     // 0: success, others: get ADC measurement fail.
} ADCMeaData_Cnf;

//-----------------------------------------------------//
//  BaseBand Testing: callback function definition     //
//-----------------------------------------------------//
typedef void (__stdcall* META_BB_READREG_CNF)(const RegRead_Cnf* result, const short token, void* usrData);
typedef void (__stdcall* META_BB_WRITEREG_CNF)(const RegWrite_Cnf* result, const short token, void* usrData);
typedef void (__stdcall* META_BB_ADCGETMEADATA_CNF)(const ADCMeaData_Cnf* result, const short token, void* usrData);

//-----------------------------------------------------//
//  BaseBand Testing: exported function definition     //
//-----------------------------------------------------//
META_RESULT  __stdcall META_BB_RegRead(const RegRead_Req* req, const META_BB_READREG_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_BB_RegRead_r(const int meta_handle, const RegRead_Req* req, const META_BB_READREG_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_BB_RegWrite(const RegWrite_Req* req, const META_BB_WRITEREG_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_BB_RegWrite_r(const int meta_handle, const RegWrite_Req* req, const META_BB_WRITEREG_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_PMIC_RegRead(unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
META_RESULT  __stdcall META_PMIC_RegRead_r(const int meta_handle, unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
META_RESULT  __stdcall META_PMIC_RegWrite(unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
META_RESULT  __stdcall META_PMIC_RegWrite_r(const int meta_handle, unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData(const ADCMeaData_Req* req, const META_BB_ADCGETMEADATA_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_r(const int meta_handle, const ADCMeaData_Req* req, const META_BB_ADCGETMEADATA_CNF cb, short* token, void* usrData);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_Ex(const unsigned int ms_timeout, const ADCMeaData_Req* req, ADCMeaData_Cnf* cnf);
META_RESULT  __stdcall META_BB_ADCGetMeaSumData_Ex_r(const int meta_handle, const unsigned int ms_timeout, const ADCMeaData_Req* req, ADCMeaData_Cnf* cnf);
META_RESULT  __stdcall META_BB_RegRead_Ex(unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
META_RESULT  __stdcall META_BB_RegRead_Ex_r(const int meta_handle, unsigned int ms_timeout, const RegRead_Req* req, RegRead_Cnf* cnf);
META_RESULT  __stdcall META_BB_RegWrite_Ex(unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
META_RESULT  __stdcall META_BB_RegWrite_Ex_r(const int meta_handle, unsigned int ms_timeout, const RegWrite_Req* req, RegWrite_Cnf* cnf);
//----------------------------------------------------//
//                     RTC control                    //
//----------------------------------------------------//
typedef enum
{
    SET_DL_FLAG = 0,      // set brom download flag
    CLR_DL_FLAG = 1,      // clear download flag
    SET_BL_DL_FLAG = 2  // set bootloader download flag
} SYSTEM_EX_CMD;

META_RESULT  __stdcall META_MISC_EX_SetCommandToSystem(unsigned int ms_timeout, const SYSTEM_EX_CMD command);
META_RESULT  __stdcall META_MISC_EX_SetCommandToSystem_r(const int meta_handle, unsigned int ms_timeout, const SYSTEM_EX_CMD command);

//--------------------------------------------------------------------------//
//  FAT Access                                                              //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  FAT Access: data structure definition              //
//-----------------------------------------------------//
typedef enum
{
    FAT_OPEN_READ = 0,
    FAT_OPEN_WRITE
} FAT_OPEN_MODE;

typedef enum
{
    FAT_FIND_FILE = 0,
    FAT_FIND_FILE_RECURSIVE,
    FAT_FIND_DIR_RECURSIVE
} FAT_FIND_MODE;

typedef enum
{
    FAT12 = 0,
    FAT16,
    FAT32
} FAT_TYPE;

typedef struct
{
    FAT_TYPE        Type;
    unsigned int    SectorsPerCluster;
    unsigned int    TotalSize;
    unsigned int    FreeSpace;
} FAT_DiskInfo_T;

typedef struct
{
    FAT_TYPE        Type;
    unsigned int    SectorsPerCluster;
    unsigned int    TotalSize_high;
    unsigned int    FreeSpace_high;
    unsigned int    TotalSize_low;
    unsigned int    FreeSpace_low;
} FAT_DiskInfo_EX_T;

typedef struct
{
    char m_cDriveLetter;   // Target FAT disk drive letter such as: 'C'
    char* m_pcfilepath;    // File path of the file we intend to write into target FAT

} FAT_FILE_INFO_REQ_T;

typedef struct
{
    FAT_FILE_INFO_REQ_T req;
    /// target side file path to check whether existing file presents
    const char* targetFilePath;
} FAT_FILE_INFO_REQ_EX_T;

typedef struct
{
    WCHAR m_wDriveLetter;   // Target FAT disk drive letter such as: 'C'
    WCHAR* m_pwcFilePath;   // File path of the file we intend to write into target FAT
} FAT_UTF_FILE_INFO_REQ_T;

typedef struct
{
    FAT_UTF_FILE_INFO_REQ_T req;
    /// target side file path to check whether existing file presents
    const WCHAR* pwcTargetFilePath;
} FAT_UTF_FILE_INFO_REQ_EX_T;
//-----------------------------------------------------/n
//  FAT Access: callback function definition           //
//-----------------------------------------------------//
typedef int (__stdcall* CALLBACK_META_FAT_PROGRESS)(unsigned char percent, int sent_bytes, int total_bytes, const short token, void* usr_arg);

//-----------------------------------------------------//
//  FAT Access: exported function definition           //
//-----------------------------------------------------//
META_RESULT  __stdcall META_FAT_Open(const char* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_Open_r(const int meta_handle, const char* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_Close(int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_Close_r(const int meta_handle, int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_GetFileSize(const int fs_handle, int* filesize, short* p_token);
META_RESULT  __stdcall META_FAT_GetFileSize_r(const int meta_handle, const int fs_handle, int* filesize, short* p_token);
META_RESULT  __stdcall META_FAT_Read(const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Read_r(const int meta_handle, const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Write(const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Write_r(const int meta_handle, const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Read_To_File(const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Read_To_File_r(const int meta_handle, const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Write_By_File(const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Write_By_File_r(const int meta_handle, const int fs_handle, const char* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_Delete(const char* fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_Delete_r(const int meta_handle, const char* fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_Move(const char* fat_filepath, const char* new_fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_Move_r(const int meta_handle, const char* fat_filepath, const char* new_fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_Find_Start(const char* fat_base_dir, const char* fat_find_pattern, FAT_FIND_MODE     find_mode, int* p_find_handle, short* p_token);
META_RESULT  __stdcall META_FAT_Find_Start_r(const int meta_handle, const char* fat_base_dir, const char* fat_find_pattern, FAT_FIND_MODE    find_mode, int* p_find_handle, short* p_token);
META_RESULT  __stdcall META_FAT_Find_Head(int find_handle);
META_RESULT  __stdcall META_FAT_Find_Prev(int find_handle);
META_RESULT  __stdcall META_FAT_Find_Next(int find_handle);
META_RESULT  __stdcall META_FAT_Find_GetFileInfo(int find_handle, char* p_filepath, const int filepath_len, int* p_filesize);
META_RESULT  __stdcall META_FAT_Find_Close(int* p_find_handle);
META_RESULT  __stdcall META_FAT_GetDiskInfo(const char DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_GetDiskInfo_r(const int meta_handle, const char DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_GetDiskInfo_Ex(const char DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_GetDiskInfo_Ex_r(const int meta_handle, const char DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_RemoveDir(const char* fat_dirpath);
META_RESULT  __stdcall META_FAT_RemoveDir_r(const int meta_handle, const char* fat_dirpath);

META_RESULT __stdcall META_FAT_CheckEnoughSpace(FAT_FILE_INFO_REQ_T* req);
META_RESULT __stdcall META_FAT_CheckEnoughSpace_r(const int meta_handle, FAT_FILE_INFO_REQ_T* req);
META_RESULT __stdcall META_FAT_CheckEnoughSpaceEx(FAT_FILE_INFO_REQ_EX_T* req_ex);
META_RESULT __stdcall META_FAT_CheckEnoughSpaceEx_r(const int meta_handle, FAT_FILE_INFO_REQ_EX_T* req_ex);

META_RESULT  __stdcall META_FAT_Read_To_File_Ex(const int fs_handle, const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag) ;

META_RESULT  __stdcall META_FAT_Read_To_File_Ex_r(const int meta_handle, const int fs_handle,
        const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag);

META_RESULT  __stdcall META_FAT_Write_By_File_Ex(const int fs_handle,
        const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopfalg);

META_RESULT  __stdcall META_FAT_Write_By_File_Ex_r(const int meta_handle,
        const int fs_handle,
        const char* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopflag);

META_RESULT  __stdcall META_FAT_CopyDirFromTarget(const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_CopyDirFromTarget_r(const int meta_handle, const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_CopyDirFromPc(const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_CopyDirFromPc_r(const int meta_handle, const char* dstDir, unsigned int dstDirLength, const char* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_RemoveDirEx(const char* fat_dirpath, int* p_stopflag);
META_RESULT  __stdcall META_FAT_RemoveDirEx_r(const int meta_handle, const char* fat_dirpath, int* p_stopflag);
META_RESULT  __stdcall META_FAT_DeleteEx(const char* fat_filepath, short* p_token, int* p_stopflag);
META_RESULT  __stdcall META_FAT_DeleteEx_r(const int meta_handle, const char* fat_filepath, short* p_token, int* p_stopflag);
/*  NOR_DRIVE = 1,
    NAND_DRIVE=2,
    CARD_DRIVE = 3,
    EXTERNAL_DRIVE = 4
*/
META_RESULT  __stdcall META_FAT_GetDriveType(unsigned int ms_timeout, const char DriveLetter, int* p_DriveType);
META_RESULT  __stdcall META_FAT_GetDriveType_r(const int meta_handle, unsigned int ms_timeout, const char DriveLetter, int* p_DriveType);


//-----------------------------------------------------------------------------
// FAT UTF(Unicode) API
//-----------------------------------------------------------------------------
META_RESULT  __stdcall META_FAT_UTF_Open(const WCHAR* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Open_r(const int meta_handle, const WCHAR* fat_filepath, FAT_OPEN_MODE  mode, int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Close(int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Close_r(const int meta_handle, int* fs_handle, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_GetFileSize(const int fs_handle, int* filesize, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_GetFileSize_r(const int meta_handle, const int fs_handle, int* filesize, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Read(const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Read_r(const int meta_handle, const int fs_handle, char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Write(const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Write_r(const int meta_handle, const int fs_handle, const char* buf, const int buf_len, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Read_To_File(const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Read_To_File_r(const int meta_handle, const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Write_By_File(const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Write_By_File_r(const int meta_handle, const int fs_handle, const WCHAR* local_filepath, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Delete(const WCHAR* fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Delete_r(const int meta_handle, const WCHAR* fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Move(const WCHAR* fat_filepath, const WCHAR* new_fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Move_r(const int meta_handle, const WCHAR* fat_filepath, const WCHAR* new_fat_filepath, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Find_Start(const WCHAR* fat_base_dir, const WCHAR* fat_find_pattern, FAT_FIND_MODE find_mode, int* p_find_handle, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Find_Start_r(const int meta_handle, const WCHAR* fat_base_dir, const WCHAR* fat_find_pattern, FAT_FIND_MODE find_mode, int* p_find_handle, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_Find_Head(int find_handle);
META_RESULT  __stdcall META_FAT_UTF_Find_Prev(int find_handle);
META_RESULT  __stdcall META_FAT_UTF_Find_Next(int find_handle);
META_RESULT  __stdcall META_FAT_UTF_Find_GetFileInfo(int find_handle, WCHAR* p_filepath, const int filepath_len, int* p_filesize);
META_RESULT  __stdcall META_FAT_UTF_Find_Close(int* p_find_handle);
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo(const WCHAR DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo_r(const int meta_handle, const WCHAR DriveLetter, FAT_DiskInfo_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo_Ex(const WCHAR DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_GetDiskInfo_Ex_r(const int meta_handle, const WCHAR DriveLetter, FAT_DiskInfo_EX_T*  p_DiskInfo, short* p_token);
META_RESULT  __stdcall META_FAT_UTF_RemoveDir(const WCHAR* fat_dirpath);
META_RESULT  __stdcall META_FAT_UTF_RemoveDir_r(const int meta_handle, const WCHAR* fat_dirpath);

META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpace(FAT_FILE_INFO_REQ_T* req);
META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpace_r(const int meta_handle, FAT_UTF_FILE_INFO_REQ_T* req);
META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpaceEx(FAT_FILE_INFO_REQ_EX_T* req_ex);
META_RESULT __stdcall META_FAT_UTF_CheckEnoughSpaceEx_r(const int meta_handle, FAT_UTF_FILE_INFO_REQ_EX_T* req_ex);

META_RESULT  __stdcall META_FAT_UTF_Read_To_File_Ex(const int fs_handle, const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag) ;

META_RESULT  __stdcall META_FAT_UTF_Read_To_File_Ex_r(const int meta_handle, const int fs_handle,
        const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg, short* p_token,
        int*   p_stopflag);

META_RESULT  __stdcall META_FAT_UTF_Write_By_File_Ex(const int fs_handle,
        const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopfalg);

META_RESULT  __stdcall META_FAT_UTF_Write_By_File_Ex_r(const int meta_handle,
        const int fs_handle,
        const WCHAR* filepath,
        CALLBACK_META_FAT_PROGRESS  cb_progress,
        void*  cb_progress_arg,
        short* p_token,
        int* p_stopflag);

META_RESULT  __stdcall META_FAT_UTF_CopyDirFromTarget(const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromTarget_r(const int meta_handle, const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromPc(const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS  cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_CopyDirFromPc_r(const int meta_handle, const WCHAR* dstDir, unsigned int dstDirLength, const WCHAR* srcDir, unsigned int srcDirLength, CALLBACK_META_FAT_PROGRESS cb_progress, void* cb_progress_arg, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_RemoveDirEx(const WCHAR* fat_dirpath, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_RemoveDirEx_r(const int meta_handle, const WCHAR* fat_dirpath, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_DeleteEx(const WCHAR* fat_filepath, short* p_token, int* p_stopflag);
META_RESULT  __stdcall META_FAT_UTF_DeleteEx_r(const int meta_handle, const WCHAR* fat_filepath, short* p_token, int* p_stopflag);
/*  NOR_DRIVE = 1,
    NAND_DRIVE=2,
    CARD_DRIVE = 3,
    EXTERNAL_DRIVE = 4
*/
META_RESULT  __stdcall META_FAT_UTF_GetDriveType(unsigned int ms_timeout, const WCHAR DriveLetter, int* p_DriveType);
META_RESULT  __stdcall META_FAT_UTF_GetDriveType_r(const int meta_handle, unsigned int ms_timeout, const WCHAR DriveLetter, int* p_DriveType);



META_RESULT  __stdcall META_Check_ULC_support(unsigned int ms_timeout);
META_RESULT  __stdcall META_Check_ULC_support_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_Check_SmartPhoneModem_support(unsigned int ms_timeout);
META_RESULT  __stdcall META_Check_SmartPhoneModem_support_r(const int meta_handle, unsigned int ms_timeout);


typedef enum
{
    META_VERSION_USER_DEFINE
    , META_VERSION_META_DLL_UTIL_VER
    , VER_TYPE_END

} META_VERSION_TYPE;

typedef struct
{

    META_VERSION_TYPE   m_eVerType;

//  bool                b_AssertWhenVerCheckFail;  // will cause assert when version check fail

    unsigned int        m_u4MainVersion;  // valid when m_eVerType = META_VERSION_USER_DEFINE
    unsigned int        m_u4MinorVersion; // valid when m_eVerType = META_VERSION_USER_DEFINE
    unsigned int        m_u4BuildNum;     // valid when m_eVerType = META_VERSION_USER_DEFINE


} META_UTIL_CHECK_TARGET_VER_REQ_T;

typedef struct
{
    bool         m_bCheckPass;
    unsigned int m_u4TargetMainVersion;
    unsigned int m_u4TargetMinorVersion;
    unsigned int m_u4TargetBuildNum;
} META_UTIL_CHECK_TARGET_VER_CNF_T;

typedef struct
{
    bool  b_TargetAssertCheckFlag;
    bool  b_SetCurRecvMsgTimes;
    unsigned char m_u1CurRecvMsgTimes;  // valid when b_SetCurRecvMsgTimes = true
} META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T;


META_RESULT  __stdcall META_Util_CheckTargetRequiredVersion(unsigned int ms_timeout, const META_UTIL_CHECK_TARGET_VER_REQ_T* req, META_UTIL_CHECK_TARGET_VER_CNF_T* cnf );
META_RESULT  __stdcall META_Util_CheckTargetRequiredVersion_r(const int meta_handle, unsigned int ms_timeout, const META_UTIL_CHECK_TARGET_VER_REQ_T* req, META_UTIL_CHECK_TARGET_VER_CNF_T* cnf );
META_RESULT  __stdcall META_Util_SetTargetAssertCheckParas(unsigned int ms_timeout, const META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T* req);
META_RESULT  __stdcall META_Util_SetTargetAssertCheckParas_r(const int meta_handle, unsigned int ms_timeout, const META_UTIL_SET_ASSERT_CHECK_PARAs_REQ_T* req);


META_RESULT  __stdcall META_Util_CheckIfTargetNVSecOn(unsigned int ms_timeout, bool* bOn);
META_RESULT  __stdcall META_Util_CheckIfTargetNVSecOn_r(const int meta_handle, unsigned int ms_timeout, bool* bOn);

META_RESULT __stdcall META_Util_RebootToNormalMode(unsigned int ms_timeout, unsigned short timeout);
META_RESULT __stdcall META_Util_RebootToNormalMode_r(const int meta_handle, unsigned int ms_timeout, unsigned short timeout);

META_RESULT __stdcall META_Util_QueryBTWiFiSingleAntennaCap(unsigned int ms_timeout, bool* bOn);
META_RESULT __stdcall META_Util_QueryBTWiFiSingleAntennaCap_r(const int meta_handle, unsigned int ms_timeout, bool* bOn);

META_RESULT __stdcall META_Util_SetAntennaPathToBT(const unsigned int ms_timeout);
META_RESULT __stdcall META_Util_SetAntennaPathToBT_r(const int meta_handle, const unsigned int ms_timeout);

META_RESULT __stdcall META_Util_SetAntennaPathToWiFi(const unsigned int ms_timeout);
META_RESULT __stdcall META_Util_SetAntennaPathToWiFi_r(const int meta_handle, const unsigned int ms_timeout);

#define META_LIPTON_OPTION_ON   0x00000001
#define META_TC01_OPTION_ON     0x00000002
#define META_AST_TD_OPTION_ON   0x00000004

META_RESULT __stdcall META_Util_QueryTargetOptionInfo(const unsigned int ms_timeout, unsigned int* info);
META_RESULT __stdcall META_Util_QueryTargetOptionInfo_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* info);

META_RESULT __stdcall META_Util_QueryTargetLimitedStateIndicator(const unsigned int ms_timeout, unsigned int* info);
META_RESULT __stdcall META_Util_QueryTargetLimitedStateIndicator_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* info);

typedef struct
{
    /// number of elements in the list
    unsigned int validNumber;
    /// voltage list (unit: micro volt 10^-6)
    unsigned int voltageList[255];
    /// register value of each voltageList
    unsigned int registerValue[255];
} MetaVpaVoltageList;

META_RESULT __stdcall META_Util_QueryVpaVoltageList(const unsigned int ms_timeout, MetaVpaVoltageList* vpaVoltageList);
META_RESULT __stdcall META_Util_QueryVpaVoltageList_r(const int meta_handle, const unsigned int ms_timeout, MetaVpaVoltageList* vpaVoltageList);
META_RESULT __stdcall META_Util_QueryDriveAvailableForFileSize(unsigned int ms_timeout, unsigned int size, short* driveLetter);
META_RESULT __stdcall META_Util_QueryDriveAvailableForFileSize_r(const int meta_handle, unsigned int ms_timeout, unsigned int size, short* driveLetter);
META_RESULT __stdcall META_Util_QueryMaxControlBuffer(unsigned int ms_timeout, unsigned int* size);
META_RESULT __stdcall META_Util_QueryMaxControlBuffer_r(const int meta_handle, unsigned int ms_timeout, unsigned int* size);
META_RESULT __stdcall META_Util_QueryAdcModuleSupport(unsigned int ms_timeout, unsigned char* support); // 1:suport 0:not support
META_RESULT __stdcall META_Util_QueryAdcModuleSupport_r(const int meta_handle, unsigned int ms_timeout, unsigned char* support);
META_RESULT __stdcall META_Util_QueryRtcModuleSupport(unsigned int ms_timeout, unsigned char* support); // 1:suport 0:not support
META_RESULT __stdcall META_Util_QueryRtcModuleSupport_r(const int meta_handle, unsigned int ms_timeout, unsigned char* support);
META_RESULT __stdcall META_Util_EnableTstMetaTraceMode(const unsigned int ms_timeout, const unsigned char trace_mode); // 0: disable 1: catcher relay 2: file dump
META_RESULT __stdcall META_Util_EnableTstMetaTraceMode_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char trace_mode);
META_RESULT __stdcall META_Util_QueryTstMetaTraceMode(const unsigned int ms_timeout, unsigned char* trace_mode);  // 0: disable 1: catcher relay 2: file dump
META_RESULT __stdcall META_Util_QueryTstMetaTraceMode_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* trace_mode);
//--------------------------------------------------------------------------//
//  WiFi Calibration                                                        //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  WiFi Calibration: data structure definition        //
//-----------------------------------------------------//

// WiFi Baseband Chip ID
#define WIFI_BB_MT5911      0x00000001
#define WIFI_BB_MT5921      0x00000002
#define WIFI_BB_MT5931      0x00000003

// WiFi RF Chip ID
#define WIFI_RF_AL2236      0x00000001
#define WIFI_RF_MAX2827     0x00000002
#define WIFI_RF_MT5921      0x00000003
#define WIFI_RF_MT5931      0x00000004

typedef enum
{
    WIFI_TEST_RATE_1M = 0,     /* 1M          */
    WIFI_TEST_RATE_2M,         /* 2M          */
    WIFI_TEST_RATE_5_5M,       /* 5.5M        */
    WIFI_TEST_RATE_11M,        /* 11M         */
    WIFI_TEST_RATE_6M,         /* 6M          */
    WIFI_TEST_RATE_9M,         /* 9M          */
    WIFI_TEST_RATE_12M,        /* 12M         */
    WIFI_TEST_RATE_18M,        /* 18M         */
    WIFI_TEST_RATE_24M,        /* 24M         */
    WIFI_TEST_RATE_36M,        /* 36M         */
    WIFI_TEST_RATE_48M,        /* 48M         */
    WIFI_TEST_RATE_54M,        /* 54M         */
    /*5931*/
    WNDRV_TEST_MOD_MCS0,       /* 802.11n MSC 0 */
    WNDRV_TEST_MOD_MCS1,       /* 802.11n MSC 1 */
    WNDRV_TEST_MOD_MCS2,       /* 802.11n MSC 2 */
    WNDRV_TEST_MOD_MCS3,       /* 802.11n MSC 3 */
    WNDRV_TEST_MOD_MCS4,       /* 802.11n MSC 4 */
    WNDRV_TEST_MOD_MCS5,       /* 802.11n MSC 5 */
    WNDRV_TEST_MOD_MCS6,       /* 802.11n MSC 6 */
    WNDRV_TEST_MOD_MCS7,       /* 802.11n MSC 7 */
    WNDRV_TEST_MOD_MCS32,       /* 802.11n MSC 32 */
    WIFI_TEST_RATE_COUNT       /* Total count   */
} WiFi_TestRate_E;

typedef enum
{
    WNDRV_HOST_INTERFACE_SDIO = 0
                                , WNDRV_HOST_INTERFACE_HPI
    , WNDRV_HOST_INTERFACE_SPI
    , WNDRV_HOST_INTERFACE_CF_MEM
    , WNDRV_HOST_INTERFACE_CF_IO
} WiFi_HostInterface_E;

typedef enum
{
    WIFI_TX_ALL_ZEROS,
    WIFI_TX_ALL_ONES,
    WIFI_TX_ALTERNATE_BITS,
    WIFI_TX_PSEUDO_RANDOM
} WiFi_TestPktTxPattern_E;

typedef enum
{
    WIFI_POWER_MODE_NORMAL,
    WIFI_POWER_MODE_IDLE,
    WIFI_POWER_MODE_SLEEP
} WiFi_PowerManagementMode_E;

typedef enum
{
    WIFI_RF_RX_TEST_MODE = 1  /* For RF Test use */
} WiFi_TestPktRxMode_E;

typedef enum
{
    WIFI_RX_ANT_DIVERSITY_AGC,  /* AGC based selection */
    WIFI_RX_ANT_DIVERSITY_MPDU, /* MPDU based selection */
    WIFI_RX_ANT_FIXED_0,        /* Always 0 */
    WIFI_RX_ANT_FIXED_1         /* Always 1 */
} WiFi_RxAntSel_E;

typedef struct
{
    unsigned int    bb_chip_id;
    char            bb_chip_ver[32];
    unsigned int    rf_chip_id;
    char            rf_chip_ver[32];
    unsigned char   support_802_11b;
    unsigned char   support_802_11a;
    unsigned char   support_802_11g;
    bool            eeprom_exist;
    unsigned int    eeprom_size;
    WiFi_HostInterface_E    host_interface;
    unsigned char   support_802_11n;
} WiFi_ChipCapability_S;

typedef struct
{
    unsigned int        ch_freq; /* Frq, units are kHz */
    WiFi_TestRate_E     tx_rate;
    int                 dbm;
} WiFi_DBM2DAC_Set_S;

typedef struct
{
    unsigned short      tx_gain_dac;
} WiFi_DBM2DAC_Query_S;

typedef struct
{
    unsigned int        ch_freq;/* Frq, units are kHz */
    WiFi_TestRate_E     tx_rate;
    unsigned char       txAnt; /* 0 for Antenna 0; 1 for Antenna 1 */
    unsigned short      tx_gain_dac;
} WiFi_TestTx_S;

typedef struct
{
    unsigned int            ch_freq;            /* Frq, units are kHz */
    WiFi_TestRate_E         tx_rate;
    unsigned short          tx_gain_dac;
    unsigned int            pktCount;
    unsigned int            pktInterval;        /* interval between each Tx Packet */
    unsigned int            pktLength;          /* 24~1500 */
    WiFi_TestPktTxPattern_E pattern;            /* content of the Tx Packet */
    unsigned char           txAnt;              /* 0 for Antenna 0; 1 for Antenna 1 */
    unsigned char           is_short_preamble;  /* 0 for long preamble and 1 for short preamble */
    unsigned char           mac_header[ 24 ];   /* Frame Ctrl, Duration = 2bytes + 2bytes */
    /* Address 1 = 6 bytes */
    /* Address 2 = 6 bytes */
    /* Address 3 = 6 bytes */
    /* Sequence Ctrl = 2 bytes */
} WiFi_TestPktTx_S;

typedef struct
{
    unsigned int            ch_freq;            /* Frq, units are kHz */
    WiFi_TestRate_E         tx_rate;
    unsigned short          tx_gain_dac;
    unsigned int            pktCount;
    unsigned int            pktInterval;        /* interval between each Tx Packet */
    unsigned int            pktLength;          /* 24~1500 */
    WiFi_TestPktTxPattern_E pattern;            /* content of the Tx Packet */
    unsigned char           txAnt;              /* 0 for Antenna 0; 1 for Antenna 1 */
    unsigned int            txFlags;
    unsigned int            targetAlc;
    unsigned char           is_short_preamble;  /* 0 for long preamble and 1 for short preamble */
    unsigned char           mac_header[ 24 ];   /* Frame Ctrl, Duration = 2bytes + 2bytes */
    /* Address 1 = 6 bytes */
    /* Address 2 = 6 bytes */
    /* Address 3 = 6 bytes */
    /* Sequence Ctrl = 2 bytes */
} WiFi_TestPktTx_Ex_S;

typedef struct
{
    unsigned int        pkt_sent_count;  /* total num sent */
    unsigned int        pkt_sent_acked;  /* acked num */
} WiFi_TxStatus_S;


typedef struct
{
    unsigned int        pkt_sent_count;  /* total num sent */
    unsigned int        pkt_sent_acked;  /* acked num */
    unsigned short      avgAlc;
    unsigned char       cckGainControl;
    unsigned char       ofdmGainControl;
} WiFi_TxStatus_Ex_S;

typedef struct
{
    unsigned int                ch_freq;  /* Frq, units are kHz */
    WiFi_TestPktRxMode_E        mode;
    WiFi_RxAntSel_E             rxAnt;
} WiFi_TestPktRx_S;

typedef struct
{
    unsigned int        int_rx_ok_num;     /* number of packets that Rx ok from interrupt */
    unsigned int        int_crc_err_num;   /* number of packets that CRC error from interrupt */
    unsigned int        pau_rx_pkt_count;  /* number of packets that Rx ok from PAU */
    unsigned int        pau_crc_err_count; /* number of packets that CRC error from PAU */
    unsigned int        pau_cca_count;     /* CCA rising edge count */
    unsigned int        pau_rx_fifo_full_count; /* number of lost packets due to FiFo full */
    unsigned int        int_long_preamble_num;
    unsigned int        int_short_preamble_num;
    unsigned int        int_rate_ok_num[ 12 ];
    unsigned int        int_rate_crc_err_num[ 12 ];
    int                 int_rssi_max;
    int                 int_rssi_min;
    int                 int_rssi_mean;
    int                 int_rssi_variance;
    /* 0~63, 64~127, 128~255, 256~511, 512~1023, 1024~2047 #define WNDRV_PACKET_SIZE_COUNT   (6) */
    unsigned int        packetSize[6];
    /* Data, Management, Control */
    unsigned int        packetType[6];
    unsigned int        int_rate_ok_num_802_11n[ 8 ];
    unsigned int        int_rate_crc_err_num_802_11n[ 8 ];
} WiFi_RxStatus_S;

typedef struct
{
    int  ED;
    int  OSD;
    int  SQ1;
    int  SFD;
    int  CRC16;
} WiFi_RxCounter_S;

typedef struct
{
    unsigned int    channel_num;
    unsigned char   channel_list[64];
} WiFi_ChannelList_S;

typedef struct
{
    unsigned char   country_code[2];
} WiFi_RegDomain_S;

typedef struct
{
    unsigned int    index;      // 32bits alignment index, +4
    unsigned int    mcr_data32;
} WiFi_MACReg32_S;

typedef struct
{
    unsigned int    index;      // 16bits alignment index, +2
    unsigned short  mcr_data16;
} WiFi_MACReg16_S;

typedef struct
{
    unsigned int    index;      // 8bits alignment index, +1
    unsigned char   bbcr_data8;
} WiFi_BBReg8_S;

typedef struct
{
    unsigned int    index;      // 16bits alignment index, +2
    unsigned short  eeprom_data16;
} WiFi_EEPROM_S;

/*5931*/
typedef enum
{
    WNDRV_TEST_BW_20MHZ = 0,
    WNDRV_TEST_BW_40MHZ,
    WNDRV_TEST_BW_U20MHZ,
    WNDRV_TEST_BW_L20MHZ,
    WNDRV_TEST_BW_COUNT
} wndrv_test_bandwidth_enum;

typedef enum
{
    WNDRV_TEST_TX_GI_400NS = 0,
    WNDRV_TEST_TX_GI_800NS,
    WNDRV_TEST_TX_GI_COUNT
} wndrv_test_guard_intval_enum;

typedef enum
{
    WNDRV_TEST_TX_GREEN_FIELD = 0,
    WNDRV_TEST_TX_MIX_MODE,
    WNDRV_TEST_TX_MODE_COUNT
} wndrv_test_mode_sel_enum;

/*5931*/
typedef struct
{
    wndrv_test_bandwidth_enum  txBw;
} wndrv_test_tx_bw_struct;


typedef struct
{
    wndrv_test_guard_intval_enum  txGi;
} wndrv_test_tx_gi_struct;


typedef struct
{
    wndrv_test_mode_sel_enum  txMode;
} wndrv_test_tx_mode_sel_struct;

typedef struct
{
    wndrv_test_bandwidth_enum  rxBw;
} wndrv_test_rx_bw_struct;

/* WNDRV_TEST_QUERY_THEM_SENS */
/* Note wndrv_test_peer_buff_them_sens_struct is used in peer_buff_ptr. */
typedef struct
{
    unsigned int  u4ThemSensVal;
} wndrv_test_peer_buff_them_sens_struct;

/* WNDRV_TEST_QUERY_VOLT_SENS */
/* Note wndrv_test_peer_buff_volt_sens_struct is used in peer_buff_ptr. */
typedef struct
{
    unsigned int  u4VoltSensVal;
} wndrv_test_peer_buff_volt_sens_struct;

/* WNDRV_TEST_QUERY_TSSI */
/* Note wndrv_test_peer_buff_volt_sens_struct is used in peer_buff_ptr. */
typedef struct
{
    unsigned int  u4Tssi;
} wndrv_test_peer_buff_tssi_struct;

/* WNDRV_TEST_QUERY_EFUSE */
/* Note wndrv_test_peer_buff_efuse_struct is used in peer_buff_ptr. */
typedef struct
{
    unsigned short  u2Offset; /* Addressing space is determined by efuse size. */
    unsigned int    u4Value;
} wndrv_test_peer_buff_efuse_struct;

//-----------------------------------------------------//
//  WiFi Calibration: WNDRV SET Functions              //
//-----------------------------------------------------//
META_RESULT  __stdcall META_WiFi_Stop(unsigned int  ms_timeout);
META_RESULT  __stdcall META_WiFi_Stop_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall META_WiFi_ContTx(unsigned int  ms_timeout, const WiFi_TestTx_S* req);
META_RESULT  __stdcall META_WiFi_ContTx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S* req);
META_RESULT  __stdcall META_WiFi_LocalFrequencyMeasure(unsigned int  ms_timeout, const WiFi_TestTx_S* req);
META_RESULT  __stdcall META_WiFi_LocalFrequencyMeasure_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S* req);
META_RESULT  __stdcall META_WiFi_CarrierSuppressionMeasure(unsigned int  ms_timeout, const WiFi_TestTx_S* req);
META_RESULT  __stdcall META_WiFi_CarrierSuppressionMeasure_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestTx_S* req);
META_RESULT  __stdcall META_WiFi_ContPktTx(unsigned int  ms_timeout, const WiFi_TestPktTx_S* req);
META_RESULT  __stdcall META_WiFi_ContPktTx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktTx_S* req);
META_RESULT  __stdcall META_WiFi_ContPktTx_Ex(unsigned int  ms_timeout, const WiFi_TestPktTx_Ex_S* req);
META_RESULT  __stdcall META_WiFi_ContPktTx_Ex_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktTx_Ex_S* req);


META_RESULT  __stdcall META_WiFi_SetPowerManagementMode(unsigned int  ms_timeout, const WiFi_PowerManagementMode_E  mode);
META_RESULT  __stdcall META_WiFi_SetPowerManagementMode_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_PowerManagementMode_E  mode);
META_RESULT  __stdcall META_WiFi_ContPktRx(unsigned int  ms_timeout, const WiFi_TestPktRx_S* req);
META_RESULT  __stdcall META_WiFi_ContPktRx_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TestPktRx_S* req);
META_RESULT  __stdcall META_WiFi_SetRegDomain(unsigned int  ms_timeout, const WiFi_RegDomain_S*  req);
META_RESULT  __stdcall META_WiFi_SetRegDomain_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_RegDomain_S*  req);
META_RESULT  __stdcall META_WiFi_SetDbmToDac(unsigned int  ms_timeout, const WiFi_DBM2DAC_Set_S* req);
META_RESULT  __stdcall META_WiFi_SetDbmToDac_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_DBM2DAC_Set_S* req);
META_RESULT  __stdcall META_WiFi_MACReg32Write(unsigned int  ms_timeout, const WiFi_MACReg32_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg32Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MACReg32_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Write(unsigned int  ms_timeout, const WiFi_MACReg16_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MACReg16_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegWrite(unsigned int  ms_timeout, const WiFi_BBReg8_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegWrite_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_BBReg8_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Write(unsigned int  ms_timeout, const WiFi_EEPROM_S* array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Write_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_EEPROM_S* array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_SetTxBw(unsigned int  ms_timeout, const wndrv_test_tx_bw_struct* req);
META_RESULT  __stdcall META_WiFi_SetTxBw_r(const int meta_handle, unsigned int  ms_timeout, const wndrv_test_tx_bw_struct* req);
META_RESULT  __stdcall META_WiFi_SetGi(unsigned int  ms_timeout, const wndrv_test_tx_gi_struct* req);
META_RESULT  __stdcall META_WiFi_SetGi_r(const int meta_handle, unsigned int  ms_timeout, const wndrv_test_tx_gi_struct* req);
META_RESULT  __stdcall META_WiFi_SetTxMode(unsigned int  ms_timeout, const wndrv_test_tx_mode_sel_struct* req);
META_RESULT  __stdcall META_WiFi_SetTxMode_r(const int meta_handle, unsigned int  ms_timeout, const wndrv_test_tx_mode_sel_struct* req);
META_RESULT  __stdcall META_WiFi_SetRxBw(unsigned int  ms_timeout, const wndrv_test_rx_bw_struct* req);
META_RESULT  __stdcall META_WiFi_SetRxBw_r(const int meta_handle, unsigned int  ms_timeout, const wndrv_test_rx_bw_struct* req);

//-----------------------------------------------------//
//  WiFi Calibration: WNDRV QUERY Functions            //
//-----------------------------------------------------//
META_RESULT  __stdcall META_WiFi_QueryTxStatus(unsigned int  ms_timeout, WiFi_TxStatus_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryTxStatus_r(const int meta_handle, unsigned int  ms_timeout, WiFi_TxStatus_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryTxStatus_Ex(unsigned int  ms_timeout, WiFi_TxStatus_Ex_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryTxStatus_Ex_r(const int meta_handle, unsigned int  ms_timeout, WiFi_TxStatus_Ex_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryRxStatus(unsigned int  ms_timeout, WiFi_RxStatus_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryRxStatus_r(const int meta_handle, unsigned int  ms_timeout, WiFi_RxStatus_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryChannelList(unsigned int  ms_timeout, WiFi_ChannelList_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryChannelList_r(const int meta_handle, unsigned int  ms_timeout, WiFi_ChannelList_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryRxCounter(unsigned int  ms_timeout, WiFi_RxCounter_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryRxCounter_r(const int meta_handle, unsigned int  ms_timeout, WiFi_RxCounter_S* cnf);
META_RESULT  __stdcall META_WiFi_QueryDbmToDac(unsigned int  ms_timeout, WiFi_DBM2DAC_Query_S*  cnf);
META_RESULT  __stdcall META_WiFi_QueryDbmToDac_r(const int meta_handle, unsigned int  ms_timeout, WiFi_DBM2DAC_Query_S*  cnf);
META_RESULT  __stdcall META_WiFi_MACReg32Read(unsigned int  ms_timeout, WiFi_MACReg32_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg32Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_MACReg32_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Read(unsigned int  ms_timeout, WiFi_MACReg16_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_MACReg16Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_MACReg16_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegRead(unsigned int  ms_timeout, WiFi_BBReg8_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_BBRegRead_r(const int meta_handle, unsigned int  ms_timeout, WiFi_BBReg8_S*  array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Read(unsigned int  ms_timeout, WiFi_EEPROM_S* array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_EEPROM_Read_r(const int meta_handle, unsigned int  ms_timeout, WiFi_EEPROM_S* array, unsigned int array_cnt);
META_RESULT  __stdcall META_WiFi_DacDcOffsetAutoCalibration(unsigned int  ms_timeout, WiFi_DAC_DC_Offset_S*  cnf);
META_RESULT  __stdcall META_WiFi_DacDcOffsetAutoCalibration_r(const int meta_handle, unsigned int  ms_timeout, WiFi_DAC_DC_Offset_S*  cnf);
META_RESULT  __stdcall META_WiFi_QueryThermoSensor(unsigned int  ms_timeout, wndrv_test_peer_buff_them_sens_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryThermoSensor_r(const int meta_handle, unsigned int  ms_timeout, wndrv_test_peer_buff_them_sens_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryVoltageSensor(unsigned int  ms_timeout, wndrv_test_peer_buff_volt_sens_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryVoltageSensor_r(const int meta_handle, unsigned int  ms_timeout, wndrv_test_peer_buff_volt_sens_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryTssi(unsigned int  ms_timeout, wndrv_test_peer_buff_tssi_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryTssi_r(const int meta_handle, unsigned int  ms_timeout, wndrv_test_peer_buff_tssi_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryEfuse(unsigned int  ms_timeout, wndrv_test_peer_buff_efuse_struct*  cnf);
META_RESULT  __stdcall META_WiFi_QueryEfuse_r(const int meta_handle, unsigned int  ms_timeout, wndrv_test_peer_buff_efuse_struct*  cnf);

//-----------------------------------------------------//
//  WiFi Calibration: Exported Functions               //
//-----------------------------------------------------//
META_RESULT  __stdcall META_WiFi_QueryChipCapability(unsigned int  ms_timeout, WiFi_ChipCapability_S*  cnf);
META_RESULT  __stdcall META_WiFi_QueryChipCapability_r(const int meta_handle, unsigned int  ms_timeout, WiFi_ChipCapability_S*  cnf);
META_RESULT  __stdcall META_WiFi_SetMacAddress(unsigned int  ms_timeout, const WiFi_MacAddress_S*  mac);
META_RESULT  __stdcall META_WiFi_SetMacAddress_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_MacAddress_S*  mac);
META_RESULT  __stdcall META_WiFi_SetTxPower2400M(unsigned int  ms_timeout, const WiFi_TxPower_2400M_S*  txpwr);
META_RESULT  __stdcall META_WiFi_SetTxPower2400M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxPower_2400M_S*  txpwr);
META_RESULT  __stdcall META_WiFi_SetTxPower5000M(unsigned int  ms_timeout, const WiFi_TxPower_5000M_S*  txpwr);
META_RESULT  __stdcall META_WiFi_SetTxPower5000M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxPower_5000M_S*  txpwr);
META_RESULT  __stdcall META_WiFi_SetDacDcOffset(unsigned int  ms_timeout, const WiFi_DAC_DC_Offset_S*  dac_dc_offset);
META_RESULT  __stdcall META_WiFi_SetDacDcOffset_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_DAC_DC_Offset_S*  dac_dc_offset);

META_RESULT  __stdcall META_WiFi_SetTxALC2400M(unsigned int  ms_timeout, const WiFi_TxALC_2400M_S*  txalc);
META_RESULT  __stdcall META_WiFi_SetTxALC2400M_r(const int meta_handle, unsigned int  ms_timeout, const WiFi_TxALC_2400M_S*  txalc);

//--------------------------------------------------------------------------//
//  BT Calibration                                                          //
//--------------------------------------------------------------------------//

//-----------------------------------------------------//
//  BT Calibration: data structure definition          //
//-----------------------------------------------------//

// BT Module ID
#define BT_NOT_SUPPORT        0x00000000
#define BTMODULE_MT6601       0x00000011
#define BTMODULE_MT6611       0x00000012
#define BTMODULE_MT6612       0x00000013
#define BTMODULE_MT6616       0x00000014
#define BTMODULE_MT6236       0x00000015
#define BTMODULE_MT6256       0x00000016
#define BTMODULE_MT6276       0x00000017
#define BTMODULE_MT6622       0x00000018
#define BTMODULE_MT6626       0x00000019
#define BTMODULE_MT6612_22_26 0x0000001A
#define BTMODULE_MT6255       0x0000001B
#define BTMODULE_MT6250       0x0000001C
#define BTMODULE_MT6260       0x0000001D
#define BTMODULE_RFMD3500     0x00000021
#define BTMODULE_RFMD4020     0x00000022

//#define BT_PACKET_LEN       339
#define BT_PACKET_LEN       1021  // because BT2.0 support at most 1021 bytes per packet
typedef struct
{
    unsigned char   id;
} BT_ModuleID_S;

typedef struct
{
    unsigned char   m_event;
    char            m_status;
    unsigned short  m_handle;
    unsigned char   m_len;
    unsigned char   m_parms[256];
} BT_HCI_EVENT;

typedef struct
{
    unsigned short  m_opcode;
    unsigned char   m_len;
    unsigned char   m_cmd[256];
} BT_HCI_COMMAND;
typedef struct
{
    unsigned short           m_con_hdl;
    unsigned short           m_len;
    unsigned char            m_buffer[BT_PACKET_LEN];
} BT_HCI_BUFFER;
typedef struct
{
    unsigned short           m_len;
    unsigned char            m_data[BT_PACKET_LEN];
} BT_HCI_PACKET;
typedef struct
{
    unsigned short           m_con_hdl;
    unsigned short           m_len;
    unsigned short           m_total_pks;
} BT_HCI_TX_PURE_TEST;

typedef struct
{
    unsigned int             m_used_time;
    unsigned short           m_len;
} BT_HCI_TX_PURE_TEST_STAT;

typedef struct
{
    unsigned int             m_used_time;
    unsigned short           m_len;
} BT_HCI_RX_PURE_TEST_STAT;

typedef struct
{
    unsigned int             m_u4UsedTime;
    unsigned short           m_u2PktSentNum;

} BT_HCI_TX_PURE_TEST_STAT_V2;

typedef struct
{
    unsigned char  m_u1Flag; /**< indicator that the FT task polling for the power on state */
    BT_HCI_COMMAND hci; /**< command buffer for the power on sequence */
} BT_POWER_ON_EX2_REQ_T;
//-----------------------------------------------------//
//  BT Calibration Functions                           //
//-----------------------------------------------------//
META_RESULT  __stdcall META_BT_QueryModuleID(unsigned int  ms_timeout, BT_ModuleID_S*  cnf);
META_RESULT  __stdcall META_BT_QueryModuleID_r(const int meta_handle, unsigned int  ms_timeout, BT_ModuleID_S*  cnf);

typedef void (__stdcall* META_BT_HCI_CNF)(const BT_HCI_EVENT* cnf, const short token, void* usrData);
typedef void (__stdcall* META_BT_HCI_TXDATA_CNF)(const BT_HCI_PACKET* cnf, const short token, void* usrData);
typedef void (__stdcall* META_BT_AUTO_HCI_CNF)(const BT_HCI_EVENT* cnf, const short token, void* usrData);
typedef void (__stdcall* META_BT_HCI_RXDATA_CNF)(const BT_HCI_BUFFER* cnf, const short token, void* usrData);

typedef void (__stdcall* META_BT_HCI_TXTEST_CNF)(const BT_HCI_TX_PURE_TEST_STAT* cnf, const short token, void* usrData);
typedef void (__stdcall* META_BT_HCI_RXTEST_CNF)(const BT_HCI_RX_PURE_TEST_STAT* cnf, const short token, void* usrData);

typedef void (__stdcall* META_BT_HCI_TXTEST_V2_CNF)(const BT_HCI_TX_PURE_TEST_STAT_V2* cnf, const short token, void* usrData);

typedef struct
{
    META_BT_HCI_TXDATA_CNF      m_SendDataCallback;
    META_BT_HCI_RXDATA_CNF      m_RecvDataCallback;
    META_BT_AUTO_HCI_CNF        m_AutoCallback;
    META_BT_HCI_TXTEST_CNF      m_TxTestCallback;
    META_BT_HCI_RXTEST_CNF      m_RxTestCallback;
    META_BT_HCI_TXTEST_V2_CNF   m_TxTestCallback_V2;
} BT_OtherCallBack;
META_RESULT  __stdcall META_BT_SendHCICommand(unsigned int  ms_timeout, BT_HCI_COMMAND* req, META_BT_HCI_CNF  cb, void*  cb_arg, unsigned char Cmpltcode);
META_RESULT  __stdcall META_BT_SendHCICommand_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_COMMAND* req, META_BT_HCI_CNF  cb, void*  cb_arg, unsigned char Cmpltcode);

META_RESULT  __stdcall META_BT_CancelHCICommand(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_CancelHCICommand_r(const int meta_handle, unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_SendHCIData(unsigned int  ms_timeout, BT_HCI_BUFFER* snd, META_BT_HCI_TXDATA_CNF  cb_tx, void*  cb_arg);
META_RESULT  __stdcall META_BT_SendHCIData_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_BUFFER* snd, META_BT_HCI_TXDATA_CNF  cb_tx, void*  cb_arg);
META_RESULT  __stdcall META_BT_RegisterAutoCallback(META_BT_AUTO_HCI_CNF cb_auto);
META_RESULT  __stdcall META_BT_RegisterAutoCallback_r(const int meta_handle, META_BT_AUTO_HCI_CNF cb_auto);
META_RESULT  __stdcall META_BT_ReceiveHCIData(META_BT_HCI_RXDATA_CNF cb_rx);
META_RESULT  __stdcall META_BT_ReceiveHCIData_r(const int meta_handle, META_BT_HCI_RXDATA_CNF cb_rx);

META_RESULT  __stdcall META_BT_TxPureTest(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST* snd, META_BT_HCI_TXTEST_CNF cb_tx, void*  cb_arg);
META_RESULT  __stdcall META_BT_TxPureTest_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST* snd, META_BT_HCI_TXTEST_CNF cb_tx, void*  cb_arg);
META_RESULT  __stdcall META_BT_RxTestStart(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall META_BT_RxTestStart_r(const int meta_handle, unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall META_BT_RxTestEnd(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_RxTestEnd_r(const int meta_handle, unsigned int  ms_timeout);

META_RESULT  __stdcall META_BT_TxPureTest_V2(unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST* snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void*  cb_arg);
META_RESULT  __stdcall META_BT_TxPureTest_V2_r(const int meta_handle, unsigned int  ms_timeout, BT_HCI_TX_PURE_TEST* snd, META_BT_HCI_TXTEST_V2_CNF cb_txtest, void*  cb_arg);

META_RESULT  __stdcall META_BT_RxTestStart_V2(unsigned int  ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);
META_RESULT  __stdcall META_BT_RxTestStart_V2_r(const int meta_handle, unsigned int ms_timeout, META_BT_HCI_RXTEST_CNF cb_rx);

META_RESULT  __stdcall META_BT_EnableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_EnableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_BT_DisableNvramOnlineUpdate(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_DisableNvramOnlineUpdate_r(const int meta_handle, unsigned int ms_timeout);


META_RESULT  __stdcall META_BT_EnablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_EnablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_BT_DisablePcmClockSyncSignal(unsigned int  ms_timeout);
META_RESULT  __stdcall META_BT_DisablePcmClockSyncSignal_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_BT_RemoveAutoCallback();
META_RESULT  __stdcall META_BT_RemoveAutoCallback_r(const int meta_handle);
META_RESULT  __stdcall META_BT_RemoveReceiveHCIDataCallback();
META_RESULT  __stdcall META_BT_RemoveReceiveHCIDataCallback_r(const int meta_handle);

META_RESULT __stdcall META_BT_POWERON_EX(const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWERON_EX_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWEROFF_EX(const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWEROFF_EX_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char u1WaitFlag);
META_RESULT __stdcall META_BT_POWERON_EX2(const unsigned int ms_timeout, const BT_POWER_ON_EX2_REQ_T* req);
META_RESULT __stdcall META_BT_POWERON_EX2_r(const int meta_handle, const unsigned int ms_timeout, const BT_POWER_ON_EX2_REQ_T* req);

//----------------------------------------------------------------//
//                              FM                                //
//----------------------------------------------------------------//

//--------------------------//
//    FM data structures    //
//--------------------------//
typedef enum
{
    FM_CHIP_ID_MT6189AN = 0
                          , FM_CHIP_ID_MT6189BN_CN = 1
                                  , FM_CHIP_ID_MT6188A = 3
                                          , FM_CHIP_ID_MT6188C = 4
                                                  , FM_CHIP_ID_MT6188D = 5
                                                          , FM_CHIP_ID_MT6616 = 6
                                                                  , FM_CHIP_ID_MT6276 = 7
                                                                          , FM_CHIP_ID_MT6256 = 8
                                                                                  , FM_CHIP_ID_MT6251 = 9
                                                                                          , FM_CHIP_ID_MT6626 = 10
                                                                                                  , FM_CHIP_ID_MT6255 = 11
                                                                                                          , FM_CHIP_ID_MT6250 = 12
                                                                                                                  , FM_CHIP_ID_MT6260 = 13
} FM_CHIP_ID_E;

typedef struct
{
    unsigned char m_ucChipId;
} FM_CHIP_ID_CNF_T;

typedef struct
{
    short m_i2CurFreq;  // freq range is [875, 1080]
} FM_FREQ_REQ_T;



typedef struct
{
    unsigned char m_ucSignalLevel;
} FM_RSSI_CNF_T;

typedef struct
{
    //unsigned char m_ucIfCnt;
    unsigned short m_u2IfCnt;

} FM_IF_CNT_CNF_T;

typedef struct
{
    unsigned short m_u2MonoOrStereo;  // 0: mono, 1: stereo
    unsigned short m_u2SblendOnOrOff; // 0: sblend off, 1: sblend on
    unsigned int   m_u4ItemValue;  // 0: disable, 1: enable

} FM_MONO_STEREO_BLEND_REQ_T;

typedef struct  // freq range is [875, 1080]
{
    short m_i2StartFreq;    // note: when we try to search next: start freq should <= stop freq
    short m_i2StopFreq;     // note: when we try to search prev: start freq should >= stop freq

} FM_FREQ_RANGE_REQ_T;

typedef struct
{
    unsigned char m_ucExit;      // 0: don't exist, 1: exist
    short         m_i2ValidFreq; // -1: settings error, 0: invalid freq, others: 875-1080 valid

} FM_VAILD_FREQ_CNF_T;

typedef struct
{
    unsigned int m_u4RssiThreshold;

} FM_RSSI_THRESHOLD_REQ_T;

typedef struct
{
    unsigned int m_u4IfCntDelta;

} FM_IF_CNT_DELTA_REQ_T;


typedef struct
{
    unsigned char m_ucAddr;

} FM_READ_BYTE_ADDR_REQ_T;


typedef struct
{
    unsigned short m_u2ReadByte;

} FM_READ_BYTE_CNF_T;


typedef struct
{
    unsigned char m_ucAddr;
    unsigned short m_u2WriteByte;
} FM_WRITE_BYTE_REQ_T;

typedef struct
{
    unsigned char m_bOnOff;  // 0: off, 1: on

} FM_SOFT_MUTE_ONOFF_REQ_T;

typedef struct
{
    unsigned char m_ucStage;  // 1~3
} FM_STAGE_REQ_T;

typedef struct
{
    unsigned char  m_ucHighOrLow;
} FM_HL_Side_CNF_T;

typedef struct
{
    unsigned char m_ucStereoOrMono;

} FM_Stereo_Mono_CNF_T;

// for MT6616 new API
typedef struct
{
    unsigned char m_ucVolume;
    char m_cDigitalGainIndex;
} FM_Volume_Setting_REQ_T;

typedef struct
{
    unsigned short m_u2Bitmap[16];
} FM_AutoScan_CNF_T;

typedef struct
{
    unsigned char m_ucRDSOn;
} FM_SetRDS_REQ_T;

typedef struct
{
    unsigned char m_ucRXFilterBW;
} FM_RX_FilterBW_CNF_T;

typedef struct
{
    unsigned char m_ucPAMDLevel;
} FM_PAMD_Level_CNF_T;

typedef struct
{
    unsigned char m_ucMR;
} FM_MR_CNF_T;

typedef struct
{
    unsigned int m_u4DecodeMode;
} FM_Decode_Mode_REQ_T;

typedef struct
{
    unsigned int m_u4HCC;
} FM_HCC_REQ_T;

typedef struct
{
    unsigned int m_u4PAMDThreshold;
} FM_PAMD_Threshold_REQ_T;

typedef struct
{
    unsigned int m_u4SoftmuteEnable;
} FM_Softmute_Enable_REQ_T;

typedef struct
{
    unsigned int m_u4DeemphasisLevel;
} FM_Deemphasis_Level_REQ_T;

typedef struct
{
    unsigned int m_u4HLSide;
} FM_HL_Side_REQ_T;

typedef struct
{
    unsigned int m_u4DemodBandwidth;
} FM_Demod_Bandwidth_REQ_T;

typedef struct
{
    unsigned int m_u4DynamicLimiter;
} FM_DynamicLimiter_REQ_T;

typedef struct
{
    unsigned int m_u4SoftmuteRate;
} FM_Softmute_Rate_REQ_T;

typedef enum
{
    RDS_CMD_NONE = 0,   // No command. This is usually an error.
    RDS_CMD_PI_CODE,
    RDS_CMD_PTY_CODE,
    RDS_CMD_PROGRAMNAME,
    RDS_CMD_LOCDATETIME,
    RDS_CMD_UTCDATETIME,
    RDS_CMD_LAST_RADIOTEXT,
    RDS_CMD_AF,
    RDS_CMD_AF_LIST,
    RDS_CMD_AFON,
    RDS_CMD_TAON,
    RDS_CMD_TAON_OFF
} RdsCmd;

typedef enum
{
    RDS_FLAG_IS_TP                                = 0x0001, // Program is a traffic program
    RDS_FLAG_IS_TA                            = 0x0002, // Program currently broadcasts a traffic ann.
    RDS_FLAG_IS_MUSIC                     = 0x0004, // Program currently broadcasts music
    RDS_FLAG_IS_STEREO                  = 0x0008, // Program is transmitted in stereo
    RDS_FLAG_IS_ARTIFICIAL_HEAD = 0x0010, // Program is an artificial head recording
    RDS_FLAG_IS_COMPRESSED       = 0x0020, // Program content is compressed
    RDS_FLAG_IS_DYNAMIC_PTY       = 0x0040, // Program type can change
    RDS_FLAG_TEXT_AB                      = 0x0080  // If this flag changes state, a new radio text                      string begins
} RdsFlag;

typedef enum
{
    RDS_EVENT_FLAGS          = 0x0001, // One of the RDS flags has changed state
    RDS_EVENT_PI_CODE        = 0x0002, // The program identification code has changed
    RDS_EVENT_PTY_CODE       = 0x0004, // The program type code has changed
    RDS_EVENT_PROGRAMNAME    = 0x0008, // The program name has changed
    RDS_EVENT_UTCDATETIME    = 0x0010, // A new UTC date/time is available
    RDS_EVENT_LOCDATETIME    = 0x0020, // A new local date/time is available
    RDS_EVENT_LAST_RADIOTEXT = 0x0040, // A radio text string was completed
    RDS_EVENT_AF                   = 0x0080, // Current Channel RF signal strength too weak, need do AF switch
    RDS_EVENT_AF_LIST        = 0x0100, // An alternative frequency list is ready
    RDS_EVENT_AFON_LIST        = 0x0200, // An alternative frequency list is ready
    RDS_EVENT_TAON        = 0x0400,  // Other Network traffic announcement start
    RDS_EVENT_TAON_OFF        = 0x0800 // Other Network traffic announcement finished.
} RdsEvent;

typedef struct
{
    RdsCmd m_eCmd;
} FM_RDS_Info_REQ_T;

typedef struct
{
    unsigned short m_buffer[64];
} FM_RDS_Info_CNF_T;

typedef struct
{
    RdsFlag m_eFlag;
    unsigned short m_buffer[64];
} FM_RDS_Status_CNF_T;

typedef struct
{
    unsigned short m_u2GoodBlock;
} FM_RDS_Good_Block_Counter_CNF_T;

typedef struct
{
    unsigned short m_u2BadBlock;
} FM_RDS_Bad_Block_Counter_CNF_T;

typedef struct
{
    unsigned short m_u2GroupCounter[32];
} FM_RDS_Group_Counter_CNF_T;

typedef struct
{
    short m_i2StartFreq;
    unsigned char m_ucDirection;
} FM_HWSeek_REQ_T;

typedef struct
{
    short m_i2EndFreq;
} FM_HWSeek_CNF_T;


typedef struct
{
    unsigned short m_u2StereoBlendControl;
} FM_SetStereoBlend_REQ_T;

typedef struct
{
    unsigned short m_u2Blocks[8];
} FM_RDS_Block_CNF_T;

//--------------------------//
//      FM Functions        //
//--------------------------//
META_RESULT  __stdcall META_FM_GetChipId(unsigned int ms_timeout, FM_CHIP_ID_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetChipId_r(const int meta_handle, unsigned int ms_timeout, FM_CHIP_ID_CNF_T* cnf);

META_RESULT  __stdcall META_FM_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_PowerOn_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_PowerOff_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_SetFreq(unsigned int ms_timeout, FM_FREQ_REQ_T* req);
META_RESULT  __stdcall META_FM_SetFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req);

META_RESULT  __stdcall META_FM_GetRSSI(unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_RSSI_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetRSSI_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_RSSI_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetIfCnt(unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_IF_CNT_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetIfCnt_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_IF_CNT_CNF_T* cnf);

META_RESULT __stdcall META_FM_SearchNextFreq(unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T* req, FM_VAILD_FREQ_CNF_T* cnf);
META_RESULT __stdcall META_FM_SearchNextFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T* req, FM_VAILD_FREQ_CNF_T* cnf);

META_RESULT __stdcall META_FM_SearchPrevFreq(unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T* req, FM_VAILD_FREQ_CNF_T* cnf);
META_RESULT __stdcall META_FM_SearchPrevFreq_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_RANGE_REQ_T* req, FM_VAILD_FREQ_CNF_T* cnf);

META_RESULT  __stdcall META_FM_SetMonoOrStereo_Blend(unsigned int ms_timeout, FM_MONO_STEREO_BLEND_REQ_T* req);
META_RESULT  __stdcall META_FM_SetMonoOrStereo_Blend_r(const int meta_handle, unsigned int ms_timeout, FM_MONO_STEREO_BLEND_REQ_T* req);

META_RESULT  __stdcall META_FM_SetRssiThreold(unsigned int ms_timeout, FM_RSSI_THRESHOLD_REQ_T* req);
META_RESULT  __stdcall META_FM_SetRssiThreold_r(const int meta_handle, unsigned int ms_timeout, FM_RSSI_THRESHOLD_REQ_T* req);

META_RESULT  __stdcall META_FM_SetIfCntDelta(unsigned int ms_timeout, FM_IF_CNT_DELTA_REQ_T* req);
META_RESULT  __stdcall META_FM_SetIfCntDelta_r(const int meta_handle, unsigned int ms_timeout, FM_IF_CNT_DELTA_REQ_T* req);

META_RESULT __stdcall META_FM_ReadByte(unsigned int ms_timeout, FM_READ_BYTE_ADDR_REQ_T* req, FM_READ_BYTE_CNF_T* cnf);
META_RESULT __stdcall META_FM_ReadByte_r(const int meta_handle, unsigned int ms_timeout, FM_READ_BYTE_ADDR_REQ_T* req, FM_READ_BYTE_CNF_T* cnf);

META_RESULT  __stdcall META_FM_WriteByte(unsigned int ms_timeout, FM_WRITE_BYTE_REQ_T* req);
META_RESULT  __stdcall META_FM_WriteByte_r(const int meta_handle, unsigned int ms_timeout, FM_WRITE_BYTE_REQ_T* req);

META_RESULT  __stdcall META_FM_SetSoftMute(unsigned int ms_timeout, FM_SOFT_MUTE_ONOFF_REQ_T* req);
META_RESULT  __stdcall META_FM_SetSoftMute_r(const int meta_handle, unsigned int ms_timeout, FM_SOFT_MUTE_ONOFF_REQ_T* req);

META_RESULT  __stdcall META_FM_SelectSoftMuteStage(unsigned int ms_timeout, FM_STAGE_REQ_T* req);
META_RESULT  __stdcall META_FM_SelectSoftMuteStage_r(const int meta_handle, unsigned int ms_timeout, FM_STAGE_REQ_T* req);

META_RESULT  __stdcall META_FM_SelectSBlendStage(unsigned int ms_timeout, FM_STAGE_REQ_T* req);
META_RESULT  __stdcall META_FM_SelectSBlendStage_r(const int meta_handle, unsigned int ms_timeout, FM_STAGE_REQ_T* req);

META_RESULT  __stdcall META_FM_GetHighOrLowSide(unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_HL_Side_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetHighOrLowSide_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_HL_Side_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetStereoOrMono(unsigned int ms_timeout, FM_Stereo_Mono_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetStereoOrMono_r(const int meta_handle, unsigned int ms_timeout, FM_Stereo_Mono_CNF_T* cnf);

// for MT6616 new API

META_RESULT  __stdcall META_FM_SetVolume(unsigned int ms_timeout, FM_Volume_Setting_REQ_T* req);
META_RESULT  __stdcall META_FM_SetVolume_r(const int meta_handle, unsigned int ms_timeout, FM_Volume_Setting_REQ_T* req);

META_RESULT  __stdcall META_FM_AutoScan(unsigned int ms_timeout, FM_AutoScan_CNF_T* cnf);
META_RESULT  __stdcall META_FM_AutoScan_r(const int meta_handle, unsigned int ms_timeout, FM_AutoScan_CNF_T* cnf);

META_RESULT  __stdcall META_FM_SetRDS(unsigned int ms_timeout, FM_SetRDS_REQ_T* req);
META_RESULT  __stdcall META_FM_SetRDS_r(const int meta_handle, unsigned int ms_timeout, FM_SetRDS_REQ_T* req);

META_RESULT  __stdcall META_FM_GetRXFilterBW(unsigned int ms_timeout, FM_RX_FilterBW_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetRXFilterBW_r(const int meta_handle, unsigned int ms_timeout, FM_RX_FilterBW_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetPAMDLevel(unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_PAMD_Level_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetPAMDLevel_r(const int meta_handle, unsigned int ms_timeout, FM_FREQ_REQ_T* req, FM_PAMD_Level_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetMR(unsigned int ms_timeout, FM_MR_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetMR_r(const int meta_handle, unsigned int ms_timeout, FM_MR_CNF_T* cnf);

META_RESULT  __stdcall META_FM_SetDecodeMode(unsigned int ms_timeout, FM_Decode_Mode_REQ_T* req);
META_RESULT  __stdcall META_FM_SetDecodeMode_r(const int meta_handle, unsigned int ms_timeout, FM_Decode_Mode_REQ_T* req);

META_RESULT  __stdcall META_FM_SetHCC(unsigned int ms_timeout, FM_HCC_REQ_T* req);
META_RESULT  __stdcall META_FM_SetHCC_r(const int meta_handle, unsigned int ms_timeout, FM_HCC_REQ_T* req);

META_RESULT  __stdcall META_FM_SetPAMDThreshold(unsigned int ms_timeout, FM_PAMD_Threshold_REQ_T* req);
META_RESULT  __stdcall META_FM_SetPAMDThreshold_r(const int meta_handle, unsigned int ms_timeout, FM_PAMD_Threshold_REQ_T* req);

META_RESULT  __stdcall META_FM_SetSoftmute(unsigned int ms_timeout, FM_Softmute_Enable_REQ_T* req);
META_RESULT  __stdcall META_FM_SetSoftmute_r(const int meta_handle, unsigned int ms_timeout, FM_Softmute_Enable_REQ_T* req);

META_RESULT  __stdcall META_FM_SetDeemphasisLevel(unsigned int ms_timeout, FM_Deemphasis_Level_REQ_T* req);
META_RESULT  __stdcall META_FM_SetDeemphasisLevel_r(const int meta_handle, unsigned int ms_timeout, FM_Deemphasis_Level_REQ_T* req);

META_RESULT  __stdcall META_FM_SetHLSide(unsigned int ms_timeout, FM_HL_Side_REQ_T* req);
META_RESULT  __stdcall META_FM_SetHLSide_r(const int meta_handle, unsigned int ms_timeout, FM_HL_Side_REQ_T* req);

META_RESULT  __stdcall META_FM_SetDemodBW(unsigned int ms_timeout, FM_Demod_Bandwidth_REQ_T* req);
META_RESULT  __stdcall META_FM_SetDemodBW_r(const int meta_handle, unsigned int ms_timeout, FM_Demod_Bandwidth_REQ_T* req);

META_RESULT  __stdcall META_FM_SetDynamicLimiter(unsigned int ms_timeout, FM_DynamicLimiter_REQ_T* req);
META_RESULT  __stdcall META_FM_SetDynamicLimiter_r(const int meta_handle, unsigned int ms_timeout, FM_DynamicLimiter_REQ_T* req);

META_RESULT  __stdcall META_FM_SetSoftmuteRate(unsigned int ms_timeout, FM_Softmute_Rate_REQ_T* req);
META_RESULT  __stdcall META_FM_SetSoftmuteRate_r(const int meta_handle, unsigned int ms_timeout, FM_Softmute_Rate_REQ_T* req);

// RDS Info
META_RESULT  __stdcall META_FM_GetPI(unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetPI_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetPTY(unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetPTY_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetPS(unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetPS_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetAF(unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetAF_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetRT(unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetRT_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Info_REQ_T* req, FM_RDS_Info_CNF_T* cnf);

// RDS Status

META_RESULT  __stdcall META_FM_GetTP(unsigned int ms_timeout, FM_RDS_Status_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetTP_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetTA(unsigned int ms_timeout, FM_RDS_Status_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetTA_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetMS(unsigned int ms_timeout, FM_RDS_Status_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetMS_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Status_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetGoodBlockCounter(unsigned int ms_timeout, FM_RDS_Good_Block_Counter_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetGoodBlockCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Good_Block_Counter_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetBadBlockCounter(unsigned int ms_timeout, FM_RDS_Bad_Block_Counter_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetBadBlockCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Bad_Block_Counter_CNF_T* cnf);

META_RESULT  __stdcall META_FM_ResetBlockCounter(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_ResetBlockCounter_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_GetGroupCounter(unsigned int ms_timeout, FM_RDS_Group_Counter_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetGroupCounter_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Group_Counter_CNF_T* cnf);

META_RESULT  __stdcall META_FM_ResetGroupCounter(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_ResetGroupCounter_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_HWSeek(unsigned int ms_timeout, FM_HWSeek_REQ_T* req, FM_HWSeek_CNF_T* cnf);
META_RESULT  __stdcall META_FM_HWSeek_r(const int meta_handle, unsigned int ms_timeout, FM_HWSeek_REQ_T* req, FM_HWSeek_CNF_T* cnf);

META_RESULT  __stdcall META_FM_HWSearch_Stop(unsigned int ms_timeout);
META_RESULT  __stdcall META_FM_HWSearch_Stop_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT  __stdcall META_FM_SetStereoBlend(unsigned int ms_timeout, FM_SetStereoBlend_REQ_T* req);
META_RESULT  __stdcall META_FM_SetStereoBlend_r(const int meta_handle, unsigned int ms_timeout, FM_SetStereoBlend_REQ_T* req);

META_RESULT  __stdcall META_FM_GetRDSLogData(unsigned int ms_timeout, FM_RDS_Block_CNF_T* cnf);
META_RESULT  __stdcall META_FM_GetRDSLogData_r(const int meta_handle, unsigned int ms_timeout, FM_RDS_Block_CNF_T* cnf);

META_RESULT  __stdcall META_FM_GetRDSBLERRatio(unsigned int ms_timeout, unsigned short* bler);
META_RESULT  __stdcall META_FM_GetRDSBLERRatio_r(const int meta_handle, unsigned int ms_timeout, unsigned short* bler);

typedef void (__stdcall* META_FM_RDS_INFO_UPDATE_CNF)(const FM_RDS_Info_CNF_T* cnf, const short token, void* usrData);
typedef void (__stdcall* META_FM_RDS_STATUS_UPDATE_CNF)(const FM_RDS_Status_CNF_T* cnf, const short token, void* usrData);
typedef struct
{
    META_FM_RDS_INFO_UPDATE_CNF m_RDSInfoUpdateCallback;
    META_FM_RDS_STATUS_UPDATE_CNF m_RDSStatusUpdateCallback;
} FM_RDSCallBack;
META_RESULT  __stdcall META_FM_RegisterRDSInfoUpdateCallback(META_FM_RDS_INFO_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RegisterRDSInfoUpdateCallback_r(const int meta_handle, META_FM_RDS_INFO_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RegisterRDSStatusUpdateCallback(META_FM_RDS_STATUS_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RegisterRDSStatusUpdateCallback_r(const int meta_handle, META_FM_RDS_STATUS_UPDATE_CNF cb);
META_RESULT  __stdcall META_FM_RemoveRDSInfoUpdateCallback(void);
META_RESULT  __stdcall META_FM_RemoveRDSInfoUpdateCallback_r(const int meta_handle);
META_RESULT  __stdcall META_FM_RemoveRDSStatusUpdateCallback(void);
META_RESULT  __stdcall META_FM_RemoveRDSStatusUpdateCallback_r(const int meta_handle);

META_RESULT  __stdcall META_FM_GetAntennaType(unsigned int ms_timeout, char* type);
META_RESULT  __stdcall META_FM_GetAntennaType_r(const int meta_handle, int ms_timeout, char* type);
META_RESULT  __stdcall META_FM_SetAntennaType(unsigned int ms_timeout, char type);
META_RESULT  __stdcall META_FM_SetAntennaType_r(const int meta_handle, int ms_timeout, char type);
META_RESULT  __stdcall META_FM_QueryCapArray(unsigned int ms_timeout, float* cap_id);
META_RESULT  __stdcall META_FM_QueryCapArray_r(const int meta_handle, int ms_timeout, float* cap_id);
//----------------------------------------------------------------//
//                            TDMB                                //
//----------------------------------------------------------------//

//--------------------------//
//    TDMB data structures  //
//--------------------------//

typedef enum     // ref from TDMB
{
    META_TDMB_KOREA_BAND = 1,
    META_TDMB_BAND_III,
    META_TDMB_L_BAND,
    META_TDMB_CANADA_BAND,
    META_TDMB_CHINESE_BAND,
    META_TDMB_BAND_II,
    META_TDMB_BAND_IF,
    META_TDMB_UNDEF_BAND
} META_TDMB_BAND_enum;

typedef struct
{
    META_TDMB_BAND_enum  m_rBand;

} TDMB_SET_BAND_REQ_T;

typedef struct
{
    unsigned int  m_u4Freq;
} TDMB_SET_FREQ_REQ_T;



typedef struct
{
    unsigned char m_ucFreqNum;
    unsigned int m_u4Freq[10];

} TDMB_AUTO_SCAN_CNF_T;

// ========  for Ensemble ========


typedef struct
{
    //TDMB_DBSTATE     DB;
    unsigned char        m_ucStateNum;
    unsigned int         m_u4State[10];


    unsigned int        Type;   //DMB,DAB,DATA
    unsigned int        Id;
    unsigned int        BitRate;
    unsigned char       PL; //Protection Level
    unsigned char       Reg[8];
    unsigned short      UserApplType;       // added by KST 2006.07.20

    unsigned int        TMId;
    unsigned int        ASCTy_DSCTy;
    unsigned int        SCId;
    unsigned int        PackAdd;
    unsigned int        DG_MFflag;
    unsigned int        Primary;
    unsigned int        CAflag;
    unsigned int        Language;
    char                SCLabel[16];

    //TDMB_SvcComponentInfo  *pSvcComp;
    unsigned char       SvcComp_Order;          // 4bits
    unsigned char       SvcComp_TMId;           // 2bits    Transport Mechanism Id
    unsigned char       SvcComp_ASCTy_DSCTy;    // 6bits    Audio Service Component Type
    unsigned char       SvcComp_SubCh_FIDCId;   // 6bits    SubChId or FIDCId in FIG 0/4
    unsigned int        SvcComp_SId;            // 16bit
    unsigned char       SvcComp_CAflag;         // 1bit     CA Flag
    unsigned char       SvcComp_DG_MFflag;      // 1bit     DG Flag or MF flag
    unsigned char       SvcComp_Language;       // 8bit
    unsigned char       SvcComp_SCIdS;          // 4bit     Service component Identifier within ther Service
    unsigned char       SvcComp_SvcCompLabel[16];// 16bytes Service component Label

    unsigned short      SvcComp_SCId;           // 12bits   Service Component Id
    unsigned short      SvcComp_PackAdd;        // 10bits   Packet Address
    unsigned short      SvcComp_SCCA;           // 16bits   Service Component Conditional Access

    unsigned short      SvcComp_m_encoded_id;   // Only for Frontier
    unsigned char       SvcComp_m_sif;          // Only for Frontier


    //TDMB_SubChInfo             *pSubCh;
    unsigned char       SubChId;        // 6bits    Sub channel Id
    unsigned char       TblIndex;       // 6bits    TableIndex
    unsigned char       Form_Opt_Prot;  //[3] : FormFlag   //[2] : Option//[1~0] : protection
    unsigned short      StrtAdd;        // 10bits   Start Address
    unsigned short      SubChSize;      // 10bits   Sub channel size

    unsigned int        Tag;

} TDMB_CHANNELDB_T;

typedef struct
{
    // TDMB_DBSTATE
    unsigned char       m_ucStateNum;
    unsigned int        m_u4State[10];

    unsigned int        Id;
    char                Label[20];

    //TDMB_ServiceInfo  *pService;
    unsigned int        SId;            // 32bits
    unsigned char       SvcLabel[16];   // 16bytes  Service Label(Program service and Data service)
    unsigned short      CharacterFlag;
    unsigned char       CAId;           // 3bit
    unsigned char       NumSvcComp;     // 4bits    Number of Service Component


    //TDMB_CHANNELDB        *Channel;
    unsigned char     m_ucChannelDBNum;
    TDMB_CHANNELDB_T  m_rChannelDB[10];


    //struct _TDMB_SERVICEDB    *Next;
    unsigned int                Tag;
    unsigned int            ChannelCount;


} TDMB_SERVICEDB_T;

typedef struct
{
    // TDMB_DBSTATE
    unsigned char        m_ucStateNum;
    unsigned int         m_u4State[10];

    unsigned int         Band;
    unsigned int         Frequency;
    unsigned short       Id;
    unsigned int         SvcNum;
    unsigned int         SvcCompNum;
    unsigned int         SubChNum;
    char                 Label[20];

    // TDMB_EnsembleInfo
    unsigned char   AlFlag;             // 1bit     Al flag
    unsigned char   NumSubCh;
    unsigned char   NumSvc;
    unsigned char   NumProgram;
    unsigned char   NumSvcComp;
    unsigned char   NumUserApp;
    unsigned char   NumAnn;
    unsigned char   NumProgType;
    unsigned char   EnsemLabel[16];     // 16bytes  Ensemble Label
    unsigned short  CharacterFlag;
    unsigned short  EId;                // 16bits   country Id Ensemble reference

    // TDMB_SERVICEDB[]
    unsigned char   m_ucServiceDBNum;
    TDMB_SERVICEDB_T  m_rServiceDB[10];

    unsigned int     Tag;

} TDMB_ENSEMBLEDB_T;


typedef struct   // for META APP
{
    unsigned char      m_ucEnsembleNum;
    TDMB_ENSEMBLEDB_T  m_rEnsembleDB[10];

} TDMB_GET_ENSM_INFO_BY_AUTO_SCAN_CNF_T;

typedef struct   // for META APP
{
    char m_cResult; // 0: success,
    // 1: the band not exist  ==> META_TDMB_ERR_BAND_NOT_EXIST
    // 2: frequency not exist ==> META_TDMB_ERR_FREQ_NOT_EXIST

    unsigned char      m_ucEnsembleNum;
    TDMB_ENSEMBLEDB_T  m_rEnsembleDB[10];
    TDMB_ENSEMBLEDB_T  m_rCurEnsembleDB;

} TDMB_SET_FREQ_CNF_T;


typedef struct
{
    unsigned short m_u2Snr;
    unsigned char  m_ucBer_a;  // a.b*10^-c
    unsigned char  m_ucBer_b;
    unsigned char  m_ucBer_c;
    short          m_i2RSSI;

} TDMB_GET_SIGNAL_CNF_T;

typedef struct
{
    unsigned int m_u4ServiceId;
    unsigned int m_u4SubChnId;
    char*         m_pcfilepath; // store the TS stream data to this file

} TDMB_SEL_SERVICE_REQ_T;

typedef struct
{
    unsigned int m_u4ServiceId;
    unsigned int m_u4SubChnId;

} TDMB_SEL_SERVICE_ONLY_REQ_T;



typedef struct  //  for Meta APP only
{
    unsigned char      m_ucEnsembleNum;
    TDMB_ENSEMBLEDB_T  m_rEnsembleDB[10];
    TDMB_ENSEMBLEDB_T  m_rCurEnsembleDB;

} TDMB_GET_ENSM_CNF_T;
// --------------------------//
//      TDMB callback        //
// --------------------------//
typedef enum
{
    TDMB_FAT_DISK_FULL = 0
                         , TDMB_FAT_UNKNOWN_WRITE_ERROR
    , TDMB_MED_MEMORY_FULL
    , TDMB_MED_MEMORY_NOT_EXIST

} TDMB_SEL_SERV_ERROR_RESULT;

typedef void (__stdcall* META_TDMB_SEL_SERV_CNF)(const TDMB_SEL_SERV_ERROR_RESULT status);

//--------------------------//
//      TDMB Functions      //
//--------------------------//

META_RESULT  __stdcall META_TDMB_TurnOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_TDMB_TurnOn_r(const int meta_handle, unsigned int ms_timeout);

// send band may return: META_TDMB_ERR_BAND_NOT_EXIST, META_SUCCESS, META_FAILED
META_RESULT __stdcall META_TDMB_SetBand(unsigned int ms_timeout, TDMB_SET_BAND_REQ_T* req);
META_RESULT __stdcall META_TDMB_SetBand_r(const int meta_handle, unsigned int ms_timeout, TDMB_SET_BAND_REQ_T* req);

META_RESULT __stdcall META_TDMB_AutoScan_GetFreq(unsigned int ms_timeout, TDMB_AUTO_SCAN_CNF_T* cnf);
META_RESULT __stdcall META_TDMB_AutoScan_GetFreq_r(const int meta_handle, unsigned int ms_timeout, TDMB_AUTO_SCAN_CNF_T* cnf);

META_RESULT __stdcall META_TDMB_SetFreq(unsigned int ms_timeout, TDMB_SET_FREQ_REQ_T* req, TDMB_SET_FREQ_CNF_T* cnf);
META_RESULT __stdcall META_TDMB_SetFreq_r(const int meta_handle, unsigned int ms_timeout, TDMB_SET_FREQ_REQ_T* req, TDMB_SET_FREQ_CNF_T* cnf);

META_RESULT __stdcall META_TDMB_AutoScan_GetEnsemble(unsigned int ms_timeout, TDMB_GET_ENSM_INFO_BY_AUTO_SCAN_CNF_T* cnf);
META_RESULT __stdcall META_TDMB_AutoScan_GetEnsemble_r(const int meta_handle, unsigned int ms_timeout, TDMB_GET_ENSM_INFO_BY_AUTO_SCAN_CNF_T* cnf);

META_RESULT __stdcall META_TDMB_GetSignal(unsigned int ms_timeout, TDMB_GET_SIGNAL_CNF_T* cnf);
META_RESULT __stdcall META_TDMB_GetSignal_r(const int meta_handle, unsigned int ms_timeout, TDMB_GET_SIGNAL_CNF_T* cnf);

//META_RESULT __stdcall META_TDMB_SelService(unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T *req);
//META_RESULT __stdcall META_TDMB_SelService_r(const int meta_handle, unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T *req);

META_RESULT __stdcall META_TDMB_SelService(unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T* req, const META_TDMB_SEL_SERV_CNF  cnf_cb);
META_RESULT __stdcall META_TDMB_SelService_r(const int meta_handle, unsigned int ms_timeout, TDMB_SEL_SERVICE_REQ_T* req, const META_TDMB_SEL_SERV_CNF  cnf_cb);

//META_RESULT __stdcall META_TDMB_SetIdle(unsigned int ms_timeout);
//META_RESULT __stdcall META_TDMB_SetIdle_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT __stdcall META_TDMB_SetIdle(unsigned int ms_timeout, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg);
META_RESULT __stdcall META_TDMB_SetIdle_r(const int meta_handle, unsigned int ms_timeout, CALLBACK_META_FAT_PROGRESS  cb_progress, void*  cb_progress_arg);


META_RESULT __stdcall META_TDMB_TurnOff(unsigned int ms_timeout);
META_RESULT __stdcall META_TDMB_TurnOff_r(const int meta_handle, unsigned int ms_timeout);

META_RESULT __stdcall META_TDMB_GetEnsm(unsigned int ms_timeout, TDMB_GET_ENSM_CNF_T* cnf);
META_RESULT __stdcall META_TDMB_GetEnsm_r(const int meta_handle, unsigned int ms_timeout, TDMB_GET_ENSM_CNF_T* cnf);

META_RESULT __stdcall META_TDMB_SelServiceOnly( unsigned int ms_timeout, TDMB_SEL_SERVICE_ONLY_REQ_T* req);
META_RESULT __stdcall META_TDMB_SelServiceOnly_r(const int meta_handle, unsigned int ms_timeout, TDMB_SEL_SERVICE_ONLY_REQ_T* req);


META_RESULT __stdcall META_TDMB_StopAutoScan(unsigned int ms_timeout);
META_RESULT __stdcall META_TDMB_StopAutoScan_r(const int meta_handle, unsigned int ms_timeout);

//----------------------------------------------------------------------//
//       META Misc: backup and restore calibration Data
//----------------------------------------------------------------------//


typedef void (__stdcall* CALLBACK_MISC_PROGRESS)(unsigned char m_u1TotalNum, unsigned char m_u1BackupNum, void* usr_arg);
typedef void (__stdcall* CALLBACK_MISC_IMEI_PROGRESS)(const int imei_max_num, const char** errMsg, const char** imei, void* usr_arg);
typedef void (__stdcall* CALLBACK_MISC_MACADDR_PROGRESS)(const char* message, const char* mac_addr, void* usr_arg);

typedef enum
{
    META_STORAGE_TYPE_FAT = 0,
    META_STORAGE_TYPE_OTP,
    META_STORAGE_TYPE_SECRO,
    META_STORAGE_TYPE_END
} META_IMEI_LOC_enum;

typedef struct
{
    char*                    m_pIniFilePath;
    char*                    m_pBackupFolderPath; // Let customer choose the backup folder
    //Note: it should be different by meta_handle!
    CALLBACK_MISC_PROGRESS  cb_progress;
    void*                    cb_progress_arg;
} MISC_BACKUP_REQ_T;



typedef struct
{
    char*                    m_pIniFilePath;
    char*                    m_pBackupFolderPath; // the folder which store the backup data
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                     cb_progress_arg;

} MISC_RESTORE_REQ_T;

typedef struct
{
    /// restore request
    MISC_RESTORE_REQ_T              restoreRequest;
    /// file transfer progress callback function
    CALLBACK_META_FAT_PROGRESS      cb_filetransfer_progress;
    /// user argument for file transfer progress callback
    void*                           filetransfer_arg;
} MISC_RESTORE_REQ_EX_T;

typedef struct
{
    char                 m_strBackupFolder[MAX_PATH];
    bool                 m_bISNewLoad;
    META_IMEI_LOC_enum   m_enumImeiLoc; // only valid when m_bISNewLoad = true;
    unsigned  char       m_ImeiData[10]; // only valid when m_bISNewLoad = true
    int                  m_i4ComPort;
    int                  m_i4BackupFileNum;

} BACKUP_RESULT_T;

typedef struct
{

    char                    m_strRestoreFromFolder[MAX_PATH];
    bool                    m_bISNewLoad;
    META_IMEI_LOC_enum      m_enumImeiLoc; // only valid when m_bISNewLoad = true;
    unsigned char           m_ImeiData[10]; // only valid when m_bISNewLoad = true;
    int                     m_i4ComPort;
    int                     m_i4BackupFileNum;


} RESTORE_RESULT_T;

typedef struct
{
    char*                    m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                     cb_progress_arg;

} MISC_UPLOAD_REQ_T;

typedef struct
{
    char*                    m_pIniFilePath; // the INI file path
    CALLBACK_MISC_PROGRESS   cb_progress;
    void*                     cb_progress_arg;
    CALLBACK_MISC_IMEI_PROGRESS   cb_imei_progress;
    void*                     cb_imei_progress_arg;
} MISC_UPLOAD_REQ_EX_T;

typedef struct
{
    MISC_UPLOAD_REQ_EX_T            uploadRequest;
    CALLBACK_META_FAT_PROGRESS      cb_filetransfer_progress;
    void*                           filetransfer_arg;
    CALLBACK_MISC_MACADDR_PROGRESS  cb_macaddr_progress;
    void*                           macaddr_arg;
} MISC_UPLOAD_REQ_EX2_T;

typedef struct
{
    char            imei[16];
    unsigned short  record_index;
    unsigned char   svn;
} META_SET_IMEI_T;

typedef struct
{
    unsigned short record_index;  /**< \brief [IN]  the index of imei record, if want to read record1 must be set 1 */
    char           imei[16];      /**< \brief [OUT] the value of IMEI */
    unsigned char  svn;           /**< \brief [OUT] the svn of IMEI */
} META_GET_IMEI_T;

typedef struct
{
    unsigned short record_index;  /**< \brief [IN]  the index of barcode record, if want to read record1 must be set 1 */
    unsigned int   bufferLength;  /**< \brief [IN]  the length of barcode buffer */
    char*          buffer;        /**< \brief [OUT] the buffer of barcode */
} META_GET_BARCODE_T;

typedef struct
{
    unsigned char wifi_mac[6];
} META_SET_WIFI_T;

META_RESULT __stdcall META_MISC_GetIMEILocation(const unsigned int ms_timeout, META_IMEI_LOC_enum* storagetype);
META_RESULT __stdcall META_MISC_GetIMEILocation_r(const int meta_handle, const unsigned int ms_timeout, META_IMEI_LOC_enum* storagetype);
META_RESULT __stdcall META_MISC_GetIMEIRecNum(const unsigned int ms_timeout, unsigned short* rec_num);
META_RESULT __stdcall META_MISC_GetIMEIRecNum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* rec_num);

META_RESULT __stdcall META_MISC_QueryNVRAMFolderAmount(const unsigned int ms_timeout, unsigned char* folder_amount);
META_RESULT __stdcall META_MISC_QueryNVRAMFolderAmount_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* folder_amount);

META_RESULT __stdcall META_MISC_CheckSIM1Inserted(const unsigned int ms_timeout, unsigned char* inserted);
META_RESULT __stdcall META_MISC_CheckSIM1Inserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* inserted);

META_RESULT __stdcall META_MISC_CheckSIM2Inserted(const unsigned int ms_timeout, unsigned char* inserted);
META_RESULT __stdcall META_MISC_CheckSIM2Inserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* inserted);

META_RESULT __stdcall META_MISC_CheckGeminiPlusSIMInserted(const unsigned int ms_timeout, unsigned char sim_module_index, unsigned char* inserted);
META_RESULT __stdcall META_MISC_CheckGeminiPlusSIMInserted_r(const int meta_handle, const unsigned int ms_timeout, unsigned char sim_module_index, unsigned char* inserted);

#define MUIC_MODE_CHARGE_ON     0
#define MUIC_MODE_CHARGE_OFF    1
#define MUIC_MODE_USB_500       2
#define MUIC_MODE_ISET_PROGRAM  3
#define MUIC_MODE_USB_100       4
#define MUIC_MODE_TEST_MODE     5
#define MUIC_MODE_USB_100_2     6

META_RESULT __stdcall META_MISC_SetMuicChargerMode(const unsigned int ms_timeout, const unsigned char* req_mode);
META_RESULT __stdcall META_MISC_SetMuicChargerMode_r(const int meta_handle, const unsigned int ms_timeout, const unsigned char* req_mode);


typedef struct
{
    const char*          LID;       // The name of logical data item ID
    //signed short      u2LIDEnumVal;
    unsigned short      u2RID;  // Record ID (the first record is 1)
} META_MISC_CAL_DATA_INTEGRITY_ENTRY;

typedef struct
{

    bool                bAllPass;  // true: check pass, false: no items or check fail
    unsigned short      u2LastLID;  // valid when bAllPass == false
    unsigned short      u2LastRID;  // valid when bAllPass == false
} META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T;


META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec(const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_StartRec_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec(const unsigned int ms_timeout, int* rec_num);
META_RESULT __stdcall META_MISC_CalDataIntegrity_StopRec_r(const int meta_handle, const unsigned int ms_timeout, int* rec_num);
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_AddOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);

META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll(const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_DelAll_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckOne(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckOne_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_ENTRY* req);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckAll(const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T* cnf);
META_RESULT __stdcall META_MISC_CalDataIntegrity_CheckAll_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_CAL_DATA_INTEGRITY_CHECK_CNF_T* cnf);


#define META_MISC_SUPPORTED_MAX_ADC_CHN_NUM 20

typedef struct
{
    bool bADCStoredInEfuse;  // true: ADC is stored in EFUSE, not in NVRAM data.
    int  i4ADCChnNum;  // specify the adc channel number supported by this phone
    int  i4ADCSlope[META_MISC_SUPPORTED_MAX_ADC_CHN_NUM]; // [0 ~ iADCChnNum-1] is valid when bADCStoredInEfuse = true
    int  i4ADCOffset[META_MISC_SUPPORTED_MAX_ADC_CHN_NUM];// [0 ~ iADCChnNum-1] is valid when bADCStoredInEfuse = true
} META_MISC_GET_ADC_FROM_EFUSE_CNF_T;

META_RESULT __stdcall META_MISC_GetADCFromEFuse(const unsigned int ms_timeout, META_MISC_GET_ADC_FROM_EFUSE_CNF_T* cnf);
META_RESULT __stdcall META_MISC_GetADCFromEFuse_r(const int meta_handle, const unsigned int ms_timeout, META_MISC_GET_ADC_FROM_EFUSE_CNF_T* cnf);

META_RESULT __stdcall META_MISC_GetCalFlagEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
META_RESULT __stdcall META_MISC_GetCalFlagEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);

META_RESULT __stdcall META_MISC_GetRfCalEnvEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfCalEnvEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfCalLossSettingEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfCalLossSettingEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfTestPowerResultEnum(const unsigned int ms_timeout, unsigned short* u2EnumVal);
META_RESULT __stdcall META_MISC_GetRfTestPowerResultEnum_r(const int meta_handle, const unsigned int ms_timeout, unsigned short* u2EnumVal);

META_RESULT __stdcall META_MISC_GetADCMaxChannel(const unsigned int ms_timeout, unsigned char* u1Val);
META_RESULT __stdcall META_MISC_GetADCMaxChannel_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* u1Val);
META_RESULT __stdcall META_MISC_GetTADCChannelIndex(const unsigned int ms_timeout, unsigned char* u1Val);
META_RESULT __stdcall META_MISC_GetTADCChannelIndex_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* u1Val);

META_RESULT __stdcall META_MISC_GetRID(const unsigned int ms_timeout, unsigned char* u1Rid, const unsigned int ui_RidLen);
META_RESULT __stdcall META_MISC_GetRID_r(const int meta_handle, const unsigned int ms_timeout, unsigned char* u1Rid, const unsigned int ui_RidLen);

META_RESULT __stdcall META_MISC_GetIMEIValue(const unsigned int ms_timeout, META_GET_IMEI_T* req);
META_RESULT __stdcall META_MISC_GetIMEIValue_r(const int meta_handle, const unsigned int ms_timeout, META_GET_IMEI_T* req);
META_RESULT __stdcall META_MISC_GetBarCodeValue(const unsigned int ms_timeout, META_GET_BARCODE_T* req);
META_RESULT __stdcall META_MISC_GetBarCodeValue_r(const int meta_handle, const unsigned int ms_timeout, META_GET_BARCODE_T* req);

META_RESULT __stdcall META_BackupCalibrationData(const MISC_BACKUP_REQ_T* req, int* p_backupstop );
META_RESULT __stdcall META_BackupCalibrationData_r(const int meta_handle, const MISC_BACKUP_REQ_T* req, int* p_backupstop);
META_RESULT __stdcall META_RestoreCalibrationData(const MISC_RESTORE_REQ_T* req, int* p_restorestop);
META_RESULT __stdcall META_RestoreCalibrationData_r(const int meta_handle, const MISC_RESTORE_REQ_T* req, int* p_restorestop);
META_RESULT __stdcall META_RestoreCalibrationDataEx(const MISC_RESTORE_REQ_EX_T* req, int* p_restorestop);
META_RESULT __stdcall META_RestoreCalibrationDataEx_r(const int meta_handle, const MISC_RESTORE_REQ_EX_T* req, int* p_restorestop);

typedef struct
{
    // full path to the file
    const char*   fullPath;
    // file size (0: means not-avaialble in the context)
    int           fileSize;
    // LID name or enum value
    const char*   lidOrEnum;
    // type of the NVRAM file (0: normal, 1: imei, 2: SML)
    unsigned char fileType;
} META_MISC_RestoreFileNotFoundInBackupResult_T;
typedef struct
{
    // file prefix of the NVRAM item
    const char*    filePrefix;
    // verno of the NVRAM item
    const char*    versionNumber;
    // enum value
    unsigned short enumValue;
    // type of the NVRAM file (0: normal, 1: imei, 2: SML)
    unsigned char  fileType;
    // file size (0: means not-avaialble in the context)
    unsigned int   fileSize;
} META_MISC_BackupFileNotFoundInNvram_T;
typedef META_MISC_BackupFileNotFoundInNvram_T META_MISC_RestoreTargetNotFoundInNvram_T;
typedef struct
{
    // key name
    const char*   keyName;
    // value string
    const char*   value;
} META_MISC_BackupMoreFileNotFoundInNvram_T;
typedef struct
{
    // where we download from the target side
    const char*     backupPath;
    unsigned int    fileSize;
    // 1: nvram sec, 2: target sec
    unsigned char   fileSection;
    // where we store the files in PC side
    const char*     localPath;
    bool            hasLidInfo;
    // meaningful when m_bHasLID == true;
    const char*     lidInfo;
    // -1: not exist 0: general LID, 1: IMEI, 2: SML
    char            lidType;
    // store the target file path we will restore!
    const char*     restorePath;
} META_MISC_BackupFileResultEntry_T;
typedef struct
{
    META_MISC_BackupFileResultEntry_T               backupResult;
    META_MISC_RestoreFileNotFoundInBackupResult_T   restoreFileInfo;
} META_MISC_BackupFileRestoreTargetSizeMismatch_T;
typedef union
{
    META_MISC_RestoreFileNotFoundInBackupResult_T   restoreFileNotFoundInBackupResultInfo;
    META_MISC_BackupFileNotFoundInNvram_T           backupFileNotFoundInNvramInfo;
    META_MISC_RestoreTargetNotFoundInNvram_T        restoreTargetNotFoundInNvramInfo;
    META_MISC_BackupMoreFileNotFoundInNvram_T       backupMoreFileNotFoundInNvramInfo;
    META_MISC_BackupFileRestoreTargetSizeMismatch_T backupFileRestoreTargetSizeMismatchInfo;
    DWORD                                           systemErrorCode;
} META_MISC_BKRSCustomizedInformation;
typedef struct
{
    META_RESULT errorCode;
    const char* message;
    int messageLength;
    META_MISC_BKRSCustomizedInformation info;
} META_MISC_BKRSCustomizedCallbackParameter;
typedef int (__stdcall* CALLBACK_BKRS_ERROR_HANDLER)(const META_MISC_BKRSCustomizedCallbackParameter* param, void* userArg);
META_RESULT __stdcall META_MISC_SetBackupRestoreErrorCallback(CALLBACK_BKRS_ERROR_HANDLER cb, void* user_arg);
META_RESULT __stdcall META_MISC_SetBackupRestoreErrorCallback_r(const int meta_handle, CALLBACK_BKRS_ERROR_HANDLER cb, void* user_arg);

META_RESULT __stdcall META_DeleteAllFilesInBackupFolder(const char* pBackupFolderPath);
META_RESULT __stdcall META_DeleteAllFilesInBackupFolder_r(const int meta_handle, const char* pBackupFolderPath);


META_RESULT __stdcall META_GetRestoreResultInfo_r(const int meta_handle, const char* backup_folder, RESTORE_RESULT_T* cnf);
META_RESULT __stdcall META_GetRestoreResultInfo(const char* backup_folder, RESTORE_RESULT_T* cnf);
META_RESULT __stdcall META_GetBackupResultInfo(const char* backup_folder, BACKUP_RESULT_T* cnf);
META_RESULT __stdcall META_GetBackupResultInfo_r(const int meta_handle, const char* backup_folder, BACKUP_RESULT_T* cnf);

// be used in old load when IMEI and SML NVRAM files can not be accessed by File System APIs!
// i.e., IMEI and SML NVRAM files will not be backuped and restored!
META_RESULT __stdcall META_BasicBackupCalibrationData_r(const int meta_handle, const MISC_BACKUP_REQ_T* req, int* p_backupstop);
META_RESULT __stdcall META_BasicBackupCalibrationData(const MISC_BACKUP_REQ_T* req, int* p_backupstop);
META_RESULT __stdcall META_BasicRestoreCalibrationData_r(const int meta_handle, const MISC_RESTORE_REQ_T* req, int* p_restorestop);
META_RESULT __stdcall META_BasicRestoreCalibrationData(const MISC_RESTORE_REQ_T* req, int* p_restorestop);

META_RESULT __stdcall META_UploadFilesToTarget(MISC_UPLOAD_REQ_T* req, int* p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_r(const int meta_handle, MISC_UPLOAD_REQ_T* req, int* p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_Ex(MISC_UPLOAD_REQ_EX_T* req, int* p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_Ex_r(const int meta_handle, MISC_UPLOAD_REQ_EX_T* req, int* p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_Ex2(MISC_UPLOAD_REQ_EX2_T* req, int* p_uploadstop);
META_RESULT __stdcall META_UploadFilesToTarget_Ex2_r(const int meta_handle, MISC_UPLOAD_REQ_EX2_T* req, int* p_uploadstop);

META_RESULT __stdcall META_MISC_GetMmiCacheEnumIndex(const unsigned int ms_timeout, unsigned short enum_value, unsigned short* index);
META_RESULT __stdcall META_MISC_GetMmiCacheEnumIndex_r(const int meta_handle, const unsigned int ms_timeout, unsigned short enum_value, unsigned short* index);
typedef struct
{
    unsigned char sec;    // seconds after the minute   - [0,59]
    unsigned char min;    // minutes after the hour     - [0,59]
    unsigned char hour;   // hours after the midnight   - [0,23]
    unsigned char day;    // day of the month           - [1,31]
    unsigned char mon;    // months                         - [1,12]
    unsigned char wday;   // days in a week                 - [1,7]; not correct information, so don't care.
    unsigned char year;   // years                      - [0,127]
} META_RCT_INFO_T;

#define META_ERS_FILE_NAME_WCHAR_CNT  100

typedef struct
{
    WCHAR            wQueryKey[META_ERS_FILE_NAME_WCHAR_CNT];//ers_filename[META_ERS_FILE_NAME_WCHAR_CNT];
    META_RCT_INFO_T  ers_ctime;
} META_ERS_INFO_T;


META_RESULT __stdcall META_MISC_EX_GetErsCount(const unsigned int ms_timeout,  int* pCnt);
META_RESULT __stdcall META_MISC_EX_GetErsCount_r(const int meta_handle, const unsigned int ms_timeout, int* pCnt);
META_RESULT __stdcall META_MISC_EX_GetErsDataInfoByIndex(const unsigned int ms_timeout,  const int index, META_ERS_INFO_T* pCnf);
META_RESULT __stdcall META_MISC_EX_GetErsDataInfoByIndex_r(const int meta_handle, const unsigned int ms_timeout, const int index, META_ERS_INFO_T* pCnf);

META_RESULT __stdcall META_MISC_EX_GetErsSize(const unsigned int ms_timeout, unsigned int* pSize);
META_RESULT __stdcall META_MISC_EX_GetErsSize_r(const int meta_handle, const unsigned int ms_timeout, unsigned int* pSize);
//META_RESULT __stdcall META_MISC_EX_GetErsData(const unsigned int ms_timeout, const unsigned int ers_data_buf_size, unsigned char *ers_data_buffer);
//META_RESULT __stdcall META_MISC_EX_GetErsData_r(const int meta_handle, const unsigned int ms_timeout, const unsigned int ers_data_buf_size, unsigned char *ers_data_buffer);
META_RESULT __stdcall META_MISC_EX_GetErsData(const unsigned int ms_timeout, WCHAR* wfilepath, const unsigned int ers_data_buf_size, unsigned char* ers_data_buffer);
META_RESULT __stdcall META_MISC_EX_GetErsData_r(const int meta_handle, const unsigned int ms_timeout, WCHAR* wfilepath, const unsigned int ers_data_buf_size, unsigned char* ers_data_buffer);

META_RESULT __stdcall META_MISC_EX_InitBPAreaFromNVRAM(const unsigned int ms_timeout);
META_RESULT __stdcall META_MISC_EX_InitBPAreaFromNVRAM_r(const int meta_handle, const unsigned int ms_timeout);
typedef enum
{
    META_BP_AREA_STATUS_OK = 0
                             , META_BP_AREA_STATUS_EMPTY
    , META_BP_AREA_STATUS_BROKEN
    , META_BP_AREA_STATUS_NO_SYNC
    , META_BP_AREA_STATUS_UNKNOWN
} META_BP_AREA_STATUS_E;
META_RESULT __stdcall META_MISC_EX_VerifyBPArea(const unsigned int ms_timeout, bool* bFastVerify, META_BP_AREA_STATUS_E* cnf);
META_RESULT __stdcall META_MISC_EX_VerifyBPArea_r(const int meta_handle, const unsigned int ms_timeout, bool* bFastVerify, META_BP_AREA_STATUS_E* cnf);
META_RESULT __stdcall META_MISC_EX_BackupCalibrationToStorage(const unsigned int ms_timeout, unsigned int storage_mode, unsigned int* status);
META_RESULT __stdcall META_MISC_EX_BackupCalibrationToStorage_r(const int meta_handle, const unsigned int ms_timeout, unsigned int storage_mode, unsigned int* status);
//----------------------------------------------------------------//
//                            CMMB                                //
//----------------------------------------------------------------//

#define   META_CMMB_FREQ_BAND_NUM  4
#define   META_CMMB_FRAME_INFO_NUM 4

#define   META_CMMB_BLK_NUM        8
#define   META_CMMB_SERV_BLOCK_NUM   20
#define   META_CMMB_DATA_BLK_NUM     128

//--------------------------//
//    CMMB data structures  //
//--------------------------//
typedef enum
{

    META_CMMB_CHINA_U_BAND = 0
                             , META_CMMB_TAIWAN_BAND
    , META_CMMB_UNDEF_BAND
} META_CMMB_BAND_enum;

typedef struct
{
    META_CMMB_BAND_enum  m_rBand;

} META_CMMB_SET_BAND_REQ_T;



typedef struct
{
    unsigned char   m_u1FreqPointId;
    unsigned char   m_u1BandWidth;
    unsigned int    m_u4Freq;

} META_CMMB_FreqBandStruct_T;


typedef struct
{
    unsigned char   m_u1StartFreqPointId;
    unsigned char   m_u1EndFreqPointId;

} META_CMMB_FREQ_RANGE_FOR_AUTO_SCAN_REQ_T;


typedef struct
{
    unsigned char                   m_u1MainFreqNum;
    META_CMMB_FreqBandStruct_T      m_rMainFreqBand[META_CMMB_FREQ_BAND_NUM];

} META_CMMB_AUTO_SCAN_GET_FREQ_CNF_T;



//==================================================================



typedef struct
{
    unsigned char                   Nit_NitUpdateSeq;
    unsigned char                   Nit_SysTime[5]   ;
    unsigned int                    Nit_CountryCode ;

    unsigned char                   Nit_Net_NetLevel;
    unsigned short                  Nit_Net_NetId;

    unsigned char                   Nit_NetNameLen  ;


    unsigned char                   Nit_NetName[128];

    unsigned char                   Nit_FreqBand_FreqPointId;
    unsigned char                   Nit_FreqBand_BandWidth;
    unsigned int                    Nit_FreqBand_CenterFreq;

    unsigned char                   Nit_OtherFreqNum;    // at most 8 here transferred by ft task.
    unsigned char                   m_ucOtherFreqNumWeCarry;


    unsigned char                   Nit_OtherFreqBandList_FreqPointId[META_CMMB_BLK_NUM];
    unsigned char                   Nit_OtherFreqBandList_BandWidth[META_CMMB_BLK_NUM];
    unsigned int                    Nit_OtherFreqBandList_CenterFreq[META_CMMB_BLK_NUM];


    unsigned char                   Nit_NeighborNetNum;  // at most 8 here transferred by ft task.
    unsigned char                   m_ucNeightborNetWeCarray;

    unsigned char                   Nit_NeighborNetList_NetLevel[META_CMMB_BLK_NUM];
    unsigned short                  Nit_NeighborNetList_NetId[META_CMMB_BLK_NUM];
    unsigned char                   Nit_NeighborNetList_FreqPointId[META_CMMB_BLK_NUM];
    unsigned char                   Nit_NeighborNetList_BandWidth[META_CMMB_BLK_NUM];
    unsigned int                    Nit_NeighborNetList_CenterFreq[META_CMMB_BLK_NUM];


} META_CMMB_NitStruct_T;

typedef struct
{
    unsigned char                        MctUpdateSeq;
    unsigned char                        FreqPointId;


    unsigned char                        MfNum;

    unsigned char                        m_ucMfNumWeCarray;


    unsigned char                        Mf_MfId[META_CMMB_BLK_NUM];
    unsigned char                        Mf_RsRate[META_CMMB_BLK_NUM];
    unsigned char                        Mf_ByteInterleaveMode[META_CMMB_BLK_NUM];
    unsigned char                        Mf_LdpcRate[META_CMMB_BLK_NUM];
    unsigned char                        Mf_ModulationMode[META_CMMB_BLK_NUM];
    unsigned char                        Mf_ScrambleMode[META_CMMB_BLK_NUM];

    unsigned char                        Mf_TimeSlotNum[META_CMMB_BLK_NUM];

    unsigned char                        m_ucMf_TimeSlotNumWeCarray[META_CMMB_BLK_NUM];

    unsigned char                        Mf_TimeSlotId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];

    unsigned char                        Mf_SubMfNum[META_CMMB_BLK_NUM];
    unsigned char                        m_ucMf_SubMfNumWeCarry[META_CMMB_BLK_NUM];


    unsigned char                        Mf_SubMfId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];
    unsigned short                       Mf_serviceId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];

} META_CMMB_MctStruct_T;

typedef struct
{
    unsigned char                    SctUpdateSeq;
    unsigned short                   ServiceNum;
    unsigned char                    m_u1ServiceNumWeCarray;

    unsigned short                   ServiceId[META_CMMB_SERV_BLOCK_NUM];
    unsigned char                    FreqPointId[META_CMMB_SERV_BLOCK_NUM];

} META_CMMB_SctStruct_T;

typedef struct
{
    unsigned char                   EsgUpdateSeq;

    unsigned char                   NetLevel;
    unsigned short                  NetId;

    unsigned char                   LocalTimeOffset;
    unsigned char                   CharSet;

    unsigned char                   EsgServiceNum;
    unsigned char                   m_ucEsgServiceNumWeCarry;

    unsigned char                   EsgService_EsgServiceIndex[META_CMMB_BLK_NUM];
    unsigned short                  EsgService_EsgServiceId[META_CMMB_BLK_NUM];


    unsigned char                   EsgDataNum;

    unsigned char                   m_ucEsgDataNumWeCarry;
    unsigned char                   EsgData_EsgDataType[META_CMMB_BLK_NUM];

    unsigned char                   EsgData_EsgDataBlockNum[META_CMMB_BLK_NUM];
    unsigned char                   m_ucEsgData_EsgDataBlockNumWeCarry[META_CMMB_BLK_NUM];

    unsigned char                   EsgDataBlock_EsgDataBlockId[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];
    unsigned char                   EsgDataBlock_EsgDataBlockVersion[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];
    unsigned char                   EsgDataBlock_EsgServiceIndex[META_CMMB_BLK_NUM][META_CMMB_BLK_NUM];

} META_CMMB_EsgListStruct_T;

typedef struct
{
    unsigned char             CaUpdateSeq;
    unsigned short            CaDataNum;
    unsigned char             m_ucCaDataNumWeCarry;
    unsigned short            CaId[META_CMMB_BLK_NUM];
    unsigned short            ServiceId[META_CMMB_BLK_NUM];
    unsigned char             EMM_BlockUnitType[META_CMMB_BLK_NUM];
    unsigned char             ECM_BlockUnitType[META_CMMB_BLK_NUM];
    unsigned char             ECM_TransmissionType[META_CMMB_BLK_NUM];

} META_CMMB_CaListStruct_T;

typedef struct
{

    META_CMMB_NitStruct_T        m_rNit;

    META_CMMB_MctStruct_T        m_rCSmct[2]; // [0] for Cmct, [1] for Smct

    META_CMMB_SctStruct_T        m_rCSsct[2]; // [0] for Csct, [1] for Ssct


    unsigned char                  Eb_EbUpdateSeq;
    unsigned char                  Eb_EbMsgNum;
    unsigned short                 Eb_DataBlockLen;
    unsigned char                  m_ucDataBlockLenWeCarray;
    unsigned char                  Eb_DataBlock[META_CMMB_DATA_BLK_NUM];


    unsigned char                   m_ucHasEsg;
    META_CMMB_EsgListStruct_T       m_rEsg;


    unsigned char                   m_ucHasCa;
    META_CMMB_CaListStruct_T        m_rCa;


} META_CMMB_CtrlInfoTable_T;


typedef struct
{

    unsigned char                    m_u1NitUpdateSeq;
    unsigned char                    m_u1CmctUpdateSeq;
    unsigned char                    m_u1SmctUpdateSeq;
    unsigned char                    m_u1CsctUpdateSeq;
    unsigned char                    m_u1SsctUpdateSeq;
    unsigned char                    m_u1EsgUpdateSeq;
    unsigned char                    m_u1FreqPointId;


    unsigned char                    m_u1NetLevel;
    unsigned short                   m_u2NetId;

    unsigned char                    m_u1HasCtrlTable;  // 0: no, 1: yes
    META_CMMB_CtrlInfoTable_T        m_rCtrlTableInfo;


} META_CMMB_FrameInfo_T;

typedef struct
{
    unsigned char                m_u1FrmNum;
    META_CMMB_FrameInfo_T        m_rFrmInfo[META_CMMB_FRAME_INFO_NUM];

} META_CMMB_AUTO_SCAN_CNF_T;

typedef struct
{
    unsigned char                m_u1FrmNum;
    META_CMMB_FrameInfo_T        m_rFrmInfo[META_CMMB_FRAME_INFO_NUM];

} META_CMMB_SET_FREQ_CNF_T;


typedef struct
{
    unsigned char m_u1FreqPointId;

} CMMB_SET_FREQ_REQ_T;

typedef struct
{
    unsigned char    m_u1FrmId;
    unsigned short   m_u2ServId;

} CMMB_SEL_SERV_REQ_ONLY_T;

typedef struct
{
    unsigned char    m_u1FrmId;
    unsigned short   m_u2ServId;
} META_CMMB_PAUSE_SERV_REQ_T;

typedef struct
{
    unsigned char   m_u1FreqPointId;
    char            m_i1Rssi;                 // unit: -dBm 0~100, 0 is best  , -1 means no such kinds of value
    char            m_i1Snr;                  // unit: dBm  0~100, 100 is best, -1 means no such kinds of value
    char            m_i1CurLdpcErrPercent;    // unit: %    0~100, 0 is best  , -1 means no such kinds of value

    int            m_i4TotalLdpcErrCnt;      // unit: -1 means no such kinds of value
    int            m_i4TotalLdpcCnt;         // unit: -1 means no such kinds of value

    int             m_i4CurRsErrorCnt;    // -1 means no such kinkds of value
    int             m_i4TotalRsErrorCnt;  // -1 means no such kinkds of value
    /* Added in W1112 */
    int             m_i4InBandPwr;
    unsigned int    m_u4IsDemodLocked;
    unsigned char   m_u1ReceptionQuality;
    unsigned int    m_u4signal_strength_indication;
} META_CMMB_GET_SIGNAL_STRENGTH_CNF_T;

/*

typedef struct
{
    unsigned char  m_u1TableItem;
    unsigned char  m_u1NetLevel;
    unsigned short m_u2NetId;
    unsigned char  m_u1FreqPointId;
    unsigned short m_u2ServiceId;

}META_CMMB_GET_TABLE_REQ_T;


typedef struct
{
    unsigned char  m_u1TableItem;  // 0: NIT, 1: MCT, 2:SCT, 4:EB, 5:ESG_BASIC
    unsigned char  m_u1NetLevel;
    unsigned short m_u2NetId;
    unsigned char  m_u1FreqPointId;
    unsigned short m_u2ServiceId;

}CMMB_GET_TABLE_CNF_T;
*/


//--------------------------//
//      CMMB Functions      //
//--------------------------//
META_RESULT  __stdcall META_CMMB_TurnOn(const unsigned int ms_timeout);
META_RESULT  __stdcall META_CMMB_TurnOn_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT  __stdcall META_CMMB_TurnOff(const unsigned int ms_timeout);
META_RESULT  __stdcall META_CMMB_TurnOff_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall  META_CMMB_SetBand(const unsigned int ms_timeout, const META_CMMB_SET_BAND_REQ_T* req);
META_RESULT __stdcall  META_CMMB_SetBand_r(const int meta_handle, const unsigned int ms_timeout, const META_CMMB_SET_BAND_REQ_T* req);
META_RESULT __stdcall  META_CMMB_AutoScanGetFreq(const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_GET_FREQ_CNF_T* cnf);
META_RESULT __stdcall  META_CMMB_AutoScanGetFreq_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_GET_FREQ_CNF_T* cnf);

META_RESULT __stdcall  META_CMMB_AutoScan(const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_CNF_T* cnf);
META_RESULT __stdcall  META_CMMB_AutoScan_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_AUTO_SCAN_CNF_T* cnf);


META_RESULT __stdcall  META_CMMB_StopAutoScan(const unsigned int ms_timeout);
META_RESULT __stdcall  META_CMMB_StopAutoScan_r(const int meta_handle, const unsigned int ms_timeout);
META_RESULT __stdcall  META_CMMB_SetFreq(const unsigned int ms_timeout, const CMMB_SET_FREQ_REQ_T* req, META_CMMB_SET_FREQ_CNF_T* cnf);
META_RESULT __stdcall  META_CMMB_SetFreq_r(const int meta_handle, const unsigned int ms_timeout, const CMMB_SET_FREQ_REQ_T* req, META_CMMB_SET_FREQ_CNF_T* cnf);

META_RESULT __stdcall  META_CMMB_SelServOnly(const unsigned int ms_timeout, const CMMB_SEL_SERV_REQ_ONLY_T* pSelServReq);
META_RESULT __stdcall  META_CMMB_SelServOnly_r(const int meta_handle, const unsigned int ms_timeout, const CMMB_SEL_SERV_REQ_ONLY_T* pSelServReq);
META_RESULT __stdcall  META_CMMB_PauseServ(unsigned int ms_timeout, const META_CMMB_PAUSE_SERV_REQ_T* req);
META_RESULT __stdcall  META_CMMB_PauseServ_r(const int meta_handle, unsigned int ms_timeout, const META_CMMB_PAUSE_SERV_REQ_T* req);


META_RESULT __stdcall  META_CMMB_GetSignalStrength(const unsigned int ms_timeout, META_CMMB_GET_SIGNAL_STRENGTH_CNF_T* cnf);
META_RESULT __stdcall  META_CMMB_GetSignalStrength_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_GET_SIGNAL_STRENGTH_CNF_T* cnf);


META_RESULT __stdcall  META_CMMB_AutoScanWithFreqRange(const unsigned int ms_timeout, META_CMMB_FREQ_RANGE_FOR_AUTO_SCAN_REQ_T* req, META_CMMB_AUTO_SCAN_CNF_T* cnf);
META_RESULT __stdcall  META_CMMB_AutoScanWithFreqRange_r(const int meta_handle, const unsigned int ms_timeout, META_CMMB_FREQ_RANGE_FOR_AUTO_SCAN_REQ_T* req, META_CMMB_AUTO_SCAN_CNF_T* cnf);


//===== Customized function ========================

META_RESULT __stdcall META_Customer_Func(int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);
META_RESULT __stdcall META_Customer_Func_r(int meta_handle, int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);


META_RESULT __stdcall META_Aux_Func(int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);
META_RESULT __stdcall META_Aux_Func_r(int meta_handle, int ms_timeout, const unsigned char* data_in, const int data_in_len, unsigned char* data_out, int* data_out_len);

// MATV functions
typedef struct
{
    unsigned int    freq;
    unsigned char   sndsys;
    unsigned char   colsys;
    unsigned char   flag;
} matv_ch_entry;

typedef struct
{
    unsigned char   m_ucChannel;
    matv_ch_entry   m_rmatv_ch_entry;
} FT_MATV_SET_CHANNEL_PROPERTY_REQ_T;

typedef struct
{
    unsigned char   m_ucProgress;
    unsigned char   m_ucChannels;
    matv_ch_entry   m_rmatv_ch_entry[70];
} FT_MATV_GET_CHANNEL_LIST_CNF_T;

typedef struct
{
    int             m_i4QualityIndex[128];
} FT_MATV_GET_CHANNEL_QUALITY_ALL_CNF_T;

META_RESULT  __stdcall META_MATV_PowerOn(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_PowerOn_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_PowerOff(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_PowerOff_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_SetRegion(unsigned int ms_timeout, unsigned char region);
META_RESULT  __stdcall META_MATV_SetRegion_r(const int meta_handle, unsigned int ms_timeout, unsigned char region);
META_RESULT  __stdcall META_MATV_StartScan(unsigned int ms_timeout, unsigned int scanmode);
META_RESULT  __stdcall META_MATV_StartScan_r(const int meta_handle, unsigned int ms_timeout, unsigned char scanmode);
META_RESULT  __stdcall META_MATV_StartFullScan(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_StartFullScan_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_StopScan(unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_StopScan_r(const int meta_handle, unsigned int ms_timeout);
META_RESULT  __stdcall META_MATV_GetChannelList(unsigned int ms_timeout, FT_MATV_GET_CHANNEL_LIST_CNF_T* cnf);
META_RESULT  __stdcall META_MATV_GetChannelList_r(const int meta_handle, unsigned int ms_timeout, FT_MATV_GET_CHANNEL_LIST_CNF_T* cnf);
META_RESULT  __stdcall META_MATV_ChangeChannel(unsigned int ms_timeout, unsigned char channel);
META_RESULT  __stdcall META_MATV_ChangeChannel_r(const int meta_handle, unsigned int ms_timeout, unsigned char channel);
META_RESULT  __stdcall META_MATV_SetChannelProperty(unsigned int ms_timeout, FT_MATV_SET_CHANNEL_PROPERTY_REQ_T* req);
META_RESULT  __stdcall META_MATV_SetChannelProperty_r(const int meta_handle, unsigned int ms_timeout, FT_MATV_SET_CHANNEL_PROPERTY_REQ_T* req);
META_RESULT  __stdcall META_MATV_GetChannelQuality(unsigned int ms_timeout, unsigned short item, int* qualityindex);
META_RESULT  __stdcall META_MATV_GetChannelQuality_r(const int meta_handle, unsigned int ms_timeout, unsigned short index, int* qualityindex);
META_RESULT  __stdcall META_MATV_GetChannelQualityAll(unsigned int ms_timeout, FT_MATV_GET_CHANNEL_QUALITY_ALL_CNF_T* channel_quality);
META_RESULT  __stdcall META_MATV_GetChannelQualityAll_r(const int meta_handle, unsigned int ms_timeout, FT_MATV_GET_CHANNEL_QUALITY_ALL_CNF_T* channel_quality);

// CCT
typedef struct
{
    char sensor_prefix_name[64];
} CCT_Dual_Dev_ISP_camera_sensor_prefix_name_struct;

typedef struct
{
    char lens_prefix_name[64];
} CCT_Dual_Dev_ISP_camera_lens_prefix_name_struct;


/*************************************************
 *============== Audio Ex Operation===============
 *************************************************/

#define META_L4AUD_VOL_TYPE_TONE 0 // Tone
#define META_L4AUD_VOL_TYPE_KT   1 // keytone
#define META_L4AUD_VOL_TYPE_MIC  2 // microphone
#define META_L4AUD_VOL_TYPE_FMR  3  // FM Radio
#define META_L4AUD_VOL_TYPE_SPH  4  // speech
#define META_L4AUD_VOL_TYPE_SID  5   // side tne
#define META_L4AUD_VOL_TYPE_MEDIA 6  // media
#define META_L4AUD_VOL_TYPE_TVOUT 7  // TV-out

#define META_L4AUD_PATH_UNKNOWN   0x00
#define META_L4AUD_PATH_RECEIVER  0x01
#define META_L4AUD_PATH_HEADSET   0x02
#define META_L4AUD_PATH_SPEAKER   0x04
#define META_L4AUD_PATH_DUAL      0x08
#define META_L4AUD_PATH_BT        0x10


#define META_L4AUD_PGA_BUF_AUDIO   0
#define META_L4AUD_PGA_BUF_VOICE   1
#define META_L4AUD_PGA_BUF_UNKNOWN 2
#define META_L4AUD_PGA_BUF_MIC     3


#define META_L4AUD_GAIN_TABLE_UNKNOWN   -1
#define META_L4AUD_GAIN_TABLE_PURE       0
#define META_L4AUD_GAIN_TABLE_RAW        1
#define META_L4AUD_GAIN_TABLE_N_LEVEL    2


typedef struct
{
    unsigned char  u1VolType;
    unsigned char  u1PathType;
    unsigned short u2SIdx; //start index: from 0
    unsigned short  u2EIdx; // end index
    bool           b_digital_gain_support;
    char           i1BufType;
    unsigned char  u1ExtAmpType; //0/L1SP_EXT_DAC_BUF0(0x40)/L1SP_EXT_DAC_BUF1(0x80)
    char           i1GainTableType;  // 0: only 8 bits
    unsigned short u2BufLevel;
    unsigned short u2ExtAmpCtrlPointNum;
} ft_l4aud_ex_gain_table_info_T;


#define AUDIO_EX_GAIN_TABLE_MAP_ENTRY_MAX_NUM 100

typedef struct
{
    unsigned char u1EntryNum;
    ft_l4aud_ex_gain_table_info_T gain_table_info[AUDIO_EX_GAIN_TABLE_MAP_ENTRY_MAX_NUM];
} Audio_Ex_GainTableMap_CNF_T;

META_RESULT __stdcall META_Audio_EX_GetGainTableMap(const unsigned int ms_timeout, Audio_Ex_GainTableMap_CNF_T* cnf);
META_RESULT __stdcall META_Audio_EX_GetGainTableMap_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_GainTableMap_CNF_T* cnf);

META_RESULT  __stdcall META_GetGainTable_Next(int find_handle);
META_RESULT __stdcall META_GetGainTable_GetDetailedInfo(int find_handle,
        unsigned char* vol_type,
        unsigned char* path_type,
        unsigned short* s_idx,
        unsigned short* e_idx,
        char* main_title,
        int main_title_len,
        char* sub_title,
        int sub_title_len);
META_RESULT __stdcall META_GetGainTable_Close(int* p_find_handle);

META_RESULT __stdcall META_GetGainTable_Start(const unsigned int ms_timeout, int* p_find_handle);
META_RESULT __stdcall META_GetGainTable_Start_r(const int meta_handle, const unsigned int ms_timeout, int* p_find_handle);


typedef struct
{
    char   i1BufType;
    unsigned short  u2BufLevel;
} Audio_Ex_GetPgaGainMap_REQ_T; //ft_l4aud_get_pga_gain_map_T;

typedef struct
{
    unsigned char   u1ExtDac;
    unsigned short u2CtrlPoint;
} Audio_Ex_GetExtAmpMap_REQ_T; //ft_l4aud_get_ext_amp_map_T;


#define AUDIO_EX_MAP_ENTRY_MAX_NUM 1000

typedef struct
{
    unsigned short u2EntryNum;
    char  i1MapInfo[AUDIO_EX_MAP_ENTRY_MAX_NUM];
} Audio_Ex_GainMap_CNF_T;

typedef struct
{
    unsigned char  u1BitNum;
    unsigned short u2EntryNum;
    char  i1MapInfo[AUDIO_EX_MAP_ENTRY_MAX_NUM];
} Audio_Ex_ExtAmpGainMap_CNF_T;


META_RESULT __stdcall META_Audio_EX_GetPgaGainMap(const unsigned int ms_timeout,
        Audio_Ex_GetPgaGainMap_REQ_T* req,
        Audio_Ex_GainMap_CNF_T* cnf);
META_RESULT __stdcall META_Audio_EX_GetPgaGainMap_r(const int meta_handle,
        const unsigned int ms_timeout,
        Audio_Ex_GetPgaGainMap_REQ_T* req,
        Audio_Ex_GainMap_CNF_T* cnf);

META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMap(const unsigned int ms_timeout,
        Audio_Ex_GetExtAmpMap_REQ_T* req,
        Audio_Ex_ExtAmpGainMap_CNF_T* cnf);
META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMap_r(const int meta_handle,
        const unsigned int ms_timeout,
        Audio_Ex_GetExtAmpMap_REQ_T* req,
        Audio_Ex_ExtAmpGainMap_CNF_T* cnf);

typedef struct
{
    /// number of bits per field
    unsigned char  u1BitNum;
    /// number of entries
    unsigned short u2EntryNum;
    /// scale factor of each map entry (if scale_factor is 2, the value of map entry should be divided by 10^2
    unsigned char  scale_factor;
    /// map entries
    short          i2MapInfo[AUDIO_EX_MAP_ENTRY_MAX_NUM];
} Audio_Ex_ExtAmpGainMap_CNF_Ex_T;
META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMapEx(const unsigned int ms_timeout,
        Audio_Ex_GetExtAmpMap_REQ_T* req,
        Audio_Ex_ExtAmpGainMap_CNF_Ex_T* cnf);

META_RESULT __stdcall META_Audio_EX_GetExtAmpGainMapEx_r(const int meta_handle,
        const unsigned int ms_timeout,
        Audio_Ex_GetExtAmpMap_REQ_T* req,
        Audio_Ex_ExtAmpGainMap_CNF_Ex_T* cnf);

typedef enum
{
    MEDIA_FORMAT_GSM_FR,
    MEDIA_FORMAT_GSM_HR,
    MEDIA_FORMAT_GSM_EFR,
    MEDIA_FORMAT_AMR,
    MEDIA_FORMAT_AMR_WB,
    MEDIA_FORMAT_DAF,
    MEDIA_FORMAT_AAC,
    MEDIA_FORMAT_PCM_8K,
    MEDIA_FORMAT_PCM_16K,
    MEDIA_FORMAT_G711_ALAW,
    MEDIA_FORMAT_G711_ULAW,
    MEDIA_FORMAT_DVI_ADPCM,
    MEDIA_FORMAT_VRD,
    MEDIA_FORMAT_WAV,
    MEDIA_FORMAT_WAV_ALAW,
    MEDIA_FORMAT_WAV_ULAW,
    MEDIA_FORMAT_WAV_DVI_ADPCM,
    MEDIA_FORMAT_SMF,
    MEDIA_FORMAT_IMELODY,
    MEDIA_FORMAT_SMF_SND,
    MEDIA_FORMAT_MMF,
    MEDIA_FORMAT_AU,
    MEDIA_FORMAT_AIFF,
    MEDIA_FORMAT_VRSI,
    MEDIA_FORMAT_WMA,
    MEDIA_FORMAT_M4A,
    MEDIA_FORMAT_WAV_DVI_ADPCM_16K,
    MEDIA_FORMAT_VOIPEVL,
    MEDIA_FORMAT_AAC_PLUS,
    MEDIA_FORMAT_AAC_PLUS_V2,
    MEDIA_FORMAT_BSAC,
    MEDIA_FORMAT_MUSICAM = 32,
    MEDIA_FORMAT_AWB_PLUS,
    MEDIA_FORMAT_AWB_PLUS_EXTEND,
    MEDIA_FORMAT_WAV_16K,
    MEDIA_FORMAT_MP4_AAC,
    MEDIA_FORMAT_MP4_AMR,
    MEDIA_FORMAT_MP4_AMR_WB,
    MEDIA_FORMAT_MP4_BSAC,
    MEDIA_FORMAT_DRA,
    MEDIA_FORMAT_COOK,
    MEDIA_FORMAT_APE,
    MEDIA_FORMAT_UNKNOWN
} Media_Format;

typedef struct
{
    /// format MEDIA_FORMAT_WAV_DVI_ADPCM (narrow-band), MEDIA_FORMAT_WAV_DVI_ADPCM_16K (wide-band)
    unsigned int   fmt;
    /// parameter (0: for MEDIA_FORMAT_WAV_DVI_ADPCM/MEDIA_FORMAT_WAV_DVI_ADPCM_16K)
    unsigned short param;
    /// requested time(ms)
    unsigned int   requested_time;
    /// [IN/OUT] file path of target (set all the buffer to NULL means the target will create file on its own)
    char           file_path[512];
    /// [IN] input volume
    unsigned char  inputVolume;
} Audio_Ex_RecordingParam_T;

META_RESULT  __stdcall META_Audio_EX_StartRecording(unsigned int ms_timeout, const Audio_Ex_RecordingParam_T* param);
META_RESULT  __stdcall META_Audio_EX_StartRecording_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_RecordingParam_T* param);
META_RESULT  __stdcall META_Audio_EX_StartRecordingEx(unsigned int ms_timeout, const Audio_Ex_RecordingParam_T* param, int* status);
META_RESULT  __stdcall META_Audio_EX_StartRecordingEx_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_RecordingParam_T* param, int* status);
typedef struct
{
    /// file path of target
    char     target_path[512];
    /// file path of local
    char     local_path[512];
    /// get file from target or not
    int      get_file;
    /// delete target side file or not
    int      delete_file;
    /// progress callback
    CALLBACK_META_FAT_PROGRESS cb;
    /// stop flag
    int      stop_flag;
} Audio_Ex_StopRecording_T;

META_RESULT  __stdcall META_Audio_EX_StopRecording(unsigned int ms_timeout, const Audio_Ex_StopRecording_T* req);
META_RESULT  __stdcall META_Audio_EX_StopRecording_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_StopRecording_T* req);
META_RESULT  __stdcall META_Audio_EX_StopRecordingEx(unsigned int ms_timeout, const Audio_Ex_StopRecording_T* req, int* status);
META_RESULT  __stdcall META_Audio_EX_StopRecordingEx_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_StopRecording_T* req, int* status);
typedef struct
{
    /// requested time(ms)
    unsigned int requested_time;
    /// recorded time(ms)
    unsigned int offset;
} Audio_Ex_QueryRecording_T;

META_RESULT  __stdcall META_Audio_EX_QueryRecording(unsigned int ms_timeout, Audio_Ex_QueryRecording_T* status);
META_RESULT  __stdcall META_Audio_EX_QueryRecording_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_QueryRecording_T* status);

typedef struct
{
    unsigned char  u1SpeechModeNum;
    unsigned char  u1SpeechModeParaMaxNum;
    unsigned short u2ModeTitelBufLen;
    char*          i1ModeTileBuf;
} Audio_Ex_Speech_Mode_Table_CNF_T;

META_RESULT __stdcall META_Audio_EX_GetSpeechModeTable(const unsigned int ms_timeout, Audio_Ex_Speech_Mode_Table_CNF_T* cnf);
META_RESULT __stdcall META_Audio_EX_GetSpeechModeTable_r(const int meta_handle, const unsigned int ms_timeout, Audio_Ex_Speech_Mode_Table_CNF_T* cnf);

#define FT_L1SP_MICROPHONE1  0
#define FT_L1SP_MICROPHONE2  1
#define FT_L1SP_SPEAKER1     2
#define FT_L1SP_SPEAKER2     3
#define FT_L1SP_LOUD_SPEAKER 4
typedef struct
{
    /// PCM2WAY format (0, 1, 2)
    unsigned int   format;
    /// specify the play wave file drive letter
    /// (this is queried by META_Util_QueryDriveAvailableForFileSize_r first)
    /// The application should put the file to the root folder of playDrive for example "c:\"
    /// the file name is always echo_play.wav for example "c:\echo_play.wav"
    short          playDrive;
    /// specify the record file drive letter
    /// (this is queried by META_Util_QueryDriveAvailableForFileSize_r first)
    /// The target will put the file to the root folder of recordDrive for example "c:\"
    /// the file name is always echo_record.out for example "c:\echo_record.out"
    short          recordDrive;
    /// the volume value pass to L1 (use index 6's value)
    unsigned char  outputDevice;
    unsigned char  outputVolume;
    unsigned char  inputDevice;
    unsigned char  inputVolume;
    unsigned char  sidetoneVolume;
} Audio_Ex_EchoLoopParam_T;
META_RESULT  __stdcall META_Audio_EX_StartEchoLoop(unsigned int ms_timeout, const Audio_Ex_EchoLoopParam_T* param, int* status);
META_RESULT  __stdcall META_Audio_EX_StartEchoLoop_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_EchoLoopParam_T* param, int* status);
typedef struct
{
    /// total number of samples
    unsigned int totalSamples;
    /// progress
    unsigned int progress;
    /// stop flag
    int stop;
} Audio_Ex_QueryEchoLoop_T;
META_RESULT  __stdcall META_Audio_EX_QueryEchoLoop(unsigned int ms_timeout, Audio_Ex_QueryEchoLoop_T* status);
META_RESULT  __stdcall META_Audio_EX_QueryEchoLoop_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_QueryEchoLoop_T* status);
META_RESULT  __stdcall META_Audio_EX_StopEchoLoop(unsigned int ms_timeout, int* status);
META_RESULT  __stdcall META_Audio_EX_StopEchoLoop_r(const int meta_handle, unsigned int ms_timeout, int* status);
typedef struct
{
    unsigned int playingRate;
    unsigned int recordingRate;
} Audio_Ex_QueryEchoLoopDataRate_T;
META_RESULT  __stdcall META_Audio_EX_QueryEchoLoopDataRate(unsigned int ms_timeout, unsigned int format, Audio_Ex_QueryEchoLoopDataRate_T* info);
META_RESULT  __stdcall META_Audio_EX_QueryEchoLoopDataRate_r(const int meta_handle, unsigned int ms_timeout, unsigned int format, Audio_Ex_QueryEchoLoopDataRate_T* info);
typedef enum
{
    MEDIA_SPEECH_FEATURE_NONE = 0x00000000,
    MEDIA_SPEECH_FEATURE_NB_DMNR = 0x00000001,
    MEDIA_SPEECH_FEATURE_WB_DMNR = 0x00000002,
    MEDIA_SPEECH_FEATURE_WB_LINK_SUPPORT = 0x00000004,
    MEDIA_SPEECH_FEATURE_HD_RECORD = 0x00000008,
    MEDIA_SPEECH_FEATURE_STEREO_RECORD = 0x00000010,
} Media_Speech_Feature;
META_RESULT __stdcall META_Audio_EX_QuerySpeechCapability(unsigned int ms_timeout, unsigned int* capability);
META_RESULT __stdcall META_Audio_EX_QuerySpeechCapability_r(const int meta_handle, unsigned int ms_timeout, unsigned int* capability);
typedef struct
{
    short          numberOfSpeechEnhancementMode;     /**< \brief the number of speech enhancement mode */
    unsigned short bufferLengthOfEachModeName;        /**< \brief buffer length of each speech enhancement mode name */
    short          numberOfSpeechEnhancementCategory; /**< \brief the number of categories for speech enhancement */
    unsigned short bufferLengthOfEachCategoryName;    /**< \brief buffer length of each speech enhancement category name */
} Audio_Ex_SpeechEnhancementParam_T;
META_RESULT __stdcall META_Audio_EX_QueryParamsOfSpeechEnhancement(unsigned int ms_timeout, Audio_Ex_SpeechEnhancementParam_T* param);
META_RESULT __stdcall META_Audio_EX_QueryParamsOfSpeechEnhancement_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_SpeechEnhancementParam_T* param);
typedef struct
{
    unsigned int bufferLength; /**< \brief [IN] the length of buffer */
    char*        buffer;       /**< \brief [OUT] buffer for names of speech enhancement mode or speech enhancement category */
} Audio_Ex_SpeechEnhancementNameBuffer_T;
META_RESULT __stdcall META_Audio_EX_QueryNamesOfSpeechEnhancementModes(unsigned int ms_timeout, Audio_Ex_SpeechEnhancementNameBuffer_T* cnf);
META_RESULT __stdcall META_Audio_EX_QueryNamesOfSpeechEnhancementModes_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_SpeechEnhancementNameBuffer_T* cnf);
META_RESULT __stdcall META_Audio_EX_QueryNamesOfSpeechEnhancementCategories(unsigned int ms_timeout, Audio_Ex_SpeechEnhancementNameBuffer_T* cnf);
META_RESULT __stdcall META_Audio_EX_QueryNamesOfSpeechEnhancementCategories_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_SpeechEnhancementNameBuffer_T* cnf);
typedef struct
{
    unsigned int bufferLength; /**< \brief [IN] the length of buffer */
    short*       buffer;       /**< \brief [OUT] buffer for category ID of each speech enhancement mode */
} Audio_Ex_SpeechEnhancementCategoryBuffer_T;
META_RESULT __stdcall META_Audio_EX_QueryCategoryIdOfSpeechEnhancementMode(unsigned int ms_timeout, Audio_Ex_SpeechEnhancementCategoryBuffer_T* cnf);
META_RESULT __stdcall META_Audio_EX_QueryCategoryIdOfSpeechEnhancementMode_r(const int meta_handle, unsigned int ms_timeout, Audio_Ex_SpeechEnhancementCategoryBuffer_T* cnf);
typedef struct
{
    unsigned char isWideBand;   /**< \brief [IN] 0 is narrow band (8k), >0 is wide band(16k) */
    unsigned char isOutputFir;  /**< \brief [IN] 0 is for input FIR, >0 is for output FIR */
} Audio_Ex_SpeechFirReq_T;
typedef struct
{
    short numberOfAllFIRMode; /**< \brief [OUT] the number of speech FIR mode */
} Audio_Ex_SpeechFirParam_T;
META_RESULT __stdcall META_Audio_EX_QueryParamsOfSpeechFIR(unsigned int ms_timeout, const Audio_Ex_SpeechFirReq_T* req, Audio_Ex_SpeechFirParam_T* param);
META_RESULT __stdcall META_Audio_EX_QueryParamsOfSpeechFIR_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_SpeechFirReq_T* req, Audio_Ex_SpeechFirParam_T* param);
META_RESULT __stdcall META_Audio_EX_QueryFlexibleEqBandNumber(unsigned int ms_timeout, short* count);
META_RESULT __stdcall META_Audio_EX_QueryFlexibleEqBandNumber_r(const int meta_handle, unsigned int ms_timeout, short* count);
META_RESULT __stdcall META_Audio_EX_SetFlexibleEq(unsigned int ms_timeout, char on_off);
META_RESULT __stdcall META_Audio_EX_SetFlexibleEq_r(const int meta_handle, unsigned int ms_timeout, char on_off);
typedef struct
{
    unsigned int bufferLength; /**< \brief [IN] the length of buffer */
    char*        buffer;       /**< \brief [IN] buffer for the Flexible EQ parameter setting (init parameters or magnitude) */
} Audio_Ex_FlexibleEqBuffer_T;
META_RESULT __stdcall META_Audio_EX_SetFlexibleEqMagnitude(unsigned int ms_timeout, const Audio_Ex_FlexibleEqBuffer_T* req);
META_RESULT __stdcall META_Audio_EX_SetFlexibleEqMagnitude_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_FlexibleEqBuffer_T* req);
META_RESULT __stdcall META_Audio_EX_SetFlexibleEqInitParam(unsigned int ms_timeout, const Audio_Ex_FlexibleEqBuffer_T* req);
META_RESULT __stdcall META_Audio_EX_SetFlexibleEqInitParam_r(const int meta_handle, unsigned int ms_timeout, const Audio_Ex_FlexibleEqBuffer_T* req);


#ifdef __MTK_INTERNAL__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //#ifdef __MTK_INTERNAL__

#ifdef __cplusplus
}
#endif

#endif
